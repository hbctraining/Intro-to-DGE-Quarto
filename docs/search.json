[
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html",
    "href": "lessons/01a_RNAseq_processing_workflow.html",
    "title": "From raw sequence reads to count matrix",
    "section": "",
    "text": "Approximate time: 40 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives",
    "title": "From raw sequence reads to count matrix",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand the different steps of the RNA-seq workflow, from RNA extraction to assessing the expression levels of genes.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#rna-extraction-and-library-preparation",
    "href": "lessons/01a_RNAseq_processing_workflow.html#rna-extraction-and-library-preparation",
    "title": "From raw sequence reads to count matrix",
    "section": "1. RNA extraction and library preparation",
    "text": "1. RNA extraction and library preparation\nBefore RNA can be sequenced, it must first be extracted and separated from its cellular environment and prepared into a cDNA library. There are a number of steps involved which are outlined in the figure below, and in parallel there are various quality checks implemented to make sure we have good quality RNA to move forward with. We briefly describe some of these steps below.\na. Enriching for RNA. Once the sample has been treated with DNAse to remove any contaminating DNA sequence, the sample undergoes either selection of the mRNA (polyA selection) or depletion of the rRNA.\nGenerally, ribosomal RNA represents the majority of the RNAs present in a cell, while messenger RNAs represent a small percentage of total RNA (~2% in humans). Therefore, if we want to study the protein-coding genes, we need to enrich for mRNA or deplete the rRNA. For differential gene expression analysis, it is best to enrich for Poly(A)+, unless you are aiming to obtain information about long non-coding RNAs, in which case ribosomal RNA depletion is recommended.\n\n\n\n\n\n\nRNA Quality check\n\n\n\nIt is essential to check for the integrity of the extracted RNA prior to starting the cDNA library prepation. Traditionally, RNA integrity was assessed via gel electrophoresis by visual inspection of the ribosomal RNA bands, but that method is time-consuming and imprecise. The Bioanalyzer system from Agilent will rapidly assess RNA integrity and calculate an RNA Integrity Number (RIN), which facilitates the interpretation and reproducibility of RNA quality. RIN, essentially, provides a means by which RNA quality from different samples can be compared to each other in a standardized manner.\n\n\nb. Fragmentation and size selection. The remaining RNA molecules are then fragmented. This is done either via chemical, enzymatic (e.g., RNAses), or physical processes (e.g., chemical/mechanical shearing). These fragments then undergo size selection to retain only those fragments within a size range that Illumina sequencing machines can handle best, i.e., between 150 to 300 bp.\n\n\n\n\n\n\nFragment size quality check\n\n\n\nAfter size selection/exclusion, the fragment size distribution should be assesed to ensure that it is unimodal and well-defined.\n\n\nc. Reverse transcribe RNA into double-stranded cDNA. Information about which strand a fragment originated from can be preserved by creating stranded libraries. The most commonly used method incorporates deoxy-UTP during the synthesis of the second cDNA strand (Levin JZ et al., 2010). Once double-stranded cDNA fragments are generated, sequence adapters are ligated to the ends. (Size selection can be performed here instead of at the RNA level.)\nd. PCR amplification. If the amount of starting material is low and/or to increase the number of cDNA molecules to an amount sufficient for sequencing, libraries are usually PCR amplified. Run as few amplification cycles as possible to avoid PCR artefacts.\n\n\n\nImage source: Zeng W and Mortazavi A, 2012",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#sequencing-illumina",
    "href": "lessons/01a_RNAseq_processing_workflow.html#sequencing-illumina",
    "title": "From raw sequence reads to count matrix",
    "section": "2. Sequencing (Illumina)",
    "text": "2. Sequencing (Illumina)\nSequencing of the cDNA libraries will generate reads. Reads correspond to the nucleotide sequences of the ends of each of the cDNA fragements in the library. You will have the choice of sequencing either a single end of the cDNA fragments (single-end reads) or both ends of the fragments (paired-end reads).\n\n\n\n\nSE - Single end dataset =&gt; Only Read1\nPE - Paired-end dataset =&gt; Read1 + Read2\n\ncan be 2 separate FastQ files or just one with interleaved pairs\n\n\nGenerally single-end sequencing is sufficient unless it is expected that the reads will match multiple locations on the genome (e.g. organisms with many paralogous genes), assemblies are being performed, or for splice isoform differentiation. Be aware that paired-end reads are generally 2x more expensive.\n\nSequencing-by-synthesis\nIllumina sequencing technology uses a sequencing-by-synthesis approach. To explore sequencing by synthesis in more depth, please watch this linked video on Illumina’s YouTube channel.\nWe have privided a brief explanation of the steps below:\nCluster growth: The DNA fragments in the cDNA library are denatured and hybridized to the glass flowcell (adapter complementarity). Each fragment is then clonally amplified, forming a cluster of double-stranded DNA. This step is necessary to ensure that the sequencing signal will be strong enough to be detected/captured unambiguously for each base of each fragment.\n\nNumber of clusters ~= Number of reads\n\nSequencing: The sequencing of the fragment ends is based on fluorophore-labelled dNTPs with reversible terminator elements. In each sequencing cycle, a base is incorporated into every cluster and excited by a laser.\nImage acquisition: Each dNTP has a distinct excitatory signal emission that is captured by cameras.\nBase calling: The Base calling program will then generate the sequence of bases, i.e. reads, for each fragement/cluster by assessing the images captured during the many sequencing cycles. In addition to calling the base in every position, the base caller will also report the certainty with which it was able to make the call (quality information).\n\nNumber of sequencing cycles = Length of reads",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#quality-control-of-raw-sequencing-data-fastqc",
    "href": "lessons/01a_RNAseq_processing_workflow.html#quality-control-of-raw-sequencing-data-fastqc",
    "title": "From raw sequence reads to count matrix",
    "section": "3. Quality control of raw sequencing data (FastQC)",
    "text": "3. Quality control of raw sequencing data (FastQC)\nThe raw reads obtained from the sequencer are stored as FASTQ files. The FASTQ file format is the de facto file format for sequence reads generated from next-generation sequencing technologies.\nEach FASTQ file is a text file that represents sequence readouts for a sample. Each read is represented by 4 lines as shown below:\n@HWI-ST330:304:H045HADXX:1:1101:1111:61397\nCACTTGTAAGGGCAGGCCCCCTTCACCCTCCCGCTCCTGGGGGANNNNNNNNNNANNNCGAGGCCCTGGGGTAGAGGGNNNNNNNNNNNNNNGATCTTGG\n+\n@?@DDDDDDHHH?GH:?FCBGGB@C?DBEGIIIIAEF;FCGGI#########################################################\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nAlways begins with ‘@’ and then information about the read\n\n\n2\nThe actual DNA sequence\n\n\n3\nAlways begins with a ‘+’ and sometimes the same info as in line 1\n\n\n4\nHas a string of characters which represent the quality scores; must have same number of characters as line 2\n\n\n\nFastQC is a commonly used software that provides a simple way to do some quality control checks on raw sequence data.\nThe main functions include:\n\nProviding a quick overview to tell you in which areas there may be problems\nSummary graphs and tables to quickly assess your data\nExport of results to an HTML-based permanent report",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#quantify-expression",
    "href": "lessons/01a_RNAseq_processing_workflow.html#quantify-expression",
    "title": "From raw sequence reads to count matrix",
    "section": "4. Quantify expression",
    "text": "4. Quantify expression\nOnce we have explored the quality of our raw reads, we can move on to quantifying expression at the transcript level. The goal of this step is to identify from which transcript each of the reads originated from and the total number of reads associated with each transcript.\nTools that have been found to be most accurate for this step in the analysis are referred to as lightweight alignment tools, which include:\n\nKallisto,\nSailfish and\nSalmon\n\nEach of the tools in the list above work slightly differently from one another. However, common to all of them is that they avoid base-to-base genomic alignment of the reads. Genomic alignment is a step performed by older splice-aware alignment tools such as STAR and HISAT2. In comparison to these tools, the lightweight alignment tools not only provide quantification estimates faster (typically more than 20 times faster), but also prove improvements in accuracy (Robert C and Watson M, 2015).\nWe will use the expression estimates, often referred to as ‘pseudocounts’, obtained from Salmon as the starting point for the differential gene expression analysis.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#quality-control-of-aligned-sequence-reads-starqualimap",
    "href": "lessons/01a_RNAseq_processing_workflow.html#quality-control-of-aligned-sequence-reads-starqualimap",
    "title": "From raw sequence reads to count matrix",
    "section": "5. Quality control of aligned sequence reads (STAR/Qualimap)",
    "text": "5. Quality control of aligned sequence reads (STAR/Qualimap)\nAs mentioned above, the differential gene expression analysis will use transcript/gene pseudocounts generated by Salmon. However, to perform some basic quality checks on the sequencing data, it is important to align the reads to the whole genome. Either STAR or HiSAT2 are able to perform this step and generate a BAM file that can be used for QC.\nA tool called Qualimap explores the features of aligned reads in the context of the genomic region they map to, hence providing an overall view of the data quality (as an HTML file). Various quality metrics assessed by Qualimap include:\n\nDNA or rRNA contamination\n5’-3’ biases\nCoverage biases",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#quality-control-aggregating-results-with-multiqc",
    "href": "lessons/01a_RNAseq_processing_workflow.html#quality-control-aggregating-results-with-multiqc",
    "title": "From raw sequence reads to count matrix",
    "section": "6. Quality control: aggregating results with MultiQC",
    "text": "6. Quality control: aggregating results with MultiQC\nThroughout the workflow we have performed various steps of quality checks on our data. You will need to do this for every sample in your dataset, making sure these metrics are consistent across the samples for a given experiment. Outlier samples should be flagged for further investigation and potential removal.\nManually tracking these metrics and browsing through multiple HTML reports (FastQC, Qualimap) and log files (Salmon, STAR) for each samples is tedious and prone to errors. MultiQC is a tool that aggregates results from several tools and generates a single HTML report with plots to visualize and compare various QC metrics between the samples. Assessment of the QC metrics may result in the removal of samples before proceeding to the next step, if necessary.\n\nOnce the QC has been performed on all the samples, we are ready to get started with Differential Gene Expression analysis with DESeq2!",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nIntroduction to Differential Gene Expression Analysis\n\n\n\nAudience\nComputational skills required\nDuration\n\n\n\n\nBiologists\nIntroduction to R\n4-session online workshop (~8 hours of trainer-led time)\n\n\n\n\nDescription\nThis repository has teaching materials for a hands-on Introduction to Differential Gene Expression Analysis workshop. The workshop will lead participants through performing a differential gene expression analysis workflow on RNA-seq count data using R/RStudio. Working knowledge of R is required or completion of the Introduction to R workshop.\nNote for Trainers: Please note that the schedule linked below assumes that learners will spend between 3-4 hours on reading through, and completing exercises from selected lessons between classes. The online component of the workshop focuses on more exercises and discussion/Q & A.\n\n\n\n\n\n\nNote\n\n\n\nThese materials were developed for a trainer-led workshop, but are also amenable to self-guided learning.\n\n\n\n\nLearning Objectives\n\nQC on count data using Principal Component Analysis (PCA) and hierarchical clustering\nUsing DESeq2 to obtain a list of significantly different genes\nVisualizing expression patterns of differentially expressed genes\nPerforming functional analysis on gene lists with R-based tools\n\n\n\nLessons\n\nWorkshop schedule (trainer-led learning)\nSelf-learning\n\n\n\nInstallation Requirements\n\nApplications\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.0.0 or above)\nRStudio\n\n\n\nPackages for R\n\n\n\n\n\n\nNotes\n\n\n\nNote 1: Install the packages in the order listed below.\nNote 2:  All the package names listed below are case sensitive!\nNote 3: If you have a Mac with an M1 chip, download and install this tool before installing your packages: https://mac.r-project.org/tools/gfortran-12.2-universal.pkg\nNote 4: At any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\nNote 5: If you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n\n(1) Install the 6 packages listed below from CRAN using the install.packages() function. You DO NOT have to go to the CRAN webpage; you can use the following function to install them one by one.\n\nBiocManager\ntidyverse\nRColorBrewer\npheatmap\nggrepel\ncowplot\n\nPlease install them one-by-one as follows:\n\ninstall.packages(\"BiocManager\")\ninstall.packages(\"tidyverse\")\n# & so on ...\n\n(2) Install the 10 packages listed below from Bioconductor using the the BiocManager::install() function.\n\nDESeq2\nclusterProfiler\nDOSE\norg.Hs.eg.db\npathview\nDEGreport\ntximport\nAnnotationHub\nensembldb\napeglm\n\n\n\n\n\n\n\nNote\n\n\n\nNOTE: The library used for the annotations associated with genes (here we are using org.Hs.eg.db) will change based on organism (e.g. if studying mouse, would need to install and load org.Mm.eg.db). The list of different organism packages are given here.\n\n\nPlease install them one-by-one as follows:\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"clusterProfiler\")\n# & so on ...\n\n(3) Finally, please check that all the packages were installed successfully by loading them one at a time using the library() function.\n\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(ggrepel)\nlibrary(cowplot)\nlibrary(clusterProfiler)\nlibrary(DEGreport)\nlibrary(org.Hs.eg.db)\nlibrary(DOSE)\nlibrary(pathview)\nlibrary(tximport)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(apeglm)\n\n(4) Once all packages have been loaded, run sessionInfo().\n\nsessionInfo()\n\n\n\n\n\nCitation\nTo cite material from this course in your publications, please use:\n\n\n\n\n\n\nCitation\n\n\n\nMeeta Mistry, Mary Piper, Jihe Liu, & Radhika Khetani. (2021, May 24). hbctraining/DGE_workshop_salmon_online: Differential Gene Expression Workshop Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.4783481. RRID:SCR_025373.\n\n\nA lot of time and effort went into the preparation of these materials. Citations help us understand the needs of the community, gain recognition for our work, and attract further funding to support our teaching activities. Thank you for citing this material if it helped you in your data analysis."
  },
  {
    "objectID": "lessons/experimental_planning_considerations.html",
    "href": "lessons/experimental_planning_considerations.html",
    "title": "Experimental design considerations",
    "section": "",
    "text": "Approximate time: 50 minutes",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/experimental_planning_considerations.html#learning-objectives",
    "href": "lessons/experimental_planning_considerations.html#learning-objectives",
    "title": "Experimental design considerations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the importance of replicates for RNA-seq differential expression experiments\nExplain the relationship between the number of biological replicates, sequencing depth, and the differentially expressed genes identified\nDemonstrate how to design an RNA-seq experiment that avoids confounding and batch effects",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/experimental_planning_considerations.html#replicates",
    "href": "lessons/experimental_planning_considerations.html#replicates",
    "title": "Experimental design considerations",
    "section": "Replicates",
    "text": "Replicates\nExperimental replicates can be performed as technical replicates or biological replicates.\n\nImage credit: Klaus B, 2015\n\nTechnical replicates: use the same biological sample to repeat the technical or experimental steps in order to accurately measure technical variation and remove it during analysis.\nBiological replicates use different biological samples of the same condition to measure the biological variation between samples.\n\nIn the days of microarrays, technical replicates were considered a necessity; however, with the current RNA-seq technologies, technical variation is much lower than biological variation and technical replicates are unneccessary.\nIn contrast, biological replicates are absolutely essential for differential expression analysis. For mice or rats, this might be easy to determine what constitutes a different biological sample, but it’s a bit more difficult to determine for cell lines. This article gives some great recommendations for cell line replicates.\nFor differential expression analysis, the more biological replicates, the better the estimates of biological variation and the more precise our estimates of the mean expression levels. This leads to more accurate modeling of our data and identification of more differentially expressed genes.\n\nImage credit: Liu Y et al., 2014\nAs the figure above illustrates, biological replicates are of greater importance than sequencing depth, which is the total number of reads sequenced per sample. The figure shows the relationship between sequencing depth and number of replicates on the number of differentially expressed genes identified [1]. Note that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.\n\n\n\n\n\n\nSample pooling\n\n\n\nTry to avoid pooling of individuals/experiments, if possible; however, if absolutely necessary, then each pooled set of samples would count as a single replicate. To ensure similar amounts of variation between replicates, you would want to pool the same number of individuals for each pooled set of samples.\nFor example, if you need at least 3 individuals to get enough material for your control replicate and at least 5 individuals to get enough material for your treatment replicate, you would pool 5 individuals for the control and 5 individuals for the treatment condition. You would also make sure that the individuals that are pooled in both conditions are similar in sex, age, etc.\n\n\nReplicates are almost always preferred to greater sequencing depth for bulk RNA-seq. However, guidelines depend on the experiment performed and the desired analysis. Below we list some general guidelines for replicates and sequencing depth to help with experimental planning:\n\nGeneral gene-level differential expression:\n\nENCODE guidelines suggest 30 million SE reads per sample (stranded).\n15 million reads per sample is often sufficient, if there are a good number of replicates (&gt;3).\nSpend money on more biological replicates, if possible.\nGenerally recommended to have read length &gt;= 50 bp.\n\nGene-level differential expression with detection of lowly-expressed genes:\n\nSimilarly benefits from replicates more than sequencing depth.\nSequence deeper with at least 30-60 million reads depending on level of expression (start with 30 million with a good number of replicates).\nGenerally recommended to have read length &gt;= 50 bp.\n\nIsoform-level differential expression:\n\nFor known isoforms, suggested to have a depth of at least 30 million reads per sample and paired-end reads.\nFor novel isoforms, should have more depth (&gt; 60 million reads per sample).\nChoose biological replicates over paired/deeper sequencing.\nGenerally recommended to have read length &gt;= 50 bp, but longer is better as the reads will be more likely to cross exon junctions.\nPerform careful QC of RNA quality. Be careful to use high quality preparation methods and restrict analysis to high quality RIN # samples.\n\nOther types of RNA analyses (intron retention, small RNA-Seq, etc.):\n\nDifferent recommendations depending on the analysis.\nAlmost always more biological replicates are better!\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe factor used to estimate the depth of sequencing for genomes is “coverage” - how many times do the number of nucleotides sequenced “cover” the genome. This metric is not exact for genomes (whole genome sequencing), but it is good enough and is used extensively. However, the metric does not work for transcriptomes because even though you may know what % of the genome has transcriptional activity, the expression of the genes is highly variable.",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/experimental_planning_considerations.html#confounding",
    "href": "lessons/experimental_planning_considerations.html#confounding",
    "title": "Experimental design considerations",
    "section": "Confounding",
    "text": "Confounding\nA confounded RNA-seq experiment is one where you cannot distinguish the separate effects of two different sources of variation in the data.\nFor example, we know that sex has large effects on gene expression, and if all of our control mice were female and all of the treatment mice were male, then our treatment effect would be confounded by sex. We could not differentiate the effect of treatment from the effect of sex.\n\nTo AVOID confounding:\n\nEnsure animals in each condition are all the same sex, age, litter, and batch, if possible.\nIf not possible, then ensure to split the animals equally between conditions",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/experimental_planning_considerations.html#batch-effects",
    "href": "lessons/experimental_planning_considerations.html#batch-effects",
    "title": "Experimental design considerations",
    "section": "Batch effects",
    "text": "Batch effects\nBatch effects are a significant issue for RNA-seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC et al., 2015\nThe issues generated by poor batch study design are highlighted nicely in Gilad Y & Mizrahi-Man O, 2015.\n\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\n\n\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC et al., 2015\nDO split replicates of the different sample groups across batches. The more replicates, the better (definitely more than 2).\n\nImage credit: Hicks SC et al., 2015\nDO include batch information in your experimental metadata. During the analysis, we can regress out the variation due to batch if not confounded so it doesn’t affect our results – if we have that information.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe sample preparation of cell line “biological” replicates “should be performed as independently as possible” (as batches), “meaning that cell culture media should be prepared freshly for each experiment, different frozen cell stocks and growth factor batches, etc. should be used [2].” However, preparation across all conditions should be performed at the same time.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nYour experiment has three different treatment groups, A, B, and C. Due to the lengthy process of tissue extraction, you can only isolate the RNA from two samples at the same time. You plan to have 4 replicates per group. Your metadata table is as follows:\n\n\n\nsample\ntreatment\nsex\nreplicate\nRNA isolation\n\n\n\n\nsample1\nA\nF\n1\n\n\n\nsample2\nA\nF\n2\n\n\n\nsample3\nA\nM\n3\n\n\n\nsample4\nA\nM\n4\n\n\n\nsample5\nB\nF\n1\n\n\n\nsample6\nB\nF\n2\n\n\n\nsample7\nB\nM\n3\n\n\n\nsample8\nB\nM\n4\n\n\n\nsample9\nC\nF\n1\n\n\n\nsample10\nC\nF\n2\n\n\n\nsample11\nC\nM\n3\n\n\n\nsample12\nC\nM\n4\n\n\n\n\nClick here to download the above table as an Excel file.\n\nFill in the RNA isolation column of the metadata table. Since we can only prepare 2 samples at a time and we have 12 samples total, you will need to isolate RNA in 6 batches. In the RNA isolation column, enter one of the following values for each sample: group1, group2, group3, group4, group5, group6. Make sure to fill in the table so as to avoid confounding by batch of RNA isolation.\nBONUS: To perform the RNA isolations more quickly, you devote two researchers to perform the RNA isolations. Create a researcher column and fill in the researchers’ initials for the samples they will prepare: use initials AB or CD.\n\nAnswer Key",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/01b_DGE_setup_and_overview.html",
    "href": "lessons/01b_DGE_setup_and_overview.html",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01b_DGE_setup_and_overview.html#learning-objectives",
    "href": "lessons/01b_DGE_setup_and_overview.html#learning-objectives",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the RNA-seq and differential gene expression analysis workflows\nExplain the experiment and its objectives\nCreate a project in R\nSet up for the analysis of RNA-seq data",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01b_DGE_setup_and_overview.html#review-of-the-dataset",
    "href": "lessons/01b_DGE_setup_and_overview.html#review-of-the-dataset",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Review of the dataset",
    "text": "Review of the dataset\nFor this workshop, we will be using a publicly available RNA-seq dataset that is part of a larger study described in Kenny PJ et al., 2014.\nThe RNA-seq was performed on HEK293F cells that were transfected either with a MOV10 transgene, siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below.\nUsing these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition.\n\n\n\n\n\n\n\n\n\nWhat is the purpose of these datasets? What does Mov10 do?\n\n\n\nThe authors are investigating interactions between various genes involved in Fragile X syndrome, a disease in which there is aberrant production of the FMRP protein.\nFMRP, a protein that is “most commonly found in the brain, is essential for normal cognitive development and female reproductive function. Mutations of this gene can lead to fragile X syndrome, intellectual disability, premature ovarian failure, autism, Parkinson’s disease, developmental delays and other cognitive deficits.” - from Wikipedia\nMOV10 is a putative RNA helicase that is also associated with FMRP in the context of the microRNA pathway.\n\n\nThe hypothesis the paper is testing is that FMRP and MOV10 associate and regulate the translation of a subset of RNAs.\n\n\n\nOur questions:\n\nWhat patterns of expression can we identify with the loss or gain of MOV10?\nAre there any genes shared between the two conditions?",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01b_DGE_setup_and_overview.html#rna-seq-workflow",
    "href": "lessons/01b_DGE_setup_and_overview.html#rna-seq-workflow",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "RNA-seq workflow",
    "text": "RNA-seq workflow\nFor this dataset, raw sequence reads were obtained from the Sequence Read Archive (SRA). These reads were then processed using the RNA-seq workflow as detailed in the pre-reading for this workshop. All steps were performed on the command line (Linux/Unix), including a thorough quality control assessment. If you are interested, we have the MultiQC html report for this dataset linked here for you to peruse.\nThe directories of output from the mapping/quantification step of the workflow (Salmon) is the data that we will be using. These transcript abundance estimates, often referred to as ‘pseudocounts’, will be the starting point for our differential gene expression analysis.",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01b_DGE_setup_and_overview.html#setting-up",
    "href": "lessons/01b_DGE_setup_and_overview.html#setting-up",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Setting up",
    "text": "Setting up\nLet’s get started by opening up RStudio and setting up a new project for this analysis.\n\nGo to the File menu and select New Project.\nIn the New Project window, choose New Directory. Then, choose New Project. Name your new directory DEanalysis and then “Create the project as subdirectory of:” the Desktop (or location of your choice).\nThe new project should automatically open in RStudio.\n\n\n\n\nTo check whether or not you are in the correct working directory, use getwd(). The path Desktop/DEanalysis should be returned to you in the console. Within your working directory, use the New folder button in the bottom right panel to create two new directories: meta and results. Remember the key to a good analysis is keeping organized from the start! (NOTE: we will be downloading our data folder.)\nNow we need to grab the files that we will be working with for the analysis. There are two things we need to download.\n\nFirst we need the Salmon results for the full dataset. Right click on the links below, and choose the “Save link as …” option to download directly into your project directory:\n\n\nSalmon data for the Mov10 full dataset\n\nOnce you have the zip file downloaded you will want to decompress it. This will create a data directory with sub-directories that correspond to each of the samples in our dataset.\n\nNext, we need the annotation file that maps our transcript identifiers to gene identifiers. We have created this file for you using the R Bioconductor package AnnotationHub. For now, we will use it as is, but later in the workshop we will spend some time showing you how to create one for yourself. Right click on the links below, and choose the “Save link as …” option to download directly into the data folder in your project directory.\n\n\nAnnotation file\n\nFinally, go to the File menu and select New File, then select R Script. This should open up a script editor in the top left hand corner. This is where we will be typing and saving all commands required for this analysis. In the script editor, type in header lines:\n\n# HBC RNA-seq DGE workshop\n# Gene-level differential expression analysis using DESeq2\n\nNow save the file as de_script.R within your project directory. When finished, your project directory should now look similar to this:\n\n\nLoading libraries\nFor this analysis we will be using several R packages, some which have been installed from CRAN and others from Bioconductor. To use these packages (and the functions contained within them), we need to load the libraries. Add the following to your script and don’t forget to comment liberally!\n\n# Setup\n# Bioconductor and CRAN libraries used\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(DEGreport)\nlibrary(tximport)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n\n\nLoading data\nThe main output of Salmon is a quant.sf file, and we have one of these for each individual sample in our dataset. A screenshot of the file is displayed below:\n\nFor each transcript that was assayed in the reference, we have:\n\nThe transcript identifier\nThe transcript length (in bp)\nThe effective length (described in detail below)\nTPM (transcripts per million), which is computed using the effective length\nThe estimated read count (‘pseudocount’)\n\n\n\n\n\n\n\nWhat exactly is the effective length?\n\n\n\nThe effective length for a transcript is the essentially the number of possible start positions for a read or fragment within that transcript. The sequence composition of a transcript affects how many reads are sampled from it. While two transcripts might be of identical actual length, depending on the sequence composition we are more likely to generate fragments from one versus the other. The transcript that has a higher likelihood of being sampled will end up with the larger effective length. The effective length is transcript length that has been “corrected” to include factors due to sequence-specific and GC biases.\n\n\nWe will be using the R Bioconductor package tximport to prepare the quant.sf files for DESeq2. The first thing we need to do is create a variable that contains the paths to each of our quant.sf files. Then we will add names to our quant files, which will allow us to easily distinguish between samples in the final output matrix.\n\n# List all directories containing data  \nsamples &lt;- list.files(path = \"./data\", full.names = TRUE, pattern = \"salmon$\")\n\n# Obtain a vector of all filenames including the path\nfiles &lt;- file.path(samples, \"quant.sf\")\n\n# Since all quant files have the same name, it is useful to have names for each element\nnames(files) &lt;- str_replace(samples, \"./data/\", \"\") %&gt;% \n                str_replace(\".salmon\", \"\")\n\nOur Salmon index was generated with transcript sequences listed by Ensembl IDs, but tximport needs to know which genes these transcripts came from. We will use the annotation table that we downloaded to extract transcript to gene information.\n\n# Load the annotation table for GrCh38\ntx2gene &lt;- read.delim(\"./data/tx2gene_grch38_ens94.txt\")\n\n# Take a look at it \ntx2gene %&gt;% head()\n\n            tx_id         ensgene     symbol\n1 ENST00000387314 ENSG00000210049      MT-TF\n2 ENST00000389680 ENSG00000211459    MT-RNR1\n3 ENST00000387342 ENSG00000210077      MT-TV\n4 ENST00000387347 ENSG00000210082    MT-RNR2\n5 ENST00000612848 ENSG00000276345 AC004556.1\n6 ENST00000386347 ENSG00000209082     MT-TL1\n\n\ntx2gene is a three-column data frame linking transcript ID (column 1) to gene ID (column 2) to gene symbol (column 3). We will take the first two columns as input to tximport. The column names are not relevant, but the column order is (i.e., transcript ID must be first).\nNow we are ready to run tximport.\n\n?tximport # let's take a look at the arguments for the tximport function\n\nThe tximport() function imports transcript-level estimates from various external software (e.g., Salmon, Kallisto) and summarizes to the gene-level (default) or outputs transcript-level matrices. There are optional arguments to use the abundance estimates as they appear in the quant.sf files or to calculate alternative values.\nFor our analysis we need non-normalized or “raw” count estimates at the gene-level for performing DESeq2 analysis.\nSince the gene-level count matrix is a default (txOut=FALSE) there is only one additional argument for us to modify to specify how to obtain our “raw” count values. The options for countsFromAbundance are as follows:\n\nno (default): This will take the values in TPM (as our scaled values) and NumReads (as our “raw” counts) columns, and collapse it down to the gene-level.\nscaledTPM: This is taking the TPM scaled up to library size as our “raw” counts.\nlengthScaledTPM: This is used to generate the “raw” count table from the TPM (rather than summarizing the NumReads column). “Raw” count values are generated by using the TPM value x featureLength x library size. These represent quantities that are on the same scale as original counts, except no longer correlated with transcript length across samples.\n\n\n\n\n\n\n\nLet’s review how TPM values are calculated:\n\n\n\n\nDivide the read counts by the length of each gene in kilobases. This gives you reads per kilobase (RPK).\nCount up all the RPK values in a sample and divide this number by 1,000,000. This is your “per million” scaling factor.\nDivide the RPK values by the “per million” scaling factor. This gives you TPM.\n\n\n\n\n# Run tximport\ntxi &lt;- tximport(files, type = \"salmon\", tx2gene = tx2gene[,c(\"tx_id\", \"ensgene\")],\n                countsFromAbundance = \"lengthScaledTPM\")\n\n\n\n\n\n\n\nAn additional argument for tximport\n\n\n\nWhen performing your own analysis, you may find that the reference transcriptome file you obtain from Ensembl will have version numbers included on your identifiers (i.e., ENSG00000265439.2). This will cause a discrepancy with the tx2gene file, since the annotation databases don’t usually contain version numbers (i.e., ENSG00000265439). To get around this issue you can use the argument ignoreTxVersion = TRUE. The logical value indicates whether to split the tx id on the ‘.’ character to remove version information, for easier matching.\n\n\n\n\nViewing data\nThe txi object is a simple list containing matrices of the abundance, counts, and length. Another list element ‘countsFromAbundance’ carries through the character argument used in the tximport call. The length matrix contains the average transcript length for each gene, which can be used as an offset for gene-level analysis.\n\nattributes(txi)\n\n$names\n[1] \"abundance\"           \"counts\"              \"length\"             \n[4] \"countsFromAbundance\"\n\n\nWe will be using the txi object as is for input into DESeq2, but will save it until the next lesson. For now let’s take a look at the count matrix. You will notice that there are decimal values, so let’s round to the nearest whole number and convert it into a dataframe. We will save it to a variable called data that we can play with.\n\n# Look at the counts\ntxi$counts %&gt;% head()\n\n                 Irrel_kd_1  Irrel_kd_2 Irrel_kd_3  Mov10_kd_2 Mov10_kd_3\nENSG00000000003 4375.751722 3645.483112 2968.36018 6177.539799 3688.16902\nENSG00000000005   27.259410   29.304293   23.31638   36.534194   13.14787\nENSG00000000419 1478.158556 1287.569549  883.63968 2368.544452 1339.80470\nENSG00000000457  507.916351  404.538329  357.20364  934.274776  571.37608\nENSG00000000460 1393.739749 1164.378205  849.77430 2172.300020 1217.31401\nENSG00000000938    1.058214    1.054427    0.00000    1.780558    0.00000\n                Mov10_oe_1 Mov10_oe_2 Mov10_oe_3\nENSG00000000003 3343.09841 3114.21097 2079.30559\nENSG00000000005   25.25078   38.11501   22.47582\nENSG00000000419 1889.59603 1766.32555 1271.05675\nENSG00000000457  646.46620  591.44175  354.09067\nENSG00000000460 1183.43712 1138.51245  673.14907\nENSG00000000938    0.00000    0.00000    0.00000\n\n\n\n# Write the counts to an object\ndata &lt;- txi$counts %&gt;% \n  round() %&gt;% \n  data.frame()\n\n\n\n\n\n\n\nWhat if I don’t have Salmon pseudocounts as input?\n\n\n\nUntil recently, the standard approach for RNA-seq analysis had been to map our reads using a splice-aware aligner (e.g., STAR) and then use the resulting BAM files as input to counting tools like featureCounts and htseq-count to obtain our final expression matrix. The field has now moved towards using lightweight alignment tools like Salmon as standard practice. If you are still working with data generated using the older standard approach we have some materials linked here on using DESeq2 with a raw count matrix as your starting point.\n\n\n\n\nCreating metadata\nOf great importance is keeping track of the information about our data. At minimum, we need to at least have a file which maps our samples to the corresponding sample groups that we are investigating. We will use the column headers from the counts matrix as the row names of our metadata file and have a single column to identify each sample as “MOV10_overexpression”, “MOV10_knockdown”, or “control”.\n\n# Create a sample table / metadata\nsampletype &lt;- factor(c(rep(\"control\",              3),\n                       rep(\"MOV10_knockdown\",      2),\n                       rep(\"MOV10_overexpression\", 3)))\nmeta &lt;- data.frame(sampletype, row.names = colnames(txi$counts))\n\nNow we are all set to start our analysis!\n\nNext Lesson",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html",
    "href": "lessons/01c_RNAseq_count_distribution.html",
    "title": "Gene-level differential expression analysis",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#learning-objectives",
    "href": "lessons/01c_RNAseq_count_distribution.html#learning-objectives",
    "title": "Gene-level differential expression analysis",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the characteristics of RNA-seq count data\nCompare different mathematical models for count data\nIdentify the most appropriate model for RNA-seq count data\nExplain the benefits of biological replicates for identifying true differences between sample groups",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#count-matrix",
    "href": "lessons/01c_RNAseq_count_distribution.html#count-matrix",
    "title": "Gene-level differential expression analysis",
    "section": "Count matrix",
    "text": "Count matrix\nWhen we start our differential gene expression analysis we begin with a matrix summarizing the gene-level expression in each sample of your dataset. The rows in the matrix correspond to genes, and the columns correspond to samples. In each position of the matrix you will have an integer value representing the total number of sequence reads that originated from a particular gene in a sample.\n\n\n\nThe higher the number of counts indicates more reads are associated with that gene and suggests a higher level of expression of that gene. However, this is not necessarily true and we will delve deeper into this later in this lesson and in the course.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#characteristics-of-rna-seq-count-data",
    "href": "lessons/01c_RNAseq_count_distribution.html#characteristics-of-rna-seq-count-data",
    "title": "Gene-level differential expression analysis",
    "section": "Characteristics of RNA-seq count data",
    "text": "Characteristics of RNA-seq count data\nTo get an idea about how RNA-seq counts are distributed, let’s plot a histogram of the counts for a single sample, ‘Mov10_oe_1’:\n\n# Plot the distribution of counts for Mov10_oe_1\nggplot(data) +\n  geom_histogram(aes(x = Mov10_oe_1), stat = \"bin\", bins = 200) +\n  xlab(\"Raw expression counts\") +\n  ylab(\"Number of genes\")\n\n\n\n\n\n\n\n\nThis plot illustrates some common features of RNA-seq count data:\n\na low number of counts associated with a large proportion of genes\na long right tail due to the lack of any upper limit for expression\nlarge dynamic range\n\nLooking at the shape of the histogram, we see that it is not normally distributed. For RNA-seq data this will always be the case. Moreover, the underlying data, as we observed earlier, is integer counts instead rather than continuous measurements. We need to take these characteristics into account when deciding on what statistical model to use.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#modeling-count-data",
    "href": "lessons/01c_RNAseq_count_distribution.html#modeling-count-data",
    "title": "Gene-level differential expression analysis",
    "section": "Modeling count data",
    "text": "Modeling count data\nCount data in general can be modeled with various distributions:\n\nBinomial distribution: Gives you the probability of getting a number of heads upon tossing a coin a number of times. Based on discrete events and used in situations when you have a certain number of cases. Thus, it gives the probability of getting r events out of n trials.\nPoisson distribution: For use when the number of cases is very large (i.e., people who buy lottery tickets), but the probability of an event is very small (probability of winning). The Poisson is similar to the binomial as it is also based on discrete events, but used with data from an infinite sample. Thus it gives the probability of getting r events in a population. It is appropriate for data where mean == variance.\n\n\n\n\n\n\n\nNote\n\n\n\nDetails provided by Rafael Irizarry in the EdX class.\n\n\nSo what do we use for RNA-seq count data?\nWith RNA-Seq data, a very large number of RNAs are represented and the probability of pulling out a particular transcript is very small. This scenario is most similar to the lottery described above, suggesting that perhaps the Poisson distribution is most appropriate. However, this will depend on the relationship between mean and variance in our data.\n\nMean versus variance\nTo assess the properties of the data we are working with, we can use the three samples corresponding to the ‘Mov10 overexpression’ replicates. First compute a vector of mean values, then compute a vector of variance values. Finally, plot these values against each other to evaluate the relationship between them.\n\n# Calculate the mean and variance for each gene for the Mov10 overexpression replicates\n# The second argument '1' of 'apply' function indicates the function being applied to rows\n#     Use '2' if applied to columns\nmean_counts &lt;- apply(data[,6:8], 1, mean) \nvariance_counts &lt;- apply(data[,6:8], 1, var)\ndf &lt;- data.frame(mean_counts, variance_counts)\n\nYour plot should look like the scatterplot below. Each data point represents a gene and the red line represents x = y.\n\n# Plot the mean vs variance\nggplot(df) +\n  geom_point(aes(x = mean_counts, y = variance_counts)) + \n  scale_y_log10(limits = c(1,1e9)) +\n  scale_x_log10(limits = c(1,1e9)) +\n  # Add a line for x = y (slope = 1)\n  geom_abline(intercept = 0, slope = 1, color = \"red\")\n\n\n\n\n\n\n\n\n\nThe mean is not equal to the variance (the scatter of data points does not fall on the diagonal).\nFor the genes with high mean expression, the variance across replicates tends to be greater than the mean (scatter is above the red line).\nFor the genes with low mean expression we see quite a bit of scatter. We usually refer to this as “heteroscedasticity”. That is, for a given expression level in the low range we observe a lot of variability in the variance values.\n\n\n\n\n\n\n\nExercise\n\n\n\nEvaluate the relationship between mean and variance for the control replicates (Irrel_kd samples). Note the differences or similarities in the plot compared to the one using the overexpression replicates.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#an-alternative-the-negative-binomial-distribution",
    "href": "lessons/01c_RNAseq_count_distribution.html#an-alternative-the-negative-binomial-distribution",
    "title": "Gene-level differential expression analysis",
    "section": "An alternative: The Negative Binomial distribution",
    "text": "An alternative: The Negative Binomial distribution\nOur data fail to satisfy the criteria for a the Poisson distribution, and typical RNA-seq data will do the same. If the proportions of mRNA stayed exactly constant between the biological replicates for a sample group, we could expect a Poisson distribution (where mean == variance). However, we always expect some amount of variability between replicates (we’ll discuss this in more detail later in the lesson). Alternatively, if we continued to add more replicates (i.e., &gt; 20) we should eventually see the scatter start to reduce and the high expression data points move closer to the red line. So, in theory, if we had enough replicates we could use the Poisson.\nIn practice, a large number of replicates can be either hard to obtain (depending on how samples are obtained) and/or can be unaffordable. It is more common to see datasets with only a handful of replicates (~3-5) and reasonable amount of variation between them. The distribution that fits RNA-seq data best, given this type of variability between replicates, is the Negative Binomial. Essentially, the Negative Binomial is a good approximation for data where the mean &lt; variance, as is the case with RNA-Seq count data.\n\n\n\n\n\n\nNote\n\n\n\nIf we use the Poisson, this will underestimate variability, leading to an increase in false positive DE genes.\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nAn RNA-seq experiment was conducted on mice forebrain to evaluate the effect of increasing concentrations of a treatment. For each of the five different concentrations we have n = 5 mice, for a total of 25 samples. If we observed little to no variability between replicates, what might this suggest about our samples?\nWhat type of mean-variance relationship would you expect to see for this dataset?",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#replicates-and-variability",
    "href": "lessons/01c_RNAseq_count_distribution.html#replicates-and-variability",
    "title": "Gene-level differential expression analysis",
    "section": "Replicates and variability",
    "text": "Replicates and variability\nBiological replicates represent multiple samples (e.g., RNA from different mice) that correspond to the same sample class or group. Intuitively, we would expect samples from the same sample group (i.e., that are under similar conditions/perturbations) to exhibit a similar transcriptional profile. In most cases, there will be a high degree of similarity of samples within a group but there will also inevitably be many differences. The source of this variability on a gene’s expression can be attributed to many factors, some of which are identifiable and others that remain unknown.\n\n\n\nWith differential expression analysis, we are looking for genes that change in expression between two or more groups. For example,\n\ncase vs. control\ncorrelation of expression with some variable or clinical outcome\n\nHowever, there is much more going on with your data than what you are anticipating. Genes that vary in expression level is a consequence of not only the experimental variable(s) of interest but also due to extraneous sources. The goal of differential expression analysis is to identify and correct for sources of variation such that we can separate the “interesting” from the “uninteresting”.\nLet’s take a closer look at the figure below as an example. Expression (counts) is plotted here for ‘GeneA’ in the ‘untreated’ and ‘treated’ groups. Each dot corresponds to expression for a single sample, and the dots are colored based on which group they belong to.\n\n\n\nThe mean expression level of GeneA for the ‘treated’ group is twice as large as the mean expression level for the ‘untreated’ group. But is the difference in expression between groups significant given the amount of variation observed within groups (across replicates)?\nIt is possible that the difference is not actually significant. We need to take into account the variation in the data (and where it might be coming from) when determining whether genes are differentially expressed. Modeling our data with the negative binomial distribution allows us to do this.\n\nHow many replicates are enough?\nMore is always better! At minimum we recommend three replicates for each sample group, but if you can increase that by any number it is in your best interest. The value of additional replicates is that as you add more data, you get increasingly precise estimates of group means, and ultimately greater confidence in the ability to reliably distinguish differences between sample classes.\nHaving many replicates allow us to:\n\nestimate variation for each gene\nrandomize out unknown covariates\nspot outliers\nimprove precision of expression and fold-change estimates\n\nThe figure below is taken from a study directly evaluating the relationship between sequencing depth and number of replicates on the number of differentially expressed genes [1].\n\n\n\nNote that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/01c_RNAseq_count_distribution.html#differential-expression-with-deseq2",
    "href": "lessons/01c_RNAseq_count_distribution.html#differential-expression-with-deseq2",
    "title": "Gene-level differential expression analysis",
    "section": "Differential expression with DESeq2",
    "text": "Differential expression with DESeq2\nDESeq2 is a popular tool for gene-level differential expression analysis. It uses the negative binomial distribution, employing a slightly more stringent approach compared to some methods yet having a good balance between sensitivity and specificity (reducing both false positives and false negatives).\n\n\n\n\n\n\nOther tools for Differential Expression Analysis\n\n\n\nThere are a number of software packages that have been developed for differential expression analysis of RNA-seq data. Most adopt the negative binomial approach; however, there are other tools based on non-parametric methods suitable for larger sample sizes. An extensive comparison of these methods can be found in Soneson and Dleorenzi, 2013.\n\n\nWe will be using DESeq2 for the analysis in this workshop. The analysis steps with DESeq2 are shown in the flowchart below in green and blue.\n\n\n\nWe will go in-depth into each of these steps in the following lessons, but additional details and helpful suggestions regarding DESeq2 can be found in the DESeq2 vignette.\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "Gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/schedule.html",
    "href": "lessons/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/schedule.html#pre-reading",
    "href": "lessons/schedule.html#pre-reading",
    "title": "",
    "section": "Pre-reading",
    "text": "Pre-reading\n\nWorkflow (raw data to counts)\nExperimental design considerations"
  },
  {
    "objectID": "lessons/schedule.html#day-1",
    "href": "lessons/schedule.html#day-1",
    "title": "",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 10:30\nWorkshop Introduction\nWill\n\n\n10:30 - 11:00\nRNA-seq pre-reading discussion\nAll\n\n\n11:00 - 11:45\nIntro to DGE / setting up DGE analysis\nMeeta\n\n\n11:45 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nRNA-seq counts distribution\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nStarting with the count matrix, we want to explore some characteristics of the RNA-seq data and evaluate the appropriate model to use.\nThis lesson will cover:\n\nDescribing characteristics of the RNA-seq count data\nUnderstanding different statistical methods to model the count data\nExplaining the benefits of biological replicates\n\n\n\n\n\nCount normalization\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nCount normalization is an important data pre-processing step before the differential expression analysis.\nThis lesson will cover:\n\nDescribing “uninteresting factors” to consider during normalization\nUnderstanding different normalization methods and their corresponding use cases\nGenerating a matrix of normalized counts using DESeq2’s median of ratios method\n\n\n\n\n\nSample-level QC (PCA and hierarchical clustering)\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nNext, we want to check the quality of count data, to make sure that the samples are good.\nThis lesson will cover:\n\nUnderstanding the importance of similarity analysis between samples\nDescribing Principal Component Analysis (PCA) and interpreting PCA plots from RNA-seq data\nPerforming hierarchical clustering and plotting correlation metrics\n\n\n\n\n\nComplete the exercises:\n\nEach lesson above contains exercises; please go through each of them.\nCopy over your solutions into the Google Form the day before the next class.\n\n\n\n\nQuestions?\n\nIf you get stuck due to an error while runnning code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-2",
    "href": "lessons/schedule.html#day-2",
    "title": "",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:00\nSelf-learning lessons discussion\nAll\n\n\n11:00 - 11:30\nDesign formulas\nWill\n\n\n11:30 - 12:00\nHypothesis testing and multiple test correction\nMeeta\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nDescription of steps for DESeq2\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nThe R code required to perform differential gene expression analysis is actually quite simple. Running the DESeq() function will carry out the various steps involved. It is important that you have some knowledge of what is happening under the hood, to be able to fully understand and interpret the results.\nIn this lesson you will:\n\nExamine size factors and learn about sources that cause observed variation in values\nExplore the gene-wise dispersion estimates as they relate back the mean-variance relationship\nCritically evaluate a dispersion plot\n\n\n\n\n\nWald test results\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nWe have run the analysis, and now it’s time to explore the results!\nIn this lesson you will:\n\nLearn how to extract results for specific group comparisons\nExplore the information presented in the results table (different statistics and their importance)\nUnderstand the different levels of filtering that are applied in DESeq2 by default (and why they are important)\n\n\n\n\n\nSummarizing results and extracting significant gene lists\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nOnce you have your results, it is useful to summarize the information. Here, we get a snapshot of the number of differentially expressed genes that are identified from the different comparisons.\n\n\n\n\nVisualization\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nA picture is worth a thousand words. In our case, a figure is worth a thousand (or 30 thousand) data points. When working with large scale data, it can be helpful to visualize results and get a big picture perspective of your findings.\nIn this lesson you will:\n\nExplore different plots for data visualization\nCreate a volcano plot to evaluate the relationship between different statistics from the results table\nCreate a heatmap for visualization of differentially expressed genes\n\n\n\n\n\nComplete the exercises:\n\nEach lesson above contains exercises; please go through each of them.\nCopy over your solutions into the Google Form the day before the next class.\n\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-3",
    "href": "lessons/schedule.html#day-3",
    "title": "",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:15\nSelf-learning lessons discussion\nAll\n\n\n11:15 - 12:00\nLikelihood Ratio Test results\nMeeta\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nTime course analysis\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nSometimes we are interested in how a gene changes over time. The Likelihood Ratio Test (LRT) is paricularly well-suited for this task.\nThis lesson will cover:\n\nDesigning a LRT for a time-course analysis in DESeq2\nIdentifying patterns in our list of differentially expressed genes\n\n\n\n\n\nGene annotation\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nNext-generation analyses rely on annotations to provide a description for defining genes, transcripts and/or proteins. These annotations are often stored in publicly available databases.\nThis lesson will cover:\n\nDescribing the various annotation databases\nAccessing annotations from one of these databases using R\n\n\n\n\n\nFunctional analysis - over-representation analysis\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nOftentimes after completing an RNA-seq experiment, you will be left with a list of differentially expressed transcripts. You may be interested in knowing if these transcripts are enriched in certain biologically-relevant contexts.\nThis lesson will cover:\n\nDescribing how functional enrichment tools yield statistically enriched functional categories or interactions\nIdentifying enriched Gene Ontology terms using the R package, clusterProfiler\n\n\n\n\n\nFunctional analysis - functional class scoring / GSEA\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nWhile some functional analyses focus on large changes focused on a select few genes, functional class scoring (FCS) focuses on weaker but coordinated changes in sets of functionally related genes (i.e., pathways) that can also have significant effects.\nThis lesson will cover:\n\nDesigning a GSEA analysis using GO and/or KEGG gene sets\nEvaluating the results of a GSEA analysis\nDiscussing other tools and resources for identifying genes of novel pathways or networks\n\n\n\n\n\nThere is no assignment submission, but please use this Google form to ask us questions!\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-4",
    "href": "lessons/schedule.html#day-4",
    "title": "",
    "section": "Day 4",
    "text": "Day 4\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:00\nQuestions about self-learning lessons\nAll\n\n\n11:00 - 11:15\nSummarizing workflow\nWill\n\n\n11:15 - 11:45\nDiscussion, Q & A\nAll\n\n\n11:45 - 12:00\nWrap Up\nWill"
  },
  {
    "objectID": "lessons/schedule.html#answer-keys",
    "href": "lessons/schedule.html#answer-keys",
    "title": "",
    "section": "Answer keys",
    "text": "Answer keys\n\nDay 1 Answer Key\nDay 2 Answer Key"
  },
  {
    "objectID": "lessons/schedule.html#resources",
    "href": "lessons/schedule.html#resources",
    "title": "",
    "section": "Resources",
    "text": "Resources\nWe have covered the inner workings of DESeq2 in a fair amount of detail such that when using this package you have a good understanding of what is going on under the hood. For more information on topics covered, we encourage you to take a look at the following resources:\n\nDESeq2 vignette\nGitHub book on RNA-seq gene level analysis\nBioconductor support site (posts tagged with deseq2)\nEnrichment analysis book\n\nVisualization: Functional (Enrichment) analysis"
  },
  {
    "objectID": "lessons/schedule.html#building-on-this-workshop",
    "href": "lessons/schedule.html#building-on-this-workshop",
    "title": "",
    "section": "Building on this workshop",
    "text": "Building on this workshop\n\nSingle-cell RNA-seq workshop\nRMarkdown\nggplot2 for functional analysis"
  },
  {
    "objectID": "lessons/schedule.html#other-helpful-links",
    "href": "lessons/schedule.html#other-helpful-links",
    "title": "",
    "section": "Other helpful links",
    "text": "Other helpful links\n\nOnline hbctraining learning materials\nhbctraining webpage"
  },
  {
    "objectID": "lessons/links-to-lessons.html",
    "href": "lessons/links-to-lessons.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/links-to-lessons.html#learning-objectives",
    "href": "lessons/links-to-lessons.html#learning-objectives",
    "title": "",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain and interpret QC on count data using Principal Component Analysis (PCA) and hierarchical clustering\nImplement DESeq2 to obtain a list of significantly different genes\nPerform functional analysis on gene lists with R-based tools"
  },
  {
    "objectID": "lessons/links-to-lessons.html#installations",
    "href": "lessons/links-to-lessons.html#installations",
    "title": "",
    "section": "Installations",
    "text": "Installations\nFollow the instructions linked here to download R and RStudio + Install Packages from CRAN and Bioconductor"
  },
  {
    "objectID": "lessons/links-to-lessons.html#lessons",
    "href": "lessons/links-to-lessons.html#lessons",
    "title": "",
    "section": "Lessons",
    "text": "Lessons\n\nPart 1 (Getting Started)\n\nWorkflow (raw data to counts)\nExperimental design considerations\nIntro to DGE / setting up DGE analysis\n\n\n\n\nPart II (QC and setting up for DESeq2)\n\nRNA-seq counts distribution\nCount normalization\nSample-level QC (PCA and hierarchical clustering)\nDesign formulas\nHypothesis testing and multiple test correction\n\n\n\n\nPart III (DESeq2)\n\nDescription of steps for DESeq2\nWald test results\nSummarizing results and extracting significant gene lists\nVisualization\nLikelihood Ratio Test results\nTime course analysis\n\n\n\n\nPart IV (Functional Analysis)\n\nGene annotation\nFunctional analysis - over-representation analysis\nFunctional analysis - functional class scoring / GSEA\n\n\nWorkflow Summary"
  },
  {
    "objectID": "lessons/links-to-lessons.html#building-on-this-workshop",
    "href": "lessons/links-to-lessons.html#building-on-this-workshop",
    "title": "",
    "section": "Building on this workshop",
    "text": "Building on this workshop\n\nSingle-cell RNA-seq workshop\nRMarkdown\nGgplot2 for functional analysis"
  },
  {
    "objectID": "lessons/links-to-lessons.html#resources",
    "href": "lessons/links-to-lessons.html#resources",
    "title": "",
    "section": "Resources",
    "text": "Resources\n\nDESeq2 vignette\nGitHub book on RNA-seq gene level analysis\nBioconductor support site (posts tagged with deseq2)\nFunctional analysis visualization"
  },
  {
    "objectID": "lessons/02_DGE_count_normalization.html",
    "href": "lessons/02_DGE_count_normalization.html",
    "title": "Count normalization with DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/02_DGE_count_normalization.html#learning-objectives",
    "href": "lessons/02_DGE_count_normalization.html#learning-objectives",
    "title": "Count normalization with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nList different “uninteresting factors” considered during normalization\nDescribe some common normalization methods and recommendations for its use\nCreate a DESeqDataSet object and discuss the structure of the object\nDemonstrate how to normalize counts using DESeq2",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/02_DGE_count_normalization.html#normalization",
    "href": "lessons/02_DGE_count_normalization.html#normalization",
    "title": "Count normalization with DESeq2",
    "section": "Normalization",
    "text": "Normalization\nThe first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples.\n\nThe counts of mapped reads for each gene is the result of RNA expression (“interesting” part) in addition to many other factors (“uninteresting” part). Normalization is the process of adjusting raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples.\nThe main “uninteresting” factors often considered during normalization are:\n\nSequencing depth: Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have twice the expression in Sample A relative to Sample B. However, this is the consequence of Sample A having doubled sequencing depth.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the figure above, each pink and green rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron.\n\n\n\nGene length: Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example below, Gene X and Gene Y have similar levels of expression, but the number of reads mapped to Gene X would be many more than the number mapped to Gene Y because Gene X is longer.\n\nRNA composition: A few highly differentially expressed genes between samples, differences in the number of genes expressed between samples, or presence of contamination can skew some types of normalization methods. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses [1].\nIn the example below, imagine the sequencing depths are similar between Sample A and Sample B, and every gene except for gene DE presents similar expression level between samples. The counts in Sample B would be greatly skewed by the DE gene, which takes up most of the counts. Other genes for Sample B would therefore appear to be less expressed than those same genes in Sample A.\n\n\nWhile normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples.\n\nCommon normalization methods\nSeveral common normalization methods have been developed to account for these differences:\n\n\n\nNormalization method\nDescription\nAccounted factors\nRecommendations for use\n\n\n\n\nCPM (counts per million)\ncounts scaled by total number of reads\nsequencing depth\ngene count comparisons between replicates of the same sample group; NOT for within sample comparisons or DE analysis\n\n\nTPM (transcripts per kilobase million)\ncounts per length of transcript (kb) per million reads mapped\nsequencing depth and gene length\ngene count comparisons within a sample or between samples of the same sample group; NOT for DE analysis\n\n\nRPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped)\nsimilar to TPM\nsequencing depth and gene length\ngene count comparisons between genes within a sample; NOT for between sample comparisons or DE analysis\n\n\nDESeq2’s median of ratios [1]\ncounts divided by sample-specific size factors determined by median ratio of gene counts relative to geometric mean per gene\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\nEdgeR’s trimmed mean of M values (TMM) [2]\nuses a weighted trimmed mean of the log expression ratios between samples\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\n\n\n\nRPKM/FPKM: not recommended for between sample comparisons\nWhile TPM and RPKM/FPKM normalization methods both account for sequencing depth and gene length, RPKM/FPKM are not recommended. The reason is that the normalized count values output by the RPKM/FPKM method are not comparable between samples.\nUsing RPKM/FPKM normalization, the total number of RPKM/FPKM normalized counts for each sample will be different. Therefore, you cannot compare the normalized counts for each gene equally between samples.\nRPKM-normalized counts table\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nXCR1\n5.5\n5.5\n\n\nWASHC1\n73.4\n21.8\n\n\n…\n…\n…\n\n\nTotal RPKM-normalized counts\n1,000,000\n1,500,000\n\n\n\nFor example, in the table above, sampleA has a greater proportion of counts associated with XCR1 (5.5/1,000,000) than sampleB (5.5/1,500,000), even though the RPKM count values are the same. Therefore, we cannot directly compare the counts for XCR1 (or any other gene) between sampleA and sampleB, because the total number of normalized counts are different between samples.\n\n\n\n\n\n\nNote\n\n\n\nThis video by StatQuest shows in more detail why TPM should be used in place of RPKM/FPKM if needing to normalize for sequencing depth and gene length.\n\n\n\n\nDESeq2-normalized counts: Median of ratios method\nSince tools for differential expression analysis are comparing the counts of the same gene between sample groups, gene length does not need to be accounted for by the tool. However, sequencing depth and RNA composition do need to be taken into account.\nTo normalize for sequencing depth and RNA composition, DESeq2 uses the median of ratios method. On the user-end there is only one step, but on the back-end there are multiple steps involved, as described below.\n\n\n\n\n\n\nNote\n\n\n\nThe steps below describe in detail some of the steps performed by DESeq2 when you run a single function to get DE genes. Basically, for a typical RNA-seq analysis, you would not run these steps individually.\n\n\nStep 1: creates a pseudo-reference sample (row-wise geometric mean)\nFor each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples.\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\n\n\n\n\nEF2A\n1489\n906\nsqrt(1489 * 906) = 1161.5\n\n\nABCD1\n22\n13\nsqrt(22 * 13) = 17.7\n\n\n…\n…\n…\n…\n\n\n\nStep 2: calculates ratio of each sample to the reference\nFor every gene in every sample, the ratios (sample/ref) are calculated (as shown below). Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample.\n\n\n\n\n\n\n\n\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\nratio of sampleA/ref\nratio of sampleB/ref\n\n\n\n\nEF2A\n1489\n906\n1161.5\n1489/1161.5 = 1.28\n906/1161.5 = 0.78\n\n\nABCD1\n22\n13\n16.9\n22/16.9 = 1.30\n13/16.9 = 0.77\n\n\nMEFV\n793\n410\n570.2\n793/570.2 = 1.39\n410/570.2 = 0.72\n\n\nBAG1\n76\n42\n56.5\n76/56.5 = 1.35\n42/56.5 = 0.74\n\n\nMOV10\n521\n1196\n883.7\n521/883.7 = 0.590\n1196/883.7 = 1.35\n\n\n…\n…\n…\n…\n\n\n\n\n\nStep 3: calculate the normalization factor for each sample (size factor)\nThe median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value:\nnormalization_factor_sampleA &lt;- median(c(1.28, 1.3, 1.39, 1.35, 0.59))\nnormalization_factor_sampleB &lt;- median(c(0.78, 0.77, 0.72, 0.74, 1.35))\nThe figure below illustrates the median value for the distribution of all gene ratios for a single sample (y-axis is the frequency).\n\nThe median of ratios method makes the assumption that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not affect the median ratio values). This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes.\n\n\n\n\n\n\nNote\n\n\n\nUsually these size factors are around 1. If you see large variations between samples, it is important to take note as it might indicate the presence of extreme outliers.\n\n\nStep 4: calculate the normalized count values using the normalization factor\nThis is performed by dividing each raw count value in a given sample by that sample’s normalization factor, generating normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for sampleA was 1.3 and the median ratio for sampleB was 0.77, you could calculate normalized counts as follows:\nRaw Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489\n906\n\n\nABCD1\n22\n13\n\n\n…\n…\n…\n\n\n\nNormalized Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489 / 1.3 = 1145.39\n906 / 0.77 = 1176.62\n\n\nABCD1\n22 / 1.3 = 16.92\n13 / 0.77 = 16.88\n\n\n…\n…\n…\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPlease note that normalized count values are not whole numbers.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/02_DGE_count_normalization.html#count-normalization-of-mov10-dataset-using-deseq2",
    "href": "lessons/02_DGE_count_normalization.html#count-normalization-of-mov10-dataset-using-deseq2",
    "title": "Count normalization with DESeq2",
    "section": "Count normalization of Mov10 dataset using DESeq2",
    "text": "Count normalization of Mov10 dataset using DESeq2\nNow that we know the theory of count normalization, we will normalize the counts for the Mov10 dataset using DESeq2. This requires a few steps:\n\nEnsure that the row names of the metadata dataframe are present and are in the same order as the column names of the counts dataframe.\nCreate a DESeqDataSet object\nGenerate the normalized counts\n\n\n1. Match the metadata and counts data\nWe should always make sure that we have sample names that match between the two files, and that the samples are in the same order. DESeq2 will output an error if this is not the case.\n\n# Check that sample names match in both files\nall(colnames(txi$counts) %in% rownames(meta))\n\n[1] TRUE\n\nall(colnames(txi$counts) == rownames(meta))\n\n[1] TRUE\n\n\nIf your data does not match, you could use the match() function to rearrange them.\n\n\n\n\n\n\nExercise\n\n\n\nSuppose we have sample names matching in the counts matrix and metadata file, but they are in different order. Write the line(s) of code to create a new matrix with columns re-ordered such that they are identical to the row names of the metadata.\n\n\n\n\n2. Create DESEq2 object\nBioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also results). These custom data structures are similar to lists in that they can contain multiple different data types/structures. But unlike lists, they have pre-specified data slots, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions.\nLet’s start by creating the DESeqDataSet object, and then we can talk a bit more about what is stored inside it. To create the object, we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have one column we are interested in, which is ~sampletype. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels.\nOur count matrix input is stored in the txi list object. So we need to specify that using the DESeqDataSetFromTximport() function, which will extract the counts component and round the values to the nearest whole number.\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n\n\n\n\n\n\nNote\n\n\n\nSince we had created a data variable in the last lesson that contains the counts, we could have also used that as input. However, in that case we would want to use the DESeqDataSetFromMatrix() function.\n\n\n\n\n\nDESeq2 object structure\n\n\nYou can use DESeq-specific functions to access the different slots and retrieve information. For example, suppose we want to retrieve the original count matrix, we would use counts() function (Note: we nest it within the head() function so that we can see just the first few lines of the matrix. You could also use the View() function to view the result in the script editor rather than in the console):\n\nhead(counts(dds))\n\n                Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3\nENSG00000000003       4376       3645       2968       6178       3688\nENSG00000000005         27         29         23         37         13\nENSG00000000419       1478       1288        884       2369       1340\nENSG00000000457        508        405        357        934        571\nENSG00000000460       1394       1164        850       2172       1217\nENSG00000000938          1          1          0          2          0\n                Mov10_oe_1 Mov10_oe_2 Mov10_oe_3\nENSG00000000003       3343       3114       2079\nENSG00000000005         25         38         22\nENSG00000000419       1890       1766       1271\nENSG00000000457        646        591        354\nENSG00000000460       1183       1139        673\nENSG00000000938          0          0          0\n\n\nAs we go through the workflow, we will use relevant functions to check what information is stored inside our object.\n\n\n3. Generate the Mov10 normalized counts\nThe next step is to normalize the count data in order to make fair gene comparisons between samples.\n\nTo perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors. We will demonstrate this function in the example below, but in a typical RNA-seq analysis, this step is automatically performed by the DESeq() function, which we will discuss later.\n\n# Estimate size factors\ndds &lt;- estimateSizeFactors(dds)\n\nBy assigning the results back to the dds object, we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factors of each sample using:\n\n# Look at size factors\nsizeFactors(dds)\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n 1.1150371  0.9606366  0.7493552  1.5634128  0.9359082  1.2257749  1.1406863 \nMov10_oe_3 \n 0.6541689 \n\n\nNow, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE.\n\n# Get normalized counts matrix\nnormalized_counts &lt;- counts(dds, normalized=TRUE)\n\nWe can save this normalized data matrix to file for later use:\n\n# Save normalized counts matrix\nwrite.table(normalized_counts, file=\"./data/normalized_counts.txt\", sep=\"\\t\", quote=FALSE, col.names=NA)\n\n\n\n\n\n\n\nNote\n\n\n\nDESeq2 doesn’t actually use normalized counts; rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that perform differential expression analysis that use the negative binomial model.\n\n\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/03_DGE_QC_analysis.html",
    "href": "lessons/03_DGE_QC_analysis.html",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "",
    "text": "Approximate time: 80 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/03_DGE_QC_analysis.html#learning-objectives",
    "href": "lessons/03_DGE_QC_analysis.html#learning-objectives",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nRecognize the importance of methods for count data transformation\nDescribe the PCA (principal component analysis) technique\nInterpret different examples of PCA plots\nEvaluate sample quality using PCA and hierachical clustering",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/03_DGE_QC_analysis.html#sample-level-qc",
    "href": "lessons/03_DGE_QC_analysis.html#sample-level-qc",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Sample-level QC",
    "text": "Sample-level QC\nA useful initial step in an RNA-seq analysis is often to assess overall similarity between samples:\n\nWhich samples are similar to each other, which are different?\nDoes this fit to the expectation from the experiment’s design?\nWhat are the major sources of variation in the dataset?\n\nTo explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. These methods/tools allow us to check how well similar the replicates are to each other (clustering) and to make sure that the experimental condition is the major source of variation in the data. Sample-level QC can also help identify any samples behaving like outliers; we can further explore any potential outliers to determine whether they need to be removed prior to DE analysis.\n\n\n\nThese unsupervised clustering methods are run using log2 transformed normalized counts. The log2 transformation improves the distances/clustering for visualization. Instead of using an ordinary log2 transform, we will be using regularized log transform (rlog), to avoid any bias from the abundance of low-count genes; Note 1 below explains this in more detail.\n\n\n\nImage adapted from “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014\n\n\n\n\n\n\nNote 1\n\n\n\n“Many common statistical methods for exploratory analysis of multidimensional data, especially methods for clustering and ordination (e.g., principal-component analysis and the like), work best for (at least approximately) homoskedastic data; this means that the variance of an observable quantity (i.e., here, the expression strength of a gene) does not depend on the mean. In RNA-seq data, however, variance grows with the mean. For example, if one performs PCA directly on a matrix of normalized read counts, the result typically depends only on the few most strongly expressed genes because they show the largest absolute differences between samples. A simple and often used strategy to avoid this is to take the logarithm of the normalized count values plus a small pseudocount; however, now the genes with low counts tend to dominate the results because, due to the strong Poisson noise inherent to small count values, they show the strongest relative differences between samples.\nAs a solution, DESeq2 offers the regularized-logarithm transformation, or rlog for short. For genes with high counts, the rlog transformation differs not much from an ordinary log2 transformation. For genes with lower counts, however, the values are shrunken towards the genes’ averages across all samples. Using an empirical Bayesian prior in the form of a ridge penality, this is done such that the rlog-transformed data are approximately homoskedastic.” - From the “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014 (the DESeq2 vignette is the updated version of this doc).\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe DESeq2 vignette suggests large datasets (100s of samples) to use the variance-stabilizing transformation (vst) instead of rlog for transformation of the counts, since the rlog function might take too long to run and the vst() function is faster with similar properties to rlog.\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). This is a very important technique used in the QC and analysis of both bulk and single-cell RNAseq data.\nTo better understand how it works, please go through this YouTube video from StatQuest that explains PCA. Alternatively, we have prepared a PCA lesson. After you have gone through the material, please proceed with the interpretation section below.\n\n\nInterpreting PCA plots\nEssentially, if two samples have similar levels of expression for the genes that contribute significantly to the variation represented by a given PC (Principal Component), they will be plotted close together on the axis that represents that PC. Therefore, we would expect that biological replicates to have similar scores (because our expectation is that the same genes are changing) and cluster together. This is easiest to understand by visualizing some example PCA plots.\nWe have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment.\n\n\n\nWhen visualizing on PC1 and PC2, we don’t see the samples separate by treatment, so we decide to explore other sources of variation present in the data. We hope that we have included all possible known sources of variation in our metadata table, and we can use these factors to color the PCA plot.\n\n\n\nWe start with the factor cage, but the cage factor does not seem to explain the variation on PC1 or PC2.\n\n\n\nThen, we color by the sex factor, which appears to separate samples on PC2. This is good information to take note of, as we can use it downstream to account for the variation due to sex in the model and regress it out.\n\n\n\nNext we explore the strain factor and find that it explains the variation on PC1.\n\n\n\nIt’s great that we have been able to identify the sources of variation for both PC1 and PC2. By accounting for it in our model, we should be able to detect more genes differentially expressed due to treatment.\nWorrisome about this plot is that we see two samples that do not cluster with the correct strain. This would indicate a likely sample swap and should be investigated to determine whether these samples are indeed the labeled strains. If we found there was a switch, we could swap the samples in the metadata. However, if we think they are labeled correctly or are unsure, we could just remove the samples from the dataset.\nStill we haven’t found if treatment is a major source of variation after strain and sex. So, we explore PC3 and PC4 to see if treatment is driving the variation represented by either of these PCs.\n\n\n\nWe find that the samples separate by treatment on PC3, and are optimistic about our DE analysis since our condition of interest, treatment, is separating on PC3 and we can regress out the variation driving PC1 and PC2.\nDepending on how much variation is explained by the first few principal components, you may want to explore more (i.e., consider more components and plot pairwise combinations). Even if your samples do not separate clearly by the experimental variable, you may still get biologically relevant results from the DE analysis. If you are expecting very small effect sizes, then it’s possible the signal is drowned out by extraneous sources of variation. In situations where you can identify those sources, it is important to account for these in your model, as it provides more power to the tool for detecting DE genes.\n\n\n\nHierarchical Clustering Heatmap\nSimilar to PCA, hierarchical clustering is another, complementary, method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.\nThe hierarchical tree along the axes indicates which samples are more similar to each other, i.e., cluster together. The color blocks at the top indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Our expectation would be that the samples cluster together similar to the groupings we’ve observed in the PCA plot.\nIn the plot below, we would be quite concerned about ‘Wt_3’ and ‘KD_3’ samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples.",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/03_DGE_QC_analysis.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "href": "lessons/03_DGE_QC_analysis.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Mov10 quality assessment and exploratory analysis using DESeq2",
    "text": "Mov10 quality assessment and exploratory analysis using DESeq2\nNow that we have a good understanding of the QC steps normally employed for RNA-seq, let’s implement them for the Mov10 dataset we are going to be working with.\n\nTransform normalized counts for the MOV10 dataset\nTo improve the distances/clustering for the PCA and hierarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these transformed counts for determining differential expression.\n\n\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\n\nThe blind=TRUE argument is to make sure that the rlog() function does not take our sample groups into account - i.e., does the transformation in an unbiased manner. When performing quality assessment, it is important to include this option. The DESeq2 vignette has more details about this.\nThe rlog() function returns a DESeqTransform object, another type of DESeq-specific object. The reason you don’t just get a matrix of transformed values is because all of the parameters (e.g., size factors) that went into computing the rlog transform are stored in that object. We use this object to plot the PCA and hierarchical clustering figures for quality assessment.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog() funtion can be a bit slow when you have &gt; ~20 samples. In these situations the vst() function is much faster and performs a similar transformation appropriate for use with plotPCA(). It’s typically just a few seconds with vst() due to optimizations and the nature of the transformation.\n\n\n\n\nPrincipal component analysis (PCA) for the MOV10 dataset\nWe are now ready for the QC steps, let’s start with PCA!\nDESeq2 has a built-in function for generating PCA plots using ggplot2 under the hood. This is great because it saves us having to type out lines of code and having to fiddle with the different ggplot2 layers. In addition, it takes the rlog object as an input directly, hence saving us the trouble of extracting the relevant information from it.\nThe function plotPCA() requires two arguments as input: a DESeqTransform object and the “intgroup” (interesting group), i.e., the name of the column in our metadata that has information about the experimental sample groups.\n\n# Plot PCA \nplotPCA(rld, intgroup=\"sampletype\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nWhat does the above plot tell you about the similarity of samples?\nDoes it fit the expectation from the experimental design?\nWhat do you think the %variance information (in the axes titles) tell you about the data in the context of the PCA?\n\n\n\nBy default plotPCA() uses the top 500 most variable genes. You can change this by adding the ntop= argument and specifying how many of the genes you want the function to consider.\n\n\n\n\n\n\nNote\n\n\n\nThe plotPCA() function will only return the values for PC1 and PC2. If you would like to explore the additional PCs in your data or if you would like to identify genes that contribute most to the PCs, you can use the prcomp() function. For example, to plot any of the PCs we could run the following code:\n\n# Input is a matrix of log transformed values\nrld &lt;- rlog(dds, blind=T)\nrld_mat &lt;- assay(rld)\npca &lt;- prcomp(t(rld_mat))\n\n# Create data frame with metadata and PC3 and PC4 values for input to ggplot\ndf &lt;- cbind(meta, pca$x)\nggplot(df) + geom_point(aes(x=PC3, y=PC4, color = sampletype))\n\n\n\n\n\n\n\n\nResources are available to learn how to do more complex inquiries using the PCs.\n\n\n\n\nHierarchical Clustering for the MOV10 dataset\nThere is no built-in function in DESeq2 for plotting the heatmap for displaying the pairwise correlation between all the samples and the hierarchical clustering information; we will use the pheatmap() function from the pheatmap package. This function cannot use the DESeqTransform object as input, but requires a matrix or dataframe. So, the first thing to do is retrieve that information from the rld object using a function called assay() (from the SummarizedExperiment package) that converts the data in a DESeqTransform object to a simple 2-dimensional data structure (a matrix in this case).\n\n# Extract the rlog matrix from the object\n# \"assay()\" is part of the \"SummarizedExperiment\" package, which is a DESeq2 dependency and is loaded with the DESeq2 library\nrld_mat &lt;- assay(rld)\n\nNext, we need to compute the pairwise correlation values for all the samples. We can do this using the cor() function:\n\n# Compute pairwise correlation values\n# cor() is a base R function\nrld_cor &lt;- cor(rld_mat)\n\nLet’s take a look at the column and row names of the correlation matrix.\n\n# Check the output of cor(), make note of the row names and column names\nhead(rld_cor)\n\n           Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1\nIrrel_kd_1  1.0000000  0.9997740  0.9997525  0.9996005  0.9996334  0.9995372\nIrrel_kd_2  0.9997740  1.0000000  0.9997564  0.9995701  0.9996137  0.9995441\nIrrel_kd_3  0.9997525  0.9997564  1.0000000  0.9995460  0.9996014  0.9995541\nMov10_kd_2  0.9996005  0.9995701  0.9995460  1.0000000  0.9997927  0.9993895\nMov10_kd_3  0.9996334  0.9996137  0.9996014  0.9997927  1.0000000  0.9994757\nMov10_oe_1  0.9995372  0.9995441  0.9995541  0.9993895  0.9994757  1.0000000\n           Mov10_oe_2 Mov10_oe_3\nIrrel_kd_1  0.9995326  0.9994112\nIrrel_kd_2  0.9995407  0.9994279\nIrrel_kd_3  0.9995620  0.9994254\nMov10_kd_2  0.9993608  0.9992364\nMov10_kd_3  0.9994457  0.9993479\nMov10_oe_1  0.9997794  0.9996902\n\nhead(meta)\n\n                     sampletype\nIrrel_kd_1              control\nIrrel_kd_2              control\nIrrel_kd_3              control\nMov10_kd_2      MOV10_knockdown\nMov10_kd_3      MOV10_knockdown\nMov10_oe_1 MOV10_overexpression\n\n\nYou will notice that they match the names we have given our samples in the metadata data frame we started with. It is important that these match, so we can use the annotation argument below to plot a color block across the top. This block enables easy visualization of the hierarchical clustering.\nLet’s plot the heatmap!\nWhen you plot using pheatmap(), the hierarchical clustering information is used to place similar samples together and this information is represented by the tree structure along the axes. The annotation argument accepts a dataframe as input; in our case it is the meta dataframe.\n\n# Load pheatmap package\nlibrary(pheatmap)\n\n# Plot heatmap using the correlation matrix and the metadata object\npheatmap(rld_cor, annotation = meta)\n\n\n\n\n\n\n\n\nOverall, we observe pretty high correlations across the board (&gt; 0.999) suggesting no outlying sample(s). Also, similar to the PCA plot, you see the samples clustering together by sample group. Together, these plots suggest to us that the data are of good quality and we have the green light to proceed to differential expression analysis.\n\n\n\n\n\n\nNote\n\n\n\nThe pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot.\n\nheat.colors &lt;- RColorBrewer::brewer.pal(6, \"Blues\")\npheatmap(rld_cor, annotation = meta, color = heat.colors,\n         border_color = NA, fontsize = 10, fontsize_row = 10, height=20)\n\n\n\n\n\n\n\n\nCurious about all of the available color palettes offered by the RColorBrewer package? Try typing in your console display.brewer.all() and see what happens!\n\n\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/principal_component_analysis.html",
    "href": "lessons/principal_component_analysis.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). Details regarding PCA are given below (based on materials from StatQuest, and if you would like a more thorough description, we encourage you to explore StatQuest’s video.\nIf you had two samples and wanted to plot the counts of one sample versus another, you could plot the counts of one sample on the x-axis and the other sample on the y-axis as shown below:\n\nYou could draw a line through the data in the direction representing the most variation, which is on the diagonal in this example. The maximum variation in the data is between the two endpoints of this line.\nWe also see the genes vary somewhat above and below the line. We could draw another line through the data representing the second most amount of variation in the data.\n\nThe genes near the ends of the line, which would include those genes with the highest variation between samples (high expression in one sample and low expression in the other), have the greatest influence on the direction of the line.\n\nFor example, a small change in the value of Gene C would greatly change the direction of the line, whereas a small change in Gene A or Gene D would have little affect.\n\nWe could just rotate the entire plot and view the lines representing the variation as left-to-right and up-and-down. We see most of the variation in the data is left-to-right; this is and the second most variation in the data is up-and-down. These axes that represent the variation are “Principal Components”, with PC1 representing the most variation in the data and PC2 representing the second most variation in the data.\nIf we had three samples, then we would have an extra direction in which we could have variation. Therefore, if we have N samples we would have N-directions of variation or principal components.\n\nWe could give quantitative scores to genes based on how much they influence PC1 and PC2. Genes with little influence would get scores near zero, while genes with more influence would receive larger scores. Genes on opposite ends of the lines have a large influence, so they would receive large scores, but with opposite signs.\n\nTo generate a score per sample, we combine the read counts for all genes. To calculate the scores, we do the following:\nSample1 PC1 score = (read count * influence) + ... for all genes\nUsing the counts in the table for each gene (assuming we had only 4 genes total) we could calculate PC1 and PC2 values for each sample as follows:\nSample1 PC1 score = (4 * -2) + (1 * -10) + (8 * 8) + (5 * 1) = 51\nSample1 PC2 score = (4 * 0.5) + (1 * 1) + (8 * -5) + (5 * 6) = -7\n\nSample2 PC1 score = (5 * -2) + (4 * -10) + (8 * 8) + (7 * 1) = 21\nSample2 PC2 score = (5 * 0.5) + (4 * 1) + (8 * -5) + (7 * 6) = 8.5\nThe scores would then be plotted to examine whether the samples exhibit similar variation across all genes:\n\nSince genes with the greatest variation between samples will have the greatest influence on the principal components, we hope our condition of interest explains this variation (e.g. high counts in one condition and low counts in the other). With PC1 representing the most variation in the data and PC2 representing the second most variation in the data, we can visualize how similar the variation of genes is between samples."
  },
  {
    "objectID": "lessons/04a_design_formulas.html",
    "href": "lessons/04a_design_formulas.html",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "",
    "text": "Approximate time: 30 minutes",
    "crumbs": [
      "Day 2:",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/04a_design_formulas.html#learning-objectives",
    "href": "lessons/04a_design_formulas.html#learning-objectives",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDemonstrate the use of the design formula with simple and complex designs\nConstruct R code to execute the differential expression analysis workflow with DESeq2",
    "crumbs": [
      "Day 2:",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/04a_design_formulas.html#running-deseq2",
    "href": "lessons/04a_design_formulas.html#running-deseq2",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "Running DESeq2",
    "text": "Running DESeq2\nPrior to performing the differential expression analysis, it is a good idea to know what sources of variation are present in your data, either by exploration during the QC and/or prior knowledge. Once you know the major sources of variation, you can remove them prior to analysis or control for them in the statistical model by including them in your design formula.\nThis step is critical as each additional factor in your design formula reduces your power. HOWEVER, failing to include important sources of variation can give you inaccurate results.\n\nDesign formula\nA design formula tells the statistical software which sources of variation to test for. This includes both your factor of interest as well as any additional covariates that are sources of variation. For example, if you know that sex is a significant source of variation in your data, then sex should be included in your model. The design formula should have all of the factors in your metadata that account for major sources of variation in your data.\nFor example, suppose you have the following metadata:\n\n\n\nIf you want to examine the expression differences between treatments, and you know that major sources of variation include sex and age, then your design formula would be:\ndesign = ~ sex + age + treatment\nThe tilde (~) should always precede your factors and tells DESeq2 to model the counts using the following formula. Note the factors included in the design formula need to match the column names in the metadata.\n\n\n\n\n\n\nDoes the order of variables matter?\n\n\n\nIn short, the order of variables in your design formula will not change the final results (i.e., the coefficients returned are the always the same). Typically, it has been best practice to list the variable that is your main effect in the last position of your design formula. In this way, the default result that is returned to you when using the results() function will be for your main effect.\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\nSuppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written?\nBased on our Mov10 metadata dataframe, which factors could we include in our design formula?\nWhat would you do if you wanted to include a factor in your design formula that is not in your metadata?\n\n\n\n\nComplex designs\nDESeq2 also allows for the analysis of complex designs. You can explore interactions or ‘the difference of differences’ by specifying for it in the design formula. For example, if you wanted to explore the effect of sex on the treatment effect, you could specify for it in the design formula as follows:\ndesign = ~ sex + age + treatment + sex:treatment\nThere are additional recommendations for complex designs in the DESeq2 vignette. In addition, Limma documentation offers additional insight into creating more complex design formulas.\n\n\n\n\n\n\nNote\n\n\n\nNeed help figuring out what information should be present in your metadata? We have additional materials highlighting bulk RNA-seq planning considerations. Please take a look at these materials before starting an experiment to help with proper experimental design.\n\n\n\n\n\nMOV10 DE analysis\nNow that we know how to specify the model to DESeq2, we can run the differential expression pipeline on the raw counts.\nTo get our differential expression results from our raw count data, we only need to run 2 lines of code!\nFirst we create a DESeqDataSet as we did in the ‘Count normalization’ lesson and specify the txi object which contains our raw counts, the metadata variable, and provide our design formula:\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\nThen, to run the actual differential expression analysis, we use a single call to the function DESeq().\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\nBy re-assigning the results of the function back to the same variable name (dds), we can fill in the slots of our DESeqDataSet object.\n\n\n\nEverything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs:\n\n\nestimating size factors\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\n\nWe will discuss what is occurring in each of these steps in the next few lessons, but the code to execute these steps is encompassed in the two lines above.\n\n\n\n\n\n\nNote\n\n\n\nThere are individual functions available in DESeq2 that would allow us to carry out each step in the workflow in a step-wise manner, rather than a single call. We demonstrated one example when generating size factors to create a normalized matrix. By calling DESeq(), the individual functions for each step are run for you.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nLet’s suppose our experiment has the following metadata:\n\n\n\n\ngenotype\ntreatment\n\n\n\n\nsample1\nWT\nev\n\n\nsample2\nWT\nev\n\n\nsample3\nWT\nev\n\n\nsample4\nWT\nev\n\n\nsample5\nKO_geneA\nev\n\n\nsample6\nKO_geneA\nev\n\n\nsample7\nKO_geneA\nev\n\n\nsample8\nKO_geneA\nev\n\n\nsample9\nWT\ntreated\n\n\nsample10\nWT\ntreated\n\n\nsample11\nWT\ntreated\n\n\nsample12\nWT\ntreated\n\n\nsample13\nKO_geneA\ntreated\n\n\nsample14\nKO_geneA\ntreated\n\n\nsample15\nKO_geneA\ntreated\n\n\nsample16\nKO_geneA\ntreated\n\n\n\nHow would the design formula be structured to perform the following analyses?\n\nTest for the effect of treatment.\nTest for the effect of genotype, while regressing out the variation due to treatment.\nTest for the effect of genotype on the treatment effects.",
    "crumbs": [
      "Day 2:",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05a_hypothesis_testing.html",
    "href": "lessons/05a_hypothesis_testing.html",
    "title": "Hypothesis testing and multiple testing",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/05a_hypothesis_testing.html#learning-objectives",
    "href": "lessons/05a_hypothesis_testing.html#learning-objectives",
    "title": "Hypothesis testing and multiple testing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the process of model fitting\nCompare two methods for hypothesis testing (Wald test vs. LRT)\nRecognize the importance of multiple test correction\nIdentify different methods for multiple test correction",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/05a_hypothesis_testing.html#generalized-linear-model",
    "href": "lessons/05a_hypothesis_testing.html#generalized-linear-model",
    "title": "Hypothesis testing and multiple testing",
    "section": "Generalized Linear Model",
    "text": "Generalized Linear Model\nAs described earlier, the count data generated by RNA-seq exhibits overdispersion (variance &gt; mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a negative binomial distribution to model the RNA-seq counts using the equation below:\n\n\n\nThe two parameters required are the size factor and the dispersion estimate. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.\n\n\n\n\n\n\nNote\n\n\n\n“In statistics, the generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows for response variables that have error distribution models other than a normal distribution. The GLM generalizes linear regression by allowing the linear model to be related to the response variable via a link function and by allowing the magnitude of the variance of each measurement to be a function of its predicted value.” (Wikipedia).\n\n\nAfter the model is fit, coefficients are estimated for each sample group along with their standard error. The coefficents are the estimates for the log2 foldchanges, and will be used as input for hypothesis testing.",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/05a_hypothesis_testing.html#hypothesis-testing",
    "href": "lessons/05a_hypothesis_testing.html#hypothesis-testing",
    "title": "Hypothesis testing and multiple testing",
    "section": "Hypothesis testing",
    "text": "Hypothesis testing\nThe first step in hypothesis testing is to set up a null hypothesis for each gene. In our case, the null hypothesis is that there is no differential expression across the two sample groups (LFC == 0). Notice that we can do this without observing any data, because it is based on a thought experiment. Second, we use a statistical test to determine if, based on the observed data, the null hypothesis is true.\n\nWald test\nIn DESeq2, the Wald test is the default used for hypothesis testing when comparing two groups. The Wald test is a test usually performed on parameters that have been estimated by maximum likelihood. In our case we are testing each gene model coefficient (LFC), which was derived using parameters like dispersion that were estimated using maximum likelihood. If there are more than 2 sample classes within a variable (for example, if you had low, medium, and high treatment levels) then DESeq2 will generate two pairwise comparisons when low is set as the control (see here for more info): low vs. medium, and low vs. high.\nDESeq2 implements the Wald test by:\n\nTaking the LFC and dividing it by its standard error, resulting in a z-statistic\nThe z-statistic is compared to a standard normal distribution, and a p-value is computed reporting the probability that a z-statistic at least as extreme as the observed value would be selected at random\nIf the p-value is small, we reject the null hypothesis and state that there is evidence against the null (i.e., the gene is differentially expressed).\n\nThe model fit and Wald test were already run previously as part of the DESeq() function:\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\n\n\nLikelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test (LRT) as an alternative hypothesis test for when we are comparing more than two sample classes. Rather than evaluating whether a gene’s expression is up- or down-regulated in one class compared to another, the LRT identifies genes that are changing in expression in any direction across the different sample classes.\nHow does this compare to the Wald test?\nThe Wald test (default) only estimates one model per gene and evaluates the null hypothesis that LFC == 0.\nFor the Likelihood Ratio Test is also performed on parameters that have been estimated by maximum likelihood. For this test two models are estimated per gene; the fit of one model is compared to the fit of the other model.\n\n\n\n\nm1 is the reduced model (i.e., the design formula with your main factor term removed)\nm2 is the full model (i.e., the full design formula you provided when creating your dds object)\n\n\n\n\n\n\n\nImportant\n\n\n\nThis type of test can be especially useful in analyzing time course experiments.\n\n\nHere, we are evaluating the null hypothesis that the full model fits just as well as the reduced model. If we reject the null hypothesis, this suggests that there is a significant amount of variation explained by the full model (and our main factor of interest), therefore the gene is differentially expressed across the different levels. DESeq2 implements the LRT by using an Analysis of Deviance (ANODEV) to compare the two model fits. It is shown that LR follows a chi-squared distribution, and this can be used to calculate and associated p-value.\nTo use the LRT, we use the DESeq() function but this time adding two arguments:\n\nspecifying that we want to use the LRT test\nthe ‘reduced’ model\n\n\n# The full model was specified previously with the `design = ~ sampletype`:\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = meta, ~ sampletype)\n\n# Likelihood ratio test\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\n\nSince our ‘full’ model only has one factor (sampletype), the ‘reduced’ model (removing that factor) leaves us with nothing in our design formula. DESeq2 cannot fit a model with nothing in the design formula, and so in the scenario where you have no additional covariates the intercept is modeled using the syntax ~ 1.\n\n\n\n\n\n\nExercise\n\n\n\nYou are studying brain maturation and growth patterns in mouse cortex and have obtained RNA-seq data for a total of 24 mice. These samples were acquired at 2 developmental stages (3 dpf and 10 dpf) and with or without treatment using a growth inhibitor (Monoamine oxidase (MAO) inhibitors). For each developmental stage and treatment combination you have 6 replicates. You also have sex information for these mice (12 males and 12 females).\n\nWhat steps are necessary to take to decide what your model should be?\nWhat is an appropriate hypothesis test if you are testing for expression differences across the developmental stages?\nProvide the line of code used to create the dds object.\nProvide the line of code used to run DESeq2.\nWould you use a different hypothesis test if you had 3 developmental timepoints?",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/05a_hypothesis_testing.html#multiple-test-correction",
    "href": "lessons/05a_hypothesis_testing.html#multiple-test-correction",
    "title": "Hypothesis testing and multiple testing",
    "section": "Multiple test correction",
    "text": "Multiple test correction\nRegardless of whether we use the Wald test or the LRT, each gene that has been tested will be associated with a p-value. It is this result which we use to determine which genes are considered significantly differentially expressed. However, we cannot use the p-value directly.\n\nWhat does the p-value mean?\nA gene with a significance cut-off of p &lt; 0.05, means there is a 5% chance it is a false positive. For example, if we test 20,000 genes for differential expression, at p &lt; 0.05 we would expect to find 1,000 genes by chance. If we found 3,000 genes to be differentially expressed total, roughly one third of our genes are false positives! We would not want to sift through our “significant” genes to identify which ones are true positives.\nSince each p-value is the result of a single test (single gene), the more genes we test, the more we inflate the false positive rate. This is the multiple testing problem.\n\n\nCorrecting the p-value for multiple testing\nThere are a few common approaches for multiple test correction:\n\nBonferroni: The adjusted p-value is calculated by: p-value * m (m = total number of tests). This is a very conservative approach with a high probability of false negatives, so is generally not recommended.\nFDR/Benjamini-Hochberg: Benjamini and Hochberg (1995) defined the concept of False Discovery Rate (FDR) and created an algorithm to control the expected FDR below a specified level given a list of independent p-values. More info about BH.\nQ-value / Storey method: The minimum FDR that can be attained when calling that feature significant. For example, if gene X has a q-value of 0.013 it means that 1.3% of genes that show p-values at least as small as gene X are false positives.\n\nDESeq2 helps reduce the number of genes tested by removing those genes unlikely to be significantly DE prior to testing, such as those with low number of counts and outlier samples (gene-level QC). However, multiple test correction is also implemented to reduce the False Discovery Rate using an interpretation of the Benjamini-Hochberg procedure.\nSo what does FDR &lt; 0.05 mean?\nBy setting the FDR cutoff to &lt; 0.05, we’re saying that the proportion of false positives we expect amongst our differentially expressed genes is 5%. For example, if you call 500 genes as differentially expressed with an FDR cutoff of 0.05, you expect 25 of them to be false positives.\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/04b_DGE_DESeq2_analysis.html",
    "href": "lessons/04b_DGE_DESeq2_analysis.html",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/04b_DGE_DESeq2_analysis.html#learning-objectives",
    "href": "lessons/04b_DGE_DESeq2_analysis.html#learning-objectives",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain the different steps involved in running DESeq()\nExamine size factors and understand the source of differences\nInspect gene-level dispersion estimates\nRecognize the importance of dispersion during differential expression analysis",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/04b_DGE_DESeq2_analysis.html#deseq2-differential-gene-expression-analysis-workflow",
    "href": "lessons/04b_DGE_DESeq2_analysis.html#deseq2-differential-gene-expression-analysis-workflow",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "DESeq2 differential gene expression analysis workflow",
    "text": "DESeq2 differential gene expression analysis workflow\nPreviously, we created the DESeq2 object using the appropriate design formula and running DESeq2 using the two lines of code:\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\nWe completed the entire workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below:\n\n\n\nWe will be taking a detailed look at each of these steps to better understand how DESeq2 is performing the statistical analysis and what metrics we should examine to explore the quality of our analysis.\n\nStep 1: Estimate size factors\nThe first step in the differential expression analysis is to estimate the size factors, which is exactly what we already did to normalize the raw counts.\n\n\n\nDESeq2 will automatically estimate the size factors when performing the differential expression analysis. However, if you have already generated the size factors using estimateSizeFactors(), as we did earlier, then DESeq2 will use these values.\nTo normalize the count data, DESeq2 calculates size factors for each sample using the median of ratios method discussed previously in the ‘Count normalization’ lesson.\n\nMOV10 DE analysis: examining the size factors\nLet’s take a quick look at size factor values we have for each sample:\n\n# Check the size factors\nsizeFactors(dds)\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n 1.1150371  0.9606366  0.7493552  1.5634128  0.9359082  1.2257749  1.1406863 \nMov10_oe_3 \n 0.6541689 \n\n\nThese numbers should be identical to those we generated initially when we had run the function estimateSizeFactors(dds). Take a look at the total number of reads for each sample:\n\n# Total number of raw counts per sample\ncolSums(counts(dds))\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n  31160785   26504972   20498243   45300696   26745860   32062221   30025690 \nMov10_oe_3 \n  17285401 \n\n\nHow do the numbers correlate with the size factor?\nWe see that the larger size factors correspond to the samples with higher sequencing depth, which makes sense, because to generate our normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.\nNow take a look at the total depth after normalization using:\n\n# Total number of normalized counts per sample\ncolSums(counts(dds, normalized=T))\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n  27945962   27591050   27354509   28975519   28577441   26156696   26322477 \nMov10_oe_3 \n  26423452 \n\n\nHow do the values across samples compare with the total counts taken for each sample?\nYou might have expected the counts to be the exact same across the samples after normalization. However, DESeq2 also accounts for RNA composition during the normalization procedure. By using the median ratio value for the size factor, DESeq2 should not be biased to a large number of counts sucked up by a few DE genes; however, this may lead to the size factors being quite different than what would be anticipated just based on sequencing depth.\n\n\n\nStep 2: Estimate gene-wise dispersion\nThe next step in the differential expression analysis is the estimation of gene-wise dispersions. Before we get into the details, we should have a good idea about what dispersion is referring to in DESeq2.\n\n\n\nIn RNA-seq count data, we know:\n\nTo determine differentially expressed genes, we evaluate the variation of expression between groups (of interest) and compare that to the variation within the groups (between replicates).\nFor each individual gene, the mean is not equal to the variance.\n\n\nGenes that are highly expressed will have a more consistent level of variations, but it will be higher than the mean.\nLowly expressed genes will exhibit variation that hovers around the mean (but with a higher amount of variability).\n\nThis complicated relationship means that we cannot just use the observed variance to account for within-group variation. Instead DESeq2 uses dispersion.\n\n\n\nWhat is dispersion?\nThe dispersion parameter models the within-group variability by describing how much the variance deviates from the mean. A dispersion of 1 would indicate that there is no deviance from the mean (i.e., mean == variance). A typical RNA-seq dataset will exhibit some amount of biological variability present across replicates and so we will always have dispersion values less than one.\n\n\n\n\nEffect on dispersion\n\n\n\n\nVariance increases\nDispersion increases\n\n\nMean expression increases\nDispersion decreases\n\n\n\nDispersion values in DESeq2\nDESeq2 estimates the dispersion for each gene based on the gene’s expression level (mean counts of within-group replicates) and observed variance across replicates, as we demonstrated with the formula above. In this way, the dispersion estimates for genes with the same mean will differ only based on their variance. Therefore, the dispersion estimates reflect the variance in gene expression for a given mean value.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this plot we have dispersion on the y-axis and mean normalized counts on the x-axis. Each black dot represents a gene and its intial maximum likelihood dispersion estimate (MLE) given the observed data. Simply looking at the trend of black dots, we observe an inverse relationship between mean and dispersion. More detail on the fitted red line and blue dots will be described later in this lesson.\n\n\nSince we have only a few (3-6) replicates per group, the dispersion estimates for each gene are often unreliable. As we walk through the next few steps, we will discuss how this issue is resolved.\n\n\nStep 3: Fit curve to gene-wise dispersion estimates\nThe next step in the workflow is to fit a curve to the gene-wise dispersion estimates. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability but, across all genes, there will be a distribution of reasonable estimates of dispersion.\n\n\n\nThis curve is displayed as a red line in the figure presented below. This fitted line allows DESeq2 to utilize information across all genes to generate more accurate estimates using a method called ‘shrinkage’ (described in Step 4).\n\n\n\n\n\nStep 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve\nThe next step in the workflow is to shrink the gene-wise dispersion estimates toward the expected dispersion values.\n\n\n\nDESeq2 assumes that genes with similar expression levels should have similar dispersion. As such, the fitted curve provides a range of expected dispersion values a range of mean expression level.\nIf the initial estimate (black dot) is much lower than the fitted curve, then values are shrunken (blue dots) towards the red line. Dispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation; however, genes with extremely high dispersion values are not (see right side figure below; these genes are shown surrounded by blue circle). This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons [1].\n\n\n\nMAP, maximum a posteriori; MLE, maximum-likelihood estimate. For more detailed information please see Love MI, Huber W, Anders S, Genome Biology 2014\nThe strength of the shrinkage for each gene depends on:\n\nhow close gene dispersions are from the curve\nsample size (more samples = less shrinkage)\n\nThis dispersion shrinkage method is particularly important to reduce false positives in the differential expression analysis. This step allows for more accurate identification of differentially expressed genes when sample sizes are small.\n\n\nInterpretation of the dispersion plot\nTo create this plot with your data, you use the function:\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\n\n\n\n\n\n\nThis is a good plot to examine to ensure your data is a good fit for the DESeq2 model. Evaluate the plot to see:\n\nWhether the data points generally scatter around the curve, with the dispersion decreasing with increasing mean expression levels.\nHow much shrinkage you get across the whole range of means in your data. For any experiment with low degrees of freedom, you will expect to see more shrinkage.\nIf the data scatter in a cloud or different shapes, then you might want to explore your data more to see if you have contamination (mitochondrial, etc.) or outlier samples.\n\nExamples of worrisome dispersion plots are shown below:\nThe plot below shows a cloud of dispersion values, which do not generally follow the curve. This would be worrisome and suggests a bad fit of the data to the model.\n\n\n\nThe next plot shows the dispersion values initially decreasing, then increasing with larger expression values. The larger mean expression values should not have larger dispersions based on our expectations - we expect decreasing dispersions with increasing mean. This indicates that there is less variation for more highly expressed genes than expected. This also indicates that there could be an outlier sample or contamination present in our analysis.\n\n\n\n\nMOV10 DE analysis: exploring the dispersion estimates and assessing model fit\nLet’s take a look at the dispersion estimates for our MOV10 data:\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\n\n\n\n\n\n\nSince we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model?\nWe see a nice decrease in dispersion with increasing mean expression, which is good. We also see the dispersion estimates generally surround the curve, which is also expected. Overall, this plot looks good. We do see strong shrinkage, which is likely due to the fact that we have only two replicates for one of our sample groups. The more replicates we have, the less shrinkage is applied to the dispersion estimates, and the more DE genes are able to be identified. We would generally recommend having at least 4 biological replicates per condition for better estimation of variation.\n\n\n\n\n\n\nExercise\n\n\n\nGiven the dispersion plot below, would you have any concerns regarding the fit of your data to the model?\n\nIf not, what aspects of the plot makes you feel confident about your data?\nIf so, what are your concerns? What would you do to address them?\n\n\n\n\n\n\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html",
    "href": "lessons/05b_wald_test_results.html",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#learning-objectives",
    "href": "lessons/05b_wald_test_results.html#learning-objectives",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss the steps required to generate a results table for pairwise comparisons (Wald test)\nSummarize the different levels of gene filtering\nExplain log fold change shrinkage",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#specifying-contrasts",
    "href": "lessons/05b_wald_test_results.html#specifying-contrasts",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "Specifying contrasts",
    "text": "Specifying contrasts\nIn our dataset, we have a single variable in our design formula that has three sample classes (levels) so we can make three possible pairwise comparisons:\n\nControl vs. Mov10 overexpression\nControl vs. Mov10 knockdown\nMov10 knockdown vs. Mov10 overexpression\n\nWe are really only interested in #1 and #2 from above. When we initially created our dds object, we had provided ~ sampletype as our design formula, indicating that sampletype is our main factor of interest.\nTo indicate which two sample classes we are interested in comparing, we need to specify contrasts. The contrasts are used as input to the DESeq2 results() function to extract the desired results.\n\n\n\n\n\n\nNote\n\n\n\nIf we run the results() function without specifying contrast or name, it will return the comparison of the last level of the last variable in the design formula over the first level of this variable. If the order of levels are not specified, they are ordered alphabetically by DESeq2.\n\n\nContrasts can be specified in two different ways (with the first method more commonly used):\n\nContrasts can be supplied as a character vector with exactly three elements: the name of the factor (of interest) in the design formula and the name of the two factors levels to compare. The factor level given last is the base level for the comparison. The syntax is given below:\n\n\n## DO NOT RUN THIS CODE\n\n# Set up contrast\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\n\n\nContrasts can be given as a list of 2 character vectors: the names of the fold changes for the level of interest, and the names of the fold changes for the base level. These names should match identically to the elements of resultsNames(object). This method can be useful for combining interaction terms and main effects.\n\n\n## DO NOT RUN THIS CODE\n\n# See what names to use\nresultsNames(dds)\n\n# Set up contrast\ncontrast &lt;- list(resultsNames(dds)[1], resultsNames(dds)[2])\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\n\nAlternatively, if you only had two factor levels, you could do nothing and not worry about specifying contrasts (i.e. results(dds)). In this case, DESeq2 will choose what your base factor level based on alphabetical order of the levels.\nTo start, we want to evaluate expression changes between the MOV10 overexpression samples and the control samples. As such we will use the first method for specifying contrasts and create a character vector:\n\n# Define contrasts for MOV10 overexpression\ncontrast_oe &lt;- c(\"sampletype\", \"MOV10_overexpression\", \"control\")\n\n\n\n\n\n\n\nDoes it matter what I choose to be my base level?\n\n\n\nYes, it does matter. Deciding what level is the base level will determine how to interpret the fold change that is reported. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in our factor level of interest relative to the base level. Thus, if leaving it up to DESeq2 to decide on the contrasts, be sure to check that the alphabetical order coincides with the fold change direction you are anticipating.",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#the-results-table",
    "href": "lessons/05b_wald_test_results.html#the-results-table",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "The results table",
    "text": "The results table\nNow that we have our contrast created, we can use it as input to the results() function. Let’s take a quick look at the help manual for the function:\n\n?results\n\nYou will see we have the option to provide a wide array of arguments and tweak things from the defaults as needed. As we go through the lesson we will keep coming back to the help documentation to discuss some arguments that are good to know about.\n\n# Extract results for MOV10 overexpression vs control\nres_tableOE &lt;- results(dds, contrast=contrast_oe, alpha = 0.05)\n\n\n\n\n\n\n\nNote\n\n\n\nFor our analysis, in addition to the contrast argument we will also provide a value of 0.05 for the alpha argument. We will describe this in more detail when we talk about gene-level filtering.\n\n\nThe results table that is returned to us is a DESeqResults object, which is a simple subclass of DataFrame. In many ways it can be treated like a dataframe (i.e., when accessing/subsetting data); however, it is important to recognize that there are differences for downstream steps like visualization.\n\n# Check what type of object is returned\nclass(res_tableOE)\n\n[1] \"DESeqResults\"\nattr(,\"package\")\n[1] \"DESeq2\"\n\n\nNow let’s take a look at what information is stored in the results:\n\n# What is stored in results?\nres_tableOE %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                    baseMean log2FoldChange      lfcSE        stat       pvalue\nENSG00000000003 3525.8834779    -0.43824542 0.07746073 -5.65764661 1.534627e-08\nENSG00000000005   26.2489043     0.02920801 0.44112948  0.06621187 9.472091e-01\nENSG00000000419 1478.2512405     0.38363503 0.11376092  3.37229197 7.454538e-04\nENSG00000000457  518.4220238     0.22897058 0.10233134  2.23754120 2.525099e-02\nENSG00000000460 1159.7761365    -0.26913819 0.08149934 -3.30233587 9.588318e-04\nENSG00000000938    0.4021325    -1.79625184 4.02392684 -0.44639277 6.553136e-01\n                        padj\nENSG00000000003 4.250966e-07\nENSG00000000005 9.726866e-01\nENSG00000000419 4.673923e-03\nENSG00000000457 8.023483e-02\nENSG00000000460 5.760864e-03\nENSG00000000938           NA\n\n\nWe have six columns of information reported for each gene (row). We can use the mcols() function to extract information on what the values stored in each column represent:\n\n# Get information on each column in results\nmcols(res_tableOE, use.names=T)\n\n\nbaseMean: mean of normalized counts for all samples\nlog2FoldChange: log2 fold change\nlfcSE: standard error\nstat: Wald statistic\npvalue: Wald test p-value\npadj: BH adjusted p-values",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#p-values",
    "href": "lessons/05b_wald_test_results.html#p-values",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "P-values",
    "text": "P-values\nThe p-value is a probability value used to determine whether there is evidence to reject the null hypothesis. A smaller p-value means that there is stronger evidence in favor of the alternative hypothesis. However, because we are performing a test for each individual gene we need to correct these p-values for multiple testing.\nThe padj column in the results table represents the p-value adjusted for multiple testing, and is the most important column of the results. Typically, a threshold such as padj &lt; 0.05 is a good starting point for identifying significant genes. The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR). There are other corrections methods available and can be changed by adding the pAdjustMethod argument to the results() function.\n\nGene-level filtering\nLet’s take a closer look at our results table. As we scroll through it, you will notice that for selected genes there are NA values in the pvalue and padj columns. What does this mean?\n\n\n\nThe missing values represent genes that have undergone filtering as part of the DESeq() function. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. DESeq2 does not physically remove any genes from the original counts matrix, and so all genes will be present in your results table. The genes omitted by DESeq2 meet one of the three filtering criteria outlined below:\n1. Genes with zero counts in all samples\nIf, within a row, all samples have zero counts, there is no expression information and therefore these genes are not tested.\n\n# Filter genes by zero expression\nres_tableOE[which(res_tableOE$baseMean == 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                baseMean log2FoldChange lfcSE stat pvalue padj\nENSG00000005381        0             NA    NA   NA     NA   NA\nENSG00000008196        0             NA    NA   NA     NA   NA\nENSG00000008197        0             NA    NA   NA     NA   NA\nENSG00000008438        0             NA    NA   NA     NA   NA\nENSG00000011083        0             NA    NA   NA     NA   NA\nENSG00000011600        0             NA    NA   NA     NA   NA\n\n\nThe baseMean column for these genes will be zero, and the log2 fold change estimates, p-value, and adjusted p-value will all be set to NA.\n2. Genes with an extreme count outlier\nThe DESeq() function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook’s distance. Cook’s distance is a measure of how much a single sample is influencing the fitted coefficients for a gene, and a large value of Cook’s distance is intended to indicate an outlier count. Genes that contain a Cook’s distance above a threshold are flagged; however, at least 3 replicates are required for flagging, as it is difficult to judge which sample might be an outlier with only 2 replicates. We can turn off this filtering by using the cooksCutoff argument in the results() function.\n\n# Filter genes that have an extreme outlier\nres_tableOE[which(is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) &\n                    res_tableOE$baseMean &gt; 0), ] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                 baseMean log2FoldChange    lfcSE       stat pvalue padj\nENSG00000001626 123.83122     -0.3561765 3.438228 -0.1035930     NA   NA\nENSG00000008226  67.82651      5.8902223 1.973889  2.9840702     NA   NA\nENSG00000058866 116.38549      0.8519290 2.133619  0.3992882     NA   NA\nENSG00000060709 108.76629      4.5901999 1.716474  2.6742036     NA   NA\nENSG00000100346 121.65513      6.3764242 1.803765  3.5350630     NA   NA\nENSG00000100427  37.51051     -2.1283061 1.491536 -1.4269224     NA   NA\n\n\nIf a gene contains a sample with an extreme count outlier, then the p-value and adjusted p-value will be set to NA.\n3. Genes with a low mean normalized counts\nDESeq2 defines a low mean threshold, that is empirically determined from your data, in which the fraction of significant genes can be increased by reducing the number of genes that are considered for multiple testing. This is based on the notion that genes with very low counts are not likely to see significant differences typically due to high dispersion.\n\n\n\nImage courtesy of slideshare presentation from Joachim Jacob, 2014.\nAt a user-specified value (alpha = 0.05), DESeq2 evaluates the change in the number of significant genes as it filters out increasingly bigger portions of genes based on their mean counts, as shown in the figure above. The point at which the number of significant genes reaches a peak is the low mean threshold that is used to filter genes that undergo multiple testing. There is also an argument to turn off the filtering off by setting independentFiltering = F.\n\n# Filter genes below the low mean threshold\nres_tableOE[which(!is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) & \n                    res_tableOE$baseMean &gt; 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                  baseMean log2FoldChange     lfcSE       stat     pvalue padj\nENSG00000000938  0.4021325     -1.7962518 4.0239268 -0.4463928 0.65531356   NA\nENSG00000000971 11.3963043     -0.6130577 0.7765898 -0.7894228 0.42986491   NA\nENSG00000002079  4.3709939     -0.4818745 1.5967741 -0.3017800 0.76281979   NA\nENSG00000002726  1.7387962     -0.3834632 1.9626071 -0.1953846 0.84509186   NA\nENSG00000002745  7.2065290      0.3893227 0.7689269  0.5063195 0.61263235   NA\nENSG00000002933 10.6169395     -1.4313952 0.6449326 -2.2194493 0.02645617   NA\n\n\nIf a gene is filtered by independent filtering, then only the adjusted p-value will be set to NA.\n\n\n\n\n\n\nImportant\n\n\n\nDESeq2 will perform the filtering outlined above by default; however, other DE tools such as EdgeR will not. Filtering is a necessary step, even if you are using limma-voom and/or edgeR’s quasi-likelihood methods. Be sure to follow pre-filtering steps when using other tools, as outlined in their user guides found on Bioconductor, as they generally perform much better.",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#fold-change",
    "href": "lessons/05b_wald_test_results.html#fold-change",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "Fold change",
    "text": "Fold change\nAnother important column in the results table is the log2FoldChange. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also add a fold change threshold. Keep in mind when setting that value that we are working with log2 fold changes, so a cutoff of log2FoldChange &lt; 1 would translate to an actual fold change of 2.\n\n\n\n\n\n\nAn alternative approach to add the fold change threshold:\n\n\n\nThe results() function has an option to add a fold change threshold using the lfcThrehsold argument. This method is more statistically motivated, and is recommended when you want a more confident set of genes based on a certain fold-change. It actually performs a statistical test against the desired threshold, by performing a two-tailed test for log2 fold changes greater than the absolute value specified. The user can change the alternative hypothesis using altHypothesis and perform two one-tailed tests as well. This is a more conservative approach, so expect to retrieve a much smaller set of genes!\n\n\nThe fold changes reported in the results table are calculated by:\nlog2 (normalized_counts_group1 / normalized_counts_group2)\nThe problem is, these fold change estimates are not entirely accurate, as they do not account for the large dispersion we observe with low read counts. To address this, the log2 fold changes need to be adjusted.\n\nMore accurate LFC estimates\nTo generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:\n\nLow counts\nHigh dispersion values\n\nLFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.\n\n\n\nIllustration taken from the DESeq2 paper.\nIn the figure above, we have an example using two genes: green gene and purple gene. For each gene, the expression values are plotted for each sample in the two different mouse strains (C57BL/6J and DBA/2J). Both genes have the same mean values for the two sample groups, but the green gene has little variation within group while the purple gene has high levels of variation. For the green gene with low within group variation, the unshrunken LFC estimate (vertex of the green solid line) is very similar to the shrunken LFC estimate (vertex of the green dotted line). However, LFC estimates for the purple gene are quite different due to the high dispersion. So even though two genes can have similar normalized count values, they can have differing degrees of LFC shrinkage. Notice the LFC estimates are shrunken toward the prior (black solid line).\nShrinking the log2 fold changes will not change the total number of genes that are identified as significantly differentially expressed. The shrinkage of fold change is to help with downstream assessment of results. For example, if you wanted to subset your significant genes based on fold change for further evaluation, you may want to use shruken values. Additionally, for functional analysis tools such as GSEA that require fold change values as input, you would want to provide shrunken values.\nTo generate the shrunken log2 fold change estimates, you have to run an additional step on your results object (that we will create below) with the function lfcShrink().\n\n# Save the unshrunken results to compare\nres_tableOE_unshrunken &lt;- res_tableOE\n\n# Apply fold change shrinkage\nres_tableOE &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_overexpression_vs_control\", type=\"apeglm\")\n\nDepending on the version of DESeq2 you are using, the default method for shrinkage estimation will differ. The defaults can be changed by adding the argument type in the lfcShrink() function as we have above. For most recent versions of DESeq2, type=\"normal\" is the default and was the only method in earlier versions. It has been shown that in most situations there are alternative methods that have less bias than the ’normal` method, and therefore we chose to use apeglm.\nNote that the stat column is no longer present in the results table. You can compare by inspecting the output of res_tableOE and res_tableOE_unshrunken in the R console. If you run type=\"apeglm\" or type=\"ashr\", you do not get a stat column because these don’t really make sense in the context of the posterior quantities that are returned.\n\n\n\n\n\n\nShrinkage\n\n\n\nFor more information on shrinkage, the DESeq2 vignette has an Extended section on shrinkage estimators that is quite useful.\n\n\n\n\n\n\n\n\ncontrast vs coef\n\n\n\nWhen using the alternative methods, rather than using the contrast argument, you will be required to specify coef. Using contrast forms an expanded model matrix, treating all factor levels equally, and averages over all distances between all pairs of factor levels to estimate the prior. Using coef means looking only at that column of the model matrix (so usually that would be one level against the reference level) and estimates the prior for that coefficient from the distribution of those MLE of coefficients. When using coef, the shrinkage depends on which level is chosen as reference.\n\n\n\n\n\n\n\n\nHow do I know what to value to provide to the coef argument?\n\n\n\nThe value you provide here needs to match identically to what is stored in the column header of the coefficients table. To see what values you have to work with you can use resultsNames(dds).",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05b_wald_test_results.html#ma-plot",
    "href": "lessons/05b_wald_test_results.html#ma-plot",
    "title": "Exploring DESeq2 results: Wald test",
    "section": "MA plot",
    "text": "MA plot\nA plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot.\nLet’s start with the unshrunken results:\n\n# MA plot using unshrunken fold changes\nplotMA(res_tableOE_unshrunken, ylim=c(-2,2))\n\n\n\n\n\n\n\n\nAnd now the shrunken results:\n\n# MA plot using shrunken fold changes\nplotMA(res_tableOE, ylim=c(-2,2))\n\n\n\n\n\n\n\n\nIn the first plot, you have the unshrunken fold change values, and you can see the abundance of scatter for the the lowly-expressed genes. That is, many of the low expressors exhibit very high fold changes. After shrinkage, we see the fold changes are much smaller estimates.\nIn addition to the comparison described above, this plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression. Generally, we would expect to see significant genes across the full range of expression levels.\n\n\n\n\n\n\nExcercise\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\nNow that we have results for the overexpression results, do the same for the Control vs. Knockdown samples.\n\nCreate a contrast vector called contrast_kd.\nUse contrast vector in the results() to extract a results table and store that to a variable called res_tableKD.\nShrink the LFC estimates using lfcShrink() and assign it back to res_tableKD.\n\n\n\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results: Wald test"
    ]
  },
  {
    "objectID": "lessons/05c_summarizing_results.html",
    "href": "lessons/05c_summarizing_results.html",
    "title": "Summarizing results from the Wald test",
    "section": "",
    "text": "Approximate time: 20 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/05c_summarizing_results.html#learning-objectives",
    "href": "lessons/05c_summarizing_results.html#learning-objectives",
    "title": "Summarizing results from the Wald test",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nEvaluate the number of differentially expressed genes produced for each comparison\nConstruct R objects containing significant genes from each comparison",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/05c_summarizing_results.html#summarizing-results",
    "href": "lessons/05c_summarizing_results.html#summarizing-results",
    "title": "Summarizing results from the Wald test",
    "section": "Summarizing results",
    "text": "Summarizing results\nTo summarize the results table, a handy function in DESeq2 is summary(). Confusingly it has the same name as the function used to inspect data frames. This function, when called with a DESeq results table as input, will summarize the results using a default threshold of padj &lt; 0.1. However, since we had set the alpha argument to 0.05 when creating our results table, the summary() function should also use the threshold FDR &lt; 0.05. (Note that padj/FDR is used even though the output says p-value &lt; 0.05.) Let’s start with the OE vs control results:\n\n# Summarize results\nsummary(res_tableOE, alpha = 0.05)\n\n\nout of 38903 with nonzero total read count\nadjusted p-value &lt; 0.05\nLFC &gt; 0 (up)       : 2004, 5.2%\nLFC &lt; 0 (down)     : 2770, 7.1%\noutliers [1]       : 28, 0.072%\nlow counts [2]     : 20580, 53%\n(mean count &lt; 13)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n\nIn addition to the number of genes up- and down-regulated at the default threshold, the function also reports the number of genes that were tested (genes with non-zero total read count), and the number of genes not included in multiple test correction due to a low mean count.",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/05c_summarizing_results.html#extracting-significant-differentially-expressed-genes",
    "href": "lessons/05c_summarizing_results.html#extracting-significant-differentially-expressed-genes",
    "title": "Summarizing results from the Wald test",
    "section": "Extracting significant differentially expressed genes",
    "text": "Extracting significant differentially expressed genes\nLet’s first create variables that contain our threshold criteria. We will only be using the adjusted p-values in our criteria:\n\n# Set thresholds\npadj.cutoff &lt;- 0.05\n\nWe can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble:\n\n# Create a tibble of results\nres_tableOE_tb &lt;- res_tableOE %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\nNow we can subset that table to only keep the significant genes using our pre-defined thresholds:\n\n# Subset the tibble to keep only significant genes\nsigOE &lt;- res_tableOE_tb %&gt;%\n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Take a quick look at this tibble\nsigOE\n\n# A tibble: 4,774 × 6\n   gene            baseMean log2FoldChange  lfcSE       pvalue        padj\n   &lt;chr&gt;              &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1 ENSG00000000003    3526.         -0.420 0.0781 0.0000000153 0.000000443\n 2 ENSG00000000419    1478.          0.341 0.115  0.000745     0.00487    \n 3 ENSG00000000460    1160.         -0.247 0.0808 0.000959     0.00599    \n 4 ENSG00000001084    2561.         -0.270 0.0936 0.00144      0.00842    \n 5 ENSG00000001167    2501.         -0.288 0.0650 0.00000330   0.0000496  \n 6 ENSG00000002016     921.         -0.273 0.116  0.00660      0.0291     \n 7 ENSG00000002330     715.         -0.403 0.132  0.000435     0.00309    \n 8 ENSG00000002549    1542.         -0.260 0.0876 0.00123      0.00736    \n 9 ENSG00000002834    2669.         -0.227 0.0538 0.0000125    0.000154   \n10 ENSG00000002919     886.         -0.389 0.0867 0.00000164   0.0000271  \n# ℹ 4,764 more rows\n\n\n\n\n\n\n\n\nExercise\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\n\nUsing the same p-adjusted threshold as above (padj.cutoff &lt; 0.05), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.\nHow many genes are differentially expressed in the Knockdown compared to Control? How does this compare to the overexpression significant gene list (in terms of numbers)?\n\n\n\nNow that we have extracted the significant results, we are ready for visualization!\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/06_DGE_visualizing_results.html",
    "href": "lessons/06_DGE_visualizing_results.html",
    "title": "Advanced visualizations",
    "section": "",
    "text": "Approximate time: 75 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced visualizations"
    ]
  },
  {
    "objectID": "lessons/06_DGE_visualizing_results.html#learning-objectives",
    "href": "lessons/06_DGE_visualizing_results.html#learning-objectives",
    "title": "Advanced visualizations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nSetup results data for application of visualization techniques\nDescribe different data visualization useful for exploring results from a DGE analysis\nCreate a volcano plot to evaluate relationship amongst DGE statistics\nCreate a heatmap to illustrate expression changes of differentially expressed genes",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced visualizations"
    ]
  },
  {
    "objectID": "lessons/06_DGE_visualizing_results.html#visualizing-the-results",
    "href": "lessons/06_DGE_visualizing_results.html#visualizing-the-results",
    "title": "Advanced visualizations",
    "section": "Visualizing the results",
    "text": "Visualizing the results\nWhen we are working with large amounts of data, it can be useful to display that information graphically to gain more insight. During this lesson, we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data. Many of these plots can be helpful in visualizing other types of data as well.\nWe will be working with three different data objects we have already created in earlier lessons:\n\nMetadata for our samples (a dataframe): meta\nNormalized expression data for every gene in each of our samples (a matrix): normalized_counts\nTibble versions of the DESeq2 results we generated in the last lesson: res_tableOE_tb and res_tableKD_tb\n\nFirst, let’s create a metadata tibble from the data frame (don’t lose the row names!)\n\n# Make metadata tibble\nmov10_meta &lt;- meta %&gt;% \n  rownames_to_column(var=\"samplename\") %&gt;% \n  as_tibble()\n\nNext, let’s bring in a column with gene symbols to the normalized_counts object, so we can use them to label our plots. Ensembl IDs are great for many things, but the gene symbols are much more recognizable to us, as biologists.\n\n# DESeq2 creates a matrix when you use the counts() function\n# First convert normalized_counts to a data frame and transfer the row names to a new column called \"gene\"\nnormalized_counts &lt;- counts(dds, normalized=TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") \n  \n# Next, merge together (ensembl IDs) the normalized counts data frame\n# with a subset of the annotations in the tx2gene data frame (only the columns for ensembl gene IDs and gene symbols)\ngrch38annot &lt;- tx2gene %&gt;% \n  dplyr::select(ensgene, symbol) %&gt;% \n  dplyr::distinct()\n\n# This will bring in a column of gene symbols\nnormalized_counts &lt;- merge(normalized_counts, grch38annot, by.x=\"gene\", by.y=\"ensgene\")\n\n# Now create a tibble for the normalized counts\nnormalized_counts &lt;- normalized_counts %&gt;%\n  as_tibble()\n\n# View at the tibble to make sure it looks correct\nnormalized_counts %&gt;% head()\n\n# A tibble: 6 × 10\n  gene         Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1\n  &lt;chr&gt;             &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 ENSG0000000…   3925.       3794.       3961.     3952.       3941.      2727. \n2 ENSG0000000…     24.2        30.2        30.7      23.7        13.9       20.4\n3 ENSG0000000…   1326.       1341.       1180.     1515.       1432.      1542. \n4 ENSG0000000…    456.        422.        476.      597.        610.       527. \n5 ENSG0000000…   1250.       1212.       1134.     1389.       1300.       965. \n6 ENSG0000000…      0.897       1.04        0         1.28        0          0  \n# ℹ 3 more variables: Mov10_oe_2 &lt;dbl&gt;, Mov10_oe_3 &lt;dbl&gt;, symbol &lt;chr&gt;\n\n\n\n\n\n\n\n\nA possible alternative to the above:\n\n\n\n\nnormalized_counts &lt;- counts(dds, normalized=TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  as_tibble() %&gt;%\n  left_join(grch38annot, by=c(\"gene\" = \"ensgene\"))\n\n\n\n\nPlotting signicant DE genes\nOne way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes.\n\nUsing DESeq2 plotCounts() to plot expression of a single gene\nTo pick out a specific gene of interest to plot, for example MOV10, we can use the plotCounts() from DESeq2. plotCounts() requires that the gene specified matches the original input to DESeq2, which in our case was Ensembl IDs.\n\n# Find the Ensembl ID of MOV10\ngrch38annot[grch38annot$symbol == \"MOV10\", \"ensgene\"]\n\n[1] \"ENSG00000155363\"\n\n# Plot expression for single gene\nplotCounts(dds, gene=\"ENSG00000155363\", intgroup=\"sampletype\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis DESeq2 function only allows for plotting the counts of a single gene at a time, and is not flexible regarding the appearance.\n\n\n\n\nUsing ggplot2 to plot expression of a single gene\nIf you wish to change the appearance of this plot, we can save the output of plotCounts() to a variable specifying the returnData=TRUE argument, then use ggplot():\n\n# Save plotcounts to a data frame object\nd &lt;- plotCounts(dds, gene=\"ENSG00000155363\", intgroup=\"sampletype\", returnData=TRUE)\n\n# What is the data output of plotCounts()?\nd %&gt;% head()\n\n                count           sampletype\nIrrel_kd_1   1911.647              control\nIrrel_kd_2   1974.191              control\nIrrel_kd_3   2072.948              control\nMov10_kd_2   1419.191      MOV10_knockdown\nMov10_kd_3   1486.757      MOV10_knockdown\nMov10_oe_1 274747.523 MOV10_overexpression\n\n# Plot the MOV10 normalized counts, using the samplenames (rownames(d)) as labels\nggplot(d, aes(x = sampletype, y = count, color = sampletype)) + \n  # Scatterplot but allow points to \"jitter\" so they are not on top of each other\n  geom_point(position=position_jitter(w = 0.1,h = 0)) +\n  # Label points\n  geom_text_repel(aes(label = rownames(d))) +\n  # Add title and plot tweaks\n  ggtitle(\"MOV10\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLabel points\n\n\n\nNote that in the plot above, we are using geom_text_repel() from the ggrepel package to label our individual points on the plot.\n\n\n\n\n\n\n\n\nPlot more than one gene\n\n\n\nIf you are interested in plotting the expression of multiple genes all together, please refer to the short lesson linked here where we demo this for the top 20 most significantly expressed genes.\n\n\n\n\n\nHeatmap\nIn addition to plotting subsets, we could also extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap().\n\n# Extract normalized expression for significant genes from the OE and control samples (2:4 and 7:9)\nnorm_OEsig &lt;- normalized_counts[,c(1:4,7:9)] %&gt;% \n  dplyr::filter(gene %in% sigOE$gene)  \n\nNow let’s draw the heatmap using pheatmap:\n\n# Set a color palette\nheat_colors &lt;- RColorBrewer::brewer.pal(6, \"YlOrRd\")\n\n# Run pheatmap using the metadata dataframe for the annotation\npheatmap(norm_OEsig[2:7], \n         color = heat_colors, \n         cluster_rows = TRUE, \n         show_rownames = FALSE,\n         annotation = meta, \n         border_color = NA, \n         fontsize = 10, \n         scale = \"row\", \n         fontsize_row = 10, \n         height = 20)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThere are several additional arguments we have included in the function for aesthetics. One important one is scale=\"row\", in which Z-scores are plotted, rather than the actual normalized count value.\nZ-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed after the clustering, so that it only affects the graphical aesthetics, and the color visualization is improved.\n\n\n\n\nVolcano plot\nThe above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log-transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.\nTo generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values and, for the purposes of this visualization, a log2fold change cutoff.\n\n# Obtain logical vector where TRUE values denote padj values &lt; 0.05 and fold change &gt; 1.5 in either direction\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% \n  dplyr::mutate(threshold_OE = padj &lt; 0.05 & abs(log2FoldChange) &gt;= log2(1.5))\n\nNow we can start plotting. The geom_point object is most applicable, as this is essentially a scatter plot:\n\n# Volcano plot\nggplot(res_tableOE_tb) +\n  geom_point(aes(x = log2FoldChange, y = -log10(padj),\n                 # Color by whether or not gene is DE by padj and log2FC\n                 colour = threshold_OE)) +\n  # You could choose to limit the y-axis to look at the shape of the data without outliers\n  # scale_y_continuous(limits = c(0,50)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))  \n\n\n\n\n\n\n\n\nThis is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the volcano plot using geom_text_repel().\nFirst, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot.\n\n# Add all the gene symbols as a column from the grch38 table using bind_cols()\nres_tableOE_tb &lt;- bind_cols(res_tableOE_tb,\n                            symbol = grch38annot$symbol[match(res_tableOE_tb$gene, grch38annot$ensgene)])\n\n# Create an empty column to indicate which genes to label\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::mutate(genelabels = \"\")\n\n# Sort by padj values \nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::arrange(padj)\n\n# Populate the genelabels column with contents of the gene symbols column for the first 10 rows, i.e., the top 10 most significantly expressed genes\nres_tableOE_tb$genelabels[1:10] &lt;- as.character(res_tableOE_tb$symbol[1:10])\n\n# Look at the new table\nhead(res_tableOE_tb)\n\n# A tibble: 6 × 9\n  gene    baseMean log2FoldChange  lfcSE    pvalue      padj threshold_OE symbol\n  &lt;chr&gt;      &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;lgl&gt;        &lt;chr&gt; \n1 ENSG00…   95772.           6.99 0.122  0         0         TRUE         MOV10 \n2 ENSG00…    8090.           1.51 0.0666 3.72e-115 3.41e-111 TRUE         H1F0  \n3 ENSG00…     239.           6.50 0.363  9.45e- 72 5.76e- 68 TRUE         HSPA6 \n4 ENSG00…    5285.           1.37 0.0788 1.64e- 68 7.48e- 65 TRUE         TXNIP \n5 ENSG00…    1747.           1.48 0.0890 1.75e- 63 6.41e- 60 TRUE         HIST1…\n6 ENSG00…    2595.           1.47 0.0956 1.49e- 54 4.54e- 51 TRUE         HIST2…\n# ℹ 1 more variable: genelabels &lt;chr&gt;\n\n\nNext, we plot it as before with an additional layer for geom_text_repel() wherein we can specify the column of gene labels we just created.\n\n# Volcano plot with labels on some points\nggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) +\n  # Color by whether or not gene is DE by padj and log2FC\n  geom_point(aes(colour = threshold_OE)) +\n  # Only label the top 10 DEG we identified above\n  geom_text_repel(aes(label = genelabels)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25))) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn R package for visualization of DGE results\n\n\n\nThe Bioconductor package DEGreport can use the DESeq2 results output to make the top 20 genes and the volcano plots generated above by writing much fewer lines of code. The caveat of these functions is you lose the ability to customize plots as we have demonstrated above.\nIf you are interested, the example code below shows how you can use DEGreport to create similar plots. Note that this is example code, do not run.\n\n## DO NOT RUN THIS CODE\n\n# Plot normalized expression of top n (20) genes\nDEGreport::degPlot(dds = dds, # dds object is output from DESeq2\n                   res = res, n = 20, xs = \"type\", group = \"condition\")\n\n# Plot labeled volcano plot\nDEGreport::degVolcano(\n  data.frame(res[,c(\"log2FoldChange\",\"padj\")]), # table - 2 columns\n  plot_text = data.frame(res[1:10,c(\"log2FoldChange\",\"padj\",\"id\")])) # table to add names\n\n# Available in the newer version for R 3.4\nDEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group = \"condition\")\n\n\n\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced visualizations"
    ]
  },
  {
    "objectID": "lessons/top20_genes-expression_plotting.html",
    "href": "lessons/top20_genes-expression_plotting.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nUsing ggplot2 to plot multiple genes (e.g. top 20)\nOften it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling.\nWe are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values):\n\n# Order results by padj values\ntop20_sigOE_genes &lt;- res_tableOE_tb %&gt;% \n  arrange(padj) %&gt;% # Arrange rows by padj values\n  pull(gene) %&gt;%        # Extract character vector of ordered genes\n  head(n=20)            # Extract the first 20 genes\n\nThen, we can extract the normalized count values for these top 20 genes:\n\n# Get normalized counts for top 20 significant genes\ntop20_sigOE_norm &lt;- normalized_counts %&gt;%\n  filter(gene %in% top20_sigOE_genes)\n\nNow that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.\nThe gather() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth.\n\n\n# Gathering the columns to have normalized counts to a single column\ngathered_top20_sigOE &lt;- top20_sigOE_norm %&gt;%\n  gather(colnames(top20_sigOE_norm)[2:9], key = \"samplename\", value = \"normalized_counts\")\n\n# Check the column header in the \"gathered\" data frame\nhead(gathered_top20_sigOE)\n\n# A tibble: 6 × 4\n  gene            symbol samplename normalized_counts\n  &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;                  &lt;dbl&gt;\n1 ENSG00000089220 PEBP1  Irrel_kd_1             7289.\n2 ENSG00000096654 ZNF184 Irrel_kd_1              502.\n3 ENSG00000102317 RBM3   Irrel_kd_1             8550.\n4 ENSG00000104885 DOT1L  Irrel_kd_1             3680.\n5 ENSG00000112972 HMGCS1 Irrel_kd_1             9310.\n6 ENSG00000124762 CDKN1A Irrel_kd_1             1639.\n\n\nNow, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot():\n\n# Add metadata\ngathered_top20_sigOE &lt;- inner_join(mov10_meta, gathered_top20_sigOE)\n\nThe inner_join() will merge 2 data frames with respect to any column with the same column name in both data frames: in this case, the “samplename” column.\nNow that we have a data frame in a format that can be utilized by ggplot easily, let’s plot!\n\n# Plot using ggplot2\nggplot(gathered_top20_sigOE) +\n  geom_point(aes(x = symbol, y = normalized_counts, color = sampletype)) +\n  scale_y_log10() +\n  # Add title and plot tweaks\n  xlab(\"Genes\") +\n  ylab(\"log10 Normalized Counts\") +\n  ggtitle(\"Top 20 Significant DE Genes\") +\n  theme_bw() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  theme(plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html",
    "href": "lessons/08a_DGE_LRT_results.html",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html#learning-objectives",
    "href": "lessons/08a_DGE_LRT_results.html#learning-objectives",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nApply the Likelihood Ratio Test (LRT) for hypothesis testing\nCompare results generated from the LRT to results obtained using the Wald test\nIdentify shared expression profiles from the LRT significant gene list",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "href": "lessons/08a_DGE_LRT_results.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Exploring results from the Likelihood ratio test (LRT)",
    "text": "Exploring results from the Likelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test as an alternative when evaluating expression change across more than two levels. Genes that are identified as significant are those that are changing in expression in any direction across the different factor levels.\nGenerally, this test will result in a larger number of genes than the individual pairwise comparisons. While the LRT is a test of significance for differences of any level(s) of the factor, one should not expect it to be exactly equal to the union of sets of genes using Wald tests (although we do expect a high degree of overlap).",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html#the-results-table",
    "href": "lessons/08a_DGE_LRT_results.html#the-results-table",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "The results() table",
    "text": "The results() table\nTo extract the results from our dds_lrt object we can use the same results() function we had used with the Wald test. There is no need for contrasts since we are not making a pairwise comparison.\n\n\n\n\n\n\nNote\n\n\n\nIn an earlier lesson on hypothesis testing, we had you create the object dds_lrt. If you are having trouble finding the object, please run the code:\n\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\n\n\n\n\n# Extract results for LRT\nres_LRT &lt;- results(dds_lrt)\n\nLet’s take a look at the results table:\n\n# View results for LRT\nres_LRT  \n\nlog2 fold change (MLE): sampletype MOV10 overexpression vs control \nLRT p-value: '~ sampletype' vs '~ 1' \nDataFrame with 57761 rows and 6 columns\n                  baseMean log2FoldChange     lfcSE      stat      pvalue\n                 &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;\nENSG00000000003  3525.8835      -0.438245 0.0774607  40.46117 1.63670e-09\nENSG00000000005    26.2489       0.029208 0.4411295   1.61898 4.45084e-01\nENSG00000000419  1478.2512       0.383635 0.1137609  11.34102 3.44611e-03\nENSG00000000457   518.4220       0.228971 0.1023313  14.63134 6.65035e-04\nENSG00000000460  1159.7761      -0.269138 0.0814993  25.03939 3.65398e-06\n...                    ...            ...       ...       ...         ...\nENSG00000285889    1.82171       -4.68144 3.9266061   2.35649 0.307818323\nENSG00000285950    7.58089       -1.01978 1.0715583   1.21446 0.544857226\nENSG00000285976 4676.24904        0.19364 0.0656673  14.87805 0.000587859\nENSG00000285978    2.25697        4.13612 2.0706212   4.68720 0.095981569\nENSG00000285980    0.00000             NA        NA        NA          NA\n                       padj\n                  &lt;numeric&gt;\nENSG00000000003 3.14071e-08\nENSG00000000005 5.88670e-01\nENSG00000000419 1.22924e-02\nENSG00000000457 3.04551e-03\nENSG00000000460 3.23425e-05\n...                     ...\nENSG00000285889          NA\nENSG00000285950          NA\nENSG00000285976  0.00273904\nENSG00000285978          NA\nENSG00000285980          NA\n\n\nThe results table output looks similar to the Wald test results, with identical columns to what we observed previously.\n\nWhy are fold changes reported for an LRT test?\nFor analyses using the likelihood ratio test, the p-values are determined solely by the difference in deviance between the full and reduced model formula. A single log2 fold change is printed in the results table for consistency with other results table outputs, but is not associated with the actual test.\nColumns relevant to the LRT test:\n\nbaseMean: mean of normalized counts for all samples\nstat: the difference in deviance between the reduced model and the full model\npvalue: the stat value is compared to a chi-squared distribution to generate a pvalue\npadj: BH adjusted p-values\n\nAdditional columns:\n\nlog2FoldChange: log2 fold change\nlfcSE: standard error\n\n\n\n\n\n\n\nNote\n\n\n\nPrinted at the top of the the results table are the two sample groups used to generate the log2 fold change values that we observe in the results table. This can be controlled using the name argument; the value provided to name must be an element of resultsNames(dds).",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html#identifying-significant-genes",
    "href": "lessons/08a_DGE_LRT_results.html#identifying-significant-genes",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Identifying significant genes",
    "text": "Identifying significant genes\nWhen filtering significant genes from the LRT we threshold only the padj column. How many genes are significant at padj &lt; 0.05?\n\n# Create a tibble for LRT results\nres_LRT_tb &lt;- res_LRT %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset to return genes with padj &lt; 0.05\nsigLRT_genes &lt;- res_LRT_tb %&gt;% \n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Get number of significant genes\nnrow(sigLRT_genes)\n\n[1] 7315\n\n# Compare to numbers we had from Wald test\nnrow(sigOE) # overexpression vs control\n\n[1] 4774\n\nnrow(sigKD) # knockdown vs control\n\n[1] 2827\n\n\nThe number of significant genes observed from the LRT is quite high. This list includes genes that can be changing in any direction across the three factor levels (control, KO, overexpression). To reduce the number of significant genes, we can increase the stringency of our FDR threshold (padj.cutoff).\n\n\n\n\n\n\nExercise\n\n\n\n\nCompare the resulting gene list from the LRT test to the gene lists from the Wald test comparisons.\n\nHow many of the sigLRT_genes overlap with the significant genes in sigOE?\nHow many of the sigLRT_genes overlap with the significant genes in sigKD?",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08a_DGE_LRT_results.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "href": "lessons/08a_DGE_LRT_results.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Identifying clusters of genes with shared expression profiles",
    "text": "Identifying clusters of genes with shared expression profiles\nWe now have this list of ~7K significant genes that we know are changing in some way across the three different sample groups. What do we do next?\nA good next step is to identify groups of genes that share a pattern of expression change across the sample groups (levels). To do this we will be using a clustering tool called degPatterns from the ‘DEGreport’ package. The degPatterns tool uses a hierarchical clustering approach based on pair-wise correlations between genes, then cuts the hierarchical tree to generate groups of genes with similar expression profiles. The tool cuts the tree in a way to optimize the diversity of the clusters, such that the variability inter-cluster &gt; the variability intra-cluster.\nBefore we begin clustering, we will first subset our rlog transformed normalized counts to retain only the differentially expressed genes (padj &lt; 0.05). In our case, it may take some time to run the clustering on 7K genes, and so for class demonstration purposes we will subset to keep only the top 1000 genes sorted by p-adjusted value.\n\n\n\n\n\n\nWhere do I get rlog transformed counts?\n\n\n\nThis rlog transformation was applied in an earlier lesson when we performed QC analysis. If you do not see this in your environment, run the following code:\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\nrld_mat &lt;- assay(rld)\n\n\n\n\n# Subset results for faster cluster finding (for classroom demo purposes)\nclustering_sig_genes &lt;- sigLRT_genes %&gt;%\n  arrange(padj) %&gt;%\n  head(n=1000)\n\n# Obtain rlog values for those significant genes\ncluster_rlog &lt;- rld_mat[clustering_sig_genes$gene, ]\n\nThe rlog transformed counts for the significant genes are input to degPatterns along with a few additional arguments:\n\nmetadata: the metadata dataframe that corresponds to samples\ntime: character column name in metadata that will be used as variable that changes\ncol: character column name in metadata to separate samples\n\nOnce the clustering is finished running, you will get your command prompt back in the console and you should see a figure appear in your plot window. The genes have been clustered into four different groups. For each group of genes, we have a boxplot illustrating expression change across the different sample groups. A line graph is overlayed to illustrate the trend in expression change.\n\n# Use the `degPatterns` function from the 'DEGreport' package to show gene clusters across sample groups\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"sampletype\", col = NULL)\n\n\n\n\n\n\n\n\nSuppose we are interested in the genes which show a decreased expression in the knockdown samples and increase in the overexpression. According to the plot there are 275 genes that share this expression profile. To find out what these genes are, let’s explore the output. What type of data structure is the clusters output?\n\n# What type of data structure is the `clusters` output?\nclass(clusters)\n\n[1] \"list\"\n\n\nWe can see what objects are stored in the list by using names(clusters). There is a dataframe stored inside. This is the main result so let’s take a look at it. The first column contains the genes, and the second column contains the cluster number to which they belong.\n\n# Let's see what is stored in the `df` component\nhead(clusters$df)\n\n                          genes cluster\nENSG00000155363 ENSG00000155363       1\nENSG00000173110 ENSG00000173110       1\nENSG00000189060 ENSG00000189060       1\nENSG00000187621 ENSG00000187621       2\nENSG00000265972 ENSG00000265972       1\nENSG00000270882 ENSG00000270882       3\n\n\nSince we are interested in Group 1, we can filter the dataframe to keep only those genes:\n\n# Extract the Group 1 genes\ngroup1 &lt;- clusters$df %&gt;%\n  dplyr::filter(cluster == 1)\n\nAfter extracting a group of genes, we can use annotation packages to obtain additional information. We can also use these lists of genes as input to downstream functional analysis tools to obtain more biological insight and see whether the groups of genes share a specific function.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/08b_time_course_analyses.html",
    "href": "lessons/08b_time_course_analyses.html",
    "title": "Time course analysis with DESeq2",
    "section": "",
    "text": "Approximate time: 20 minutes",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/08b_time_course_analyses.html#learning-objectives",
    "href": "lessons/08b_time_course_analyses.html#learning-objectives",
    "title": "Time course analysis with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss time course analyses with DESeq2",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/08b_time_course_analyses.html#time-course-analyses-with-lrt",
    "href": "lessons/08b_time_course_analyses.html#time-course-analyses-with-lrt",
    "title": "Time course analysis with DESeq2",
    "section": "Time course analyses with LRT",
    "text": "Time course analyses with LRT\nDespite the popularity of static measurement of gene expression, time-course capturing of biological processes is essential to reflect their dynamic nature, particularly when patterns are complex and are not simply ascending or descending. When working with this type of data, the Likelihood Ratio Test (LRT) is especially helpful. We can use the LRT to explore whether there are any significant differences across a series of timepoints and further evaluate differences observed between sample classes.\nFor example, suppose we have an experiment looking at the effect of treatment over time on mice of two different genotypes. We could use a design formula for our ‘full model’ that would include the major sources of variation in our data: genotype, treatment, time, and our main condition of interest, which is the difference in the effect of treatment over time (treatment:time).\n\n\n\n\n\n\nWarning\n\n\n\nThis is just example code for our hypothetical experiment. You should not run this code.\n\n\n\n## DO NOT RUN THIS CODE\n\nfull_model &lt;- ~ genotype + treatment + time + treatment:time\n\nTo perform the LRT test, we also need to provide a reduced model, that is the full model without the treatment:time term:\n\n## DO NOT RUN THIS CODE\n\nreduced_model &lt;- ~ genotype + treatment + time\n\nThen, we could run the LRT by using the following code:\n\n## DO NOT RUN THIS CODE\n\ndds &lt;- DESeqDataSetFromMatrix(countData = raw_counts,\n                              colData = metadata,\n                              design = ~ genotype + treatment + time + treatment:time)\n\ndds_lrt_time &lt;- DESeq(dds, test=\"LRT\", reduced = ~ genotype + treatment + time)\n\nTo understand what kind of gene expression patterns will be identified as differentially expressed, we have a few examples below. In the plots below we have time on the x-axis and gene expression on the y-axis. In this dataset there are two samples for each time point, one having undergone some treatment (red) and the other without (blue).\nFor this figure, we are depicting the type of genes that will not be identified as differentially expressed. Here, we observe that GeneX is differentially expressed between the time points, however there is no difference in that expression pattern between the treatment groups.\n\n\n\nThe type of gene expression patterns we do expect the LRT to return are those that exhibit differences in the effect of treatment over time. In the example below, GeneX displays a different expression pattern over time for the two treatment groups.\n\n\n\nContinuing with our example dataset, after running the LRT we can determine the set of significant genes using a threshold of padj &lt; 0.05. The next step would be to sort those genes into groups based on shared expression patterns, and we could do this using degPatterns(). Here, you will notice that we make use of the col argument since we have two groups that we are comparing to one another.\n\n## DO NOT RUN THIS CODE\n\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"time\", col = \"treatment\")\n\nDepending on what type of shared expression profiles exist in your data, you can then extract the groups of genes associated with the patterns of interest and move on to functional analysis for each of the gene groups of interest.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html",
    "href": "lessons/genomic_annotation.html",
    "title": "Genomic annotations",
    "section": "",
    "text": "Approximate time: 30 minutes",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#learning-objectives",
    "href": "lessons/genomic_annotation.html#learning-objectives",
    "title": "Genomic annotations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDiscuss the available genomic annotation databases and the different types if information stored\nCompare and contrast the tools available for accessing genomic annotation databases\nApply various R packages for retrieval of genomic annotations",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#databases",
    "href": "lessons/genomic_annotation.html#databases",
    "title": "Genomic annotations",
    "section": "Databases",
    "text": "Databases\nWe retrieve information on the processes, pathways, etc. (for which a gene is involved in) from the necessary database where the information is stored. The database you choose will be dependent on what type of information you are trying to obtain. Examples of databases that are often queried include:\nGeneral databases\nOffer comprehensive information on genome features, feature coordinates, homology, variant information, phenotypes, protein domain/family information, associated biological processes/pathways, associated microRNAs, etc.:\n\nEnsembl (use Ensembl gene IDs)\nNCBI (use Entrez gene IDs)\nUCSC\nEMBL-EBI\n\nAnnotation-specific databases\nProvide annotations related to a specific topic:\n\nGene Ontology (GO): database of gene ontology biological processes, cellular components and molecular functions - based on Ensembl or Entrez gene IDs or official gene symbols\nKEGG: database of biological pathways - based on Entrez gene IDs\nMSigDB: database of gene sets\nReactome: database of biological pathways\nHuman Phenotype Ontology: database of genes associated with human disease\nCORUM: database of protein complexes for human, mouse, rat\n…\n\nThis is by no means an exhaustive list, there are many other databases available that are not listed here.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#genome-builds",
    "href": "lessons/genomic_annotation.html#genome-builds",
    "title": "Genomic annotations",
    "section": "Genome builds",
    "text": "Genome builds\nBefore you begin your search through any of these databases, you should know which build of the genome was used to generate your gene list and make sure you use the same build for the annotations during functional analysis. When a new genome build is acquired, the names and/or coordinate location of genomic features (gene, transcript, exon, etc.) may change. Therefore, the annotations regarding genome features (gene, transcript, exon, etc.) is genome build-specific and we need to make sure that our annotations are obtained from the appropriate resource.\nFor example, if we used the GRCh38 build of the human genome to quantify gene expression used for differential expression analysis, then we should use the same GRCh38 build of the genome to convert between gene IDs and to identify annotations for each of the genes.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#tools-for-accessing-databases",
    "href": "lessons/genomic_annotation.html#tools-for-accessing-databases",
    "title": "Genomic annotations",
    "section": "Tools for accessing databases",
    "text": "Tools for accessing databases\nWithin R, there are many popular packages used for gene/transcript-level annotation. These packages provide tools that take the list of genes you provide and retrieve information for each gene using one or more of the databases listed above.\n\nAnnotation tools: for accessing/querying annotations from a specific databases\n\n\n\nTool\nDescription\nPros\nCons\n\n\n\n\norg.Xx.eg.db\nQuery gene feature information for the organism of interest\ngene ID conversion, biotype and coordinate information\nonly latest genome build available\n\n\nEnsDb.Xx.vxx\nTranscript and gene-level information directly fetched from Ensembl API (similar to TxDb, but with filtering ability and versioned by Ensembl release)\neasy functions to extract features, direct filtering\nNot the most up-to-date annotations, more difficult to use than some packages\n\n\nTxDb.Xx.UCSC.hgxx.knownGene\nUCSC database for transcript and gene-level information or can create own TxDb from an SQLite database file using the GenomicFeatures package\nfeature information, easy functions to extract features\nonly available current and recent genome builds - can create your own, less up-to-date with annotations than Ensembl\n\n\nannotables\nGene-level feature information immediately available for the human and model organisms\nsuper quick and easy gene ID conversion, biotype and coordinate information\nstatic resource, not updated regularly\n\n\nbiomaRt\nAn R package version of the Ensembl BioMart online tool\nall Ensembl database information available, all organisms on Ensembl, wealth of information\n\n\n\n\n\n\nInterface tools: for accessing/querying annotations from multiple different annotation sources\n\nAnnotationDbi: queries the OrgDb, TxDb, Go.db, EnsDb, and BioMart annotations.\n\nAnnotationHub: queries large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nThese are both packages that can be used to create the tx2gene files we had you download at the beginning of this workshop.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#annotationdbi",
    "href": "lessons/genomic_annotation.html#annotationdbi",
    "title": "Genomic annotations",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\nWhile AnnotationDbi is a popular tool, we will not be walking through code to use this package. However, if you are interested in more detail, we have materials linked here with examples using our current dataset.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/genomic_annotation.html#annotationhub",
    "href": "lessons/genomic_annotation.html#annotationhub",
    "title": "Genomic annotations",
    "section": "AnnotationHub",
    "text": "AnnotationHub\nAnnotationHub is a wonderful resource for accessing genomic data or querying large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc. All of this information is stored and easily accessible by directly connecting to the database.\nTo get started with AnnotationHub, we first load the library and connect to the database:\n\n# Load libraries\nlibrary(AnnotationHub)\nlibrary(ensembldb)\n\n# Connect to AnnotationHub\nah &lt;- AnnotationHub()\n\n\n\n\n\n\n\nWhat is a cache?\n\n\n\nA cache is used in R to store data or a copy of the data so that future requests can be served faster without having to re-run a lengthy computation.\nThe AnnotationHub() command creates a client that manages a local cache of the database, helping with quick and reproducible access. When encountering question AnnotationHub does not exist, create directory?, you can answer either yes (create a permanent location to store cache) or no (create a temporary location to store cache). hubCache(ah) gets the file system location of the local AnnotationHub cache. hubUrl(ah) gets the URL for the online hub.\n\n\nTo see the types of information stored inside our database, we can just type the name of the object. Using the output, you can get an idea of the information that you can query within the AnnotationHub object:\n\n# Explore the AnnotationHub object\nah\n\nAnnotationHub with 72100 records\n# snapshotDate(): 2024-10-28\n# $dataprovider: Ensembl, BroadInstitute, UCSC, ftp://ftp.ncbi.nlm.nih.gov/g...\n# $species: Homo sapiens, Mus musculus, Drosophila melanogaster, Rattus norv...\n# $rdataclass: GRanges, TwoBitFile, BigWigFile, EnsDb, Rle, OrgDb, SQLiteFil...\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH5012\"]]' \n\n             title                                             \n  AH5012   | Chromosome Band                                   \n  AH5013   | STS Markers                                       \n  AH5014   | FISH Clones                                       \n  AH5015   | Recomb Rate                                       \n  AH5016   | ENCODE Pilot                                      \n  ...        ...                                               \n  AH119506 | Ensembl 113 EnsDb for Zonotrichia albicollis      \n  AH119507 | Ensembl 113 EnsDb for Zalophus californianus      \n  AH119508 | Ensembl 113 EnsDb for Zosterops lateralis melanops\n  AH119518 | MassBank CompDb for release 2024.06               \n  AH119519 | MassBank CompDb for release 2024.11               \n\n\nNotice the note on retrieving records with object[[ID]] - this will be how we can extract a single record from the AnnotationHub object.\nIf you would like to see more information about any of the classes of data, you can extract that information as well. For example, if you wanted to determine all species information available, you could explore that within the AnnotationHub object:\n\n# Explore all species information available\nunique(ah$species) %&gt;% head()\n\n[1] \"Homo sapiens\"         \"Vicugna pacos\"        \"Dasypus novemcinctus\"\n[4] \"Otolemur garnettii\"   \"Papio hamadryas\"      \"Papio anubis\"        \n\n\nIn addition to species information, there is also additional information about the type of Data Objects and the Data Providers:\n\n# Explore the types of Data Objects available\nunique(ah$rdataclass) %&gt;% head()\n\n[1] \"GRanges\"          \"data.frame\"       \"Inparanoid8Db\"    \"TwoBitFile\"      \n[5] \"ChainFile\"        \"SQLiteConnection\"\n\n# Explore the Data Providers\nunique(ah$dataprovider) %&gt;% head()\n\n[1] \"UCSC\"        \"Ensembl\"     \"RefNet\"      \"Inparanoid8\" \"NHLBI\"      \n[6] \"ChEA\"       \n\n\nNow that we know the types of information available from AnnotationHub, we can query it for the information we want using the query() function. Let’s say we would like to return the Ensembl EnsDb information for Human. To return the records available, we need to use the terms as they are output from the ah object to extract the desired data.\n\n# Query AnnotationHub for Human references\nhuman_ens &lt;- query(ah, c(\"Homo sapiens\", \"EnsDb\"))\n\n# See what annotations are available\nhuman_ens\n\nAnnotationHub with 28 records\n# snapshotDate(): 2024-10-28\n# $dataprovider: Ensembl\n# $species: Homo sapiens\n# $rdataclass: EnsDb\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH53211\"]]' \n\n             title                             \n  AH53211  | Ensembl 87 EnsDb for Homo Sapiens \n  AH53715  | Ensembl 88 EnsDb for Homo Sapiens \n  AH56681  | Ensembl 89 EnsDb for Homo Sapiens \n  AH57757  | Ensembl 90 EnsDb for Homo Sapiens \n  AH60773  | Ensembl 91 EnsDb for Homo Sapiens \n  ...        ...                               \n  AH109606 | Ensembl 109 EnsDb for Homo sapiens\n  AH113665 | Ensembl 110 EnsDb for Homo sapiens\n  AH116291 | Ensembl 111 EnsDb for Homo sapiens\n  AH116860 | Ensembl 112 EnsDb for Homo sapiens\n  AH119325 | Ensembl 113 EnsDb for Homo sapiens\n\n\nThe query retrieves all hits for the EnsDb objects, and you will see that they are listed by the release number. The most current release for GRCh38 is Ensembl 113 and AnnotationHub offers that as an option to use. However, if you look at options for older releases, for Homo sapiens it only go back as far as Ensembl 87. This is fine if you are using GRCh38; however, if you were using an older genome build like hg19/GRCh37, you would need to load the EnsDb package if available for that release or you might need to build your own with ensembldb.\nIn our case, we are looking for the latest Ensembl release so that the annotations are the most up-to-date. To extract this information from AnnotationHub, we can use the AnnotationHub ID to subset the object:\n\n# Extract annotations of interest\nhuman_ens &lt;- human_ens[[\"AH119325\"]]\n\nNow we can use ensembldb functions to extract the information at the gene, transcript, or exon levels. We are interested in the gene-level annotations, so we can extract that information as follows:\n\n# Extract gene-level information\ngenes(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n          gene_id   gene_name                       gene_biotype gene_seq_start\n1 ENSG00000290825    DDX11L16                             lncRNA          11121\n3 ENSG00000223972     DDX11L1 transcribed_unprocessed_pseudogene          12010\n4 ENSG00000310526      WASH7P                             lncRNA          14356\n5 ENSG00000227232      WASH7P transcribed_unprocessed_pseudogene          14696\n6 ENSG00000278267   MIR6859-1                              miRNA          17369\n7 ENSG00000243485 MIR1302-2HG                             lncRNA          28589\n  gene_seq_end seq_name seq_strand seq_coord_system\n1        24894        1          1       chromosome\n3        13670        1          1       chromosome\n4        30744        1         -1       chromosome\n5        24886        1         -1       chromosome\n6        17436        1         -1       chromosome\n7        31109        1          1       chromosome\n                                                                                      description\n1 DEAD/H-box helicase 11 like 16 (pseudogene) [Source:NCBI gene (formerly Entrezgene);Acc:727856]\n3                  DEAD/H-box helicase 11 like 1 (pseudogene) [Source:HGNC Symbol;Acc:HGNC:37102]\n4                           WASP family homolog 7, pseudogene [Source:HGNC Symbol;Acc:HGNC:38034]\n5                           WASP family homolog 7, pseudogene [Source:HGNC Symbol;Acc:HGNC:38034]\n6                                             microRNA 6859-1 [Source:HGNC Symbol;Acc:HGNC:50039]\n7                                         MIR1302-2 host gene [Source:HGNC Symbol;Acc:HGNC:52482]\n    gene_id_version canonical_transcript      symbol     entrezid\n1 ENSG00000290825.2      ENST00000832823    DDX11L16 727856, ....\n3 ENSG00000223972.6      ENST00000450305     DDX11L1           NA\n4 ENSG00000310526.1      ENST00000831140      WASH7P       653635\n5 ENSG00000227232.6      ENST00000488147      WASH7P           NA\n6 ENSG00000278267.1      ENST00000619216   MIR6859-1    102466751\n7 ENSG00000243485.6      ENST00000834618 MIR1302-2HG           NA\n\n\nBut note that it is just as easy to get the transcript- or exon-level information:\n\n# Extract transcript-level information\ntranscripts(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n            tx_id     tx_biotype tx_seq_start tx_seq_end tx_cds_seq_start\n1 ENST00000620701          snRNA            1        107               NA\n2 ENST00000634102 protein_coding            1      58864             5632\n3 ENST00000630811         lncRNA            1       7125               NA\n4 ENST00000622103          snRNA           12        118               NA\n5 ENST00000612589          snRNA           12        118               NA\n6 ENST00000610987          snRNA           12        118               NA\n  tx_cds_seq_end         gene_id tx_support_level     tx_id_version gc_content\n1             NA ENSG00000275782               NA ENST00000620701.1   42.99065\n2          57902 ENSG00000278550                1 ENST00000634102.1   59.15209\n3             NA ENSG00000280592                2 ENST00000630811.1   55.94758\n4             NA ENSG00000275021               NA ENST00000622103.1   42.99065\n5             NA ENSG00000275168               NA ENST00000612589.1   42.99065\n6             NA ENSG00000276552               NA ENST00000610987.1   42.99065\n  tx_external_name tx_is_canonical         tx_name\n1        U6.55-201               1 ENST00000620701\n2      SLC43A2-224               0 ENST00000634102\n3    LINC01624-216               1 ENST00000630811\n4        U6.47-201               1 ENST00000622103\n5        U6.49-201               1 ENST00000612589\n6        U6.61-201               1 ENST00000610987\n\n# Extract exon-level information\nexons(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n          exon_id exon_seq_start exon_seq_end\n1 ENSE00003754250              1          107\n2 ENSE00003766135              1         2668\n3 ENSE00003783572              1         5793\n4 ENSE00003716605             12          118\n5 ENSE00003723881             12          118\n6 ENSE00003725167             12          118\n\n\nTo obtain an annotation data frame using AnnotationHub, we’ll use the genes() function, but only keep selected columns and filter out rows to keep those corresponding to our gene identifiers in our results file:\n\n# Create a gene-level dataframe \nannotations_ahb &lt;- genes(human_ens, return.type = \"data.frame\") %&gt;%\n  # Choose which columns to keep\n  dplyr::select(gene_id, gene_name, entrezid, gene_biotype) %&gt;%\n  # Choose which rows to keep (only genes that are in our overexpression results)\n  dplyr::filter(gene_id %in% res_tableOE_tb$gene)\n\nThis dataframe looks like it should be fine as it is, but we look a little closer we will notice that the column containing Entrez identifiers is a list, and in fact there are many Ensembl identifiers that map to more than one Entrez identifier!\n\n# Wait a second, we don't have one-to-one mappings!\nclass(annotations_ahb$entrezid)\n\n[1] \"list\"\n\nwhich(map(annotations_ahb$entrezid, length) &gt; 1) %&gt;% head()\n\nENSG00000186092 ENSG00000239149 ENSG00000229571 ENSG00000206652 ENSG00000158747 \n              9             407             432             529             604 \nENSG00000235200 \n           1835 \n\n\nSo what do we do here? And why do we have this problem? An answer from the Ensembl Help Desk is that this occurs when we cannot choose a perfect match; i.e., when we have two good matches, but one does not appear to match with a better percentage than the other. In that case, we assign both matches. What we will do is choose to keep the first identifier for these multiple mapping cases.\n\n# Only keep the first identifier in each list\nannotations_ahb$entrezid &lt;- map(annotations_ahb$entrezid, 1) %&gt;% unlist()\n\n\n\n\n\n\n\nNote\n\n\n\nNot all databases handle multiple mappings in the same way. For example, if we used the OrgDb instead of the EnsDb:\n\n# Pull annotations from OrgDb\nhuman_orgdb &lt;- query(ah, c(\"org.Hs.eg.db.sqlite\"))\nhuman_orgdb &lt;- human_orgdb[[\"AH116710\"]]\nannotations_orgdb &lt;- AnnotationDbi::select(human_orgdb, res_tableOE_tb$gene, c(\"SYMBOL\", \"GENENAME\", \"ENTREZID\"), \"ENSEMBL\")\n\nWe would find that multiple mapping entries would be automatically reduced to one-to-one. We would also find that more than half of the input genes do not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. Since our data is based on Ensembl mappings, using the OrgDb would result in a loss of information.\n\n\nLet’s take a look and see how many of our Ensembl identifiers have an associated gene symbol, and how many of them are unique:\n\n# Total Ensembl IDs with associated gene symbols\nwhich(!is.na(annotations_ahb$gene_name)) %&gt;% length()\n\n[1] 56427\n\n# Duplicated gene symbols\nwhich(duplicated(annotations_ahb$gene_name)) %&gt;% length()\n\n[1] 15814\n\n\nLet’s identify the non-duplicated genes and only keep the ones that are not duplicated:\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_ahb$gene_name) == FALSE)\n\n# How many rows does annotations_ahb have?\nannotations_ahb %&gt;% nrow()\n\n[1] 56427\n\n# Return only the non-duplicated genes using indices\nannotations_ahb &lt;- annotations_ahb[non_duplicates_idx, ]\n\n# How many rows are we left with after removing?\nannotations_ahb %&gt;% nrow()\n\n[1] 40613\n\n\nFinally, it would be good to know what proportion of the Ensembl identifiers map to an Entrez identifier:\n\n# Determine how many of the Entrez column entries are NA\nwhich(is.na(annotations_ahb$entrezid)) %&gt;% length()\n\n[1] 15969\n\n\nThat’s almost half of our genes! If we plan on using Entrez ID results for downstream analysis, we should definitely keep this in mind. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The discrepancy (which we can expect to observe) between databases is due to the fact that each implements its own different computational approaches for generating the gene builds.\n\nUsing AnnotationHub to create our tx2gene file\nTo create our tx2gene file, we would need to use a combination of the methods above and merge two dataframes together. For example:\n\n## DO NOT RUN THIS CODE\n\n# Create a transcript dataframe\ntxdb &lt;- transcripts(human_ens, return.type = \"data.frame\") %&gt;%\n  dplyr::select(tx_id, gene_id)\ntxdb &lt;- txdb[grep(\"ENST\", txdb$tx_id),]\n\n# Create a gene-level dataframe\ngenedb &lt;- genes(human_ens, return.type = \"data.frame\")  %&gt;%\n  dplyr::select(gene_id, gene_name)\n\n# Merge the two dataframes together\nannotations &lt;- inner_join(txdb, genedb)\n\nIn this lesson our focus has been using annotation packages to extract information mainly just for gene ID conversion for the different tools that we use downstream. Many of the annotation packages we have presented have much more information than what we need for functional analysis, and we have only just scratched the surface here. It’s good to know the capabilities of the tools we use, so we encourage you to spend some time exploring these packages to become more familiar with them.\n\n\n\n\n\n\nNote\n\n\n\nThe annotables package is a super easy annotation package to use. It is not updated frequently, so it’s not great for getting the most up-to-date information for the current builds and does not have information for other organisms than human and mouse, but is a quick way to get annotation information.\n\n# Install package\nBiocManager::install(\"annotables\")\n\n# Load library\nlibrary(annotables)\n\n# Access previous build of annotations\ngrch38",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/AnnotationDbi_lesson.html",
    "href": "lessons/AnnotationDbi_lesson.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/AnnotationDbi_lesson.html#annotationdbi",
    "href": "lessons/AnnotationDbi_lesson.html#annotationdbi",
    "title": "",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\n\norg.Hs.eg.db\nThere are a plethora of organism-specific orgDb packages, such as org.Hs.eg.db for human and org.Mm.eg.db for mouse, and a list of organism databases can be found here. These databases are best for converting gene IDs or obtaining GO information for current genome builds, but not for older genome builds. These packages provide the current builds corresponding to the release date of the package, and update every 6 months. If a package is not available for your organism of interest, you can create your own using AnnotationHub.\n\n# Load libraries\nlibrary(org.Hs.eg.db)\nlibrary(AnnotationDbi)\n\n# Check object metadata\norg.Hs.eg.db\n\nOrgDb object:\n| DBSCHEMAVERSION: 2.1\n| Db type: OrgDb\n| Supporting package: AnnotationDbi\n| DBSCHEMA: HUMAN_DB\n| ORGANISM: Homo sapiens\n| SPECIES: Human\n| EGSOURCEDATE: 2024-Sep20\n| EGSOURCENAME: Entrez Gene\n| EGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA\n| CENTRALID: EG\n| TAXID: 9606\n| GOSOURCENAME: \n| GOSOURCEURL: \n| GOSOURCEDATE: \n| GOEGSOURCEDATE: 2024-Sep20\n| GOEGSOURCENAME: Entrez Gene\n| GOEGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA\n| KEGGSOURCENAME: KEGG GENOME\n| KEGGSOURCEURL: ftp://ftp.genome.jp/pub/kegg/genomes\n| KEGGSOURCEDATE: 2011-Mar15\n| GPSOURCENAME: UCSC Genome Bioinformatics (Homo sapiens)\n| GPSOURCEURL: ftp://hgdownload.cse.ucsc.edu/goldenPath/hg38/database\n| GPSOURCEDATE: 2024-Sep22\n| ENSOURCEDATE: 2024-May14\n| ENSOURCENAME: Ensembl\n| ENSOURCEURL: ftp://ftp.ensembl.org/pub/current_fasta\n| UPSOURCENAME: Uniprot\n| UPSOURCEURL: http://www.UniProt.org/\n| UPSOURCEDATE: Mon Sep 23 15:46:45 2024\n\n\nWe can see the metadata for the database by just typing the name of the database, including the species, last updates for the different source information, and the source urls. Note the KEGG data from this database was last updated in 2011, so may not be the best site for KEGG pathway information.\nWe can easily extract information from this database using AnnotationDbi with the methods: columns, keys, keytypes, and select. For example, we will use our org.Hs.eg.db database to acquire information, but know that the same methods work for the TxDb, Go.db, EnsDb, and BioMart annotations.\n\n# Return the Ensembl IDs for a set of genes\nannotations_orgDb &lt;- AnnotationDbi::select(\n  org.Hs.eg.db, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENENAME\"), # information to retrieve for given data\n  keytype = \"ENSEMBL\") # type of data given in 'keys' argument\n\nWe started from at about 57K genes in our results table, and the dimensions of our resulting annotation data frame also look quite similar. Let’s take a peek to see if we actually returned annotations for each individual Ensembl gene ID that went in to the query:\n\n# How many Ensembl IDs have NOT been linked to gene names (symbols)?\nlength(which(is.na(annotations_orgDb$SYMBOL)))\n\n[1] 22125\n\n\nLooks like about half of the input genes did not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The difference is due to the fact that each database implements different computational approaches for generating the gene builds. Let’s get rid of those NA entries:\n\n# Determine the indices for the non-NA genes\nnon_na_idx &lt;- which(is.na(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the genes with annotations using indices\nannotations_orgDb &lt;- annotations_orgDb[non_na_idx, ]\n\nYou may have also noted the warning returned: ‘select()’ returned 1:many mapping between keys and columns. This is always going to happen with converting between different gene IDs (i.e., one geneID can map to more than one identifier in another databse) . Unless we would like to keep multiple mappings for a single gene, then we probably want to de-duplicate our data before using it.\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_orgDb &lt;- annotations_orgDb[non_duplicates_idx, ]\n\n\n\nEnsDb.Hsapiens.v86\nTo generate the Ensembl annotations, the EnsDb database can also be easily queried using AnnotationDbi. You will need to decide the release of Ensembl you would like to query. We know that our data is for GRCh38, and the most current EnsDb release for GRCh38 in Bioconductor is release 86, so we can install this database. All Ensembl releases are listed here. NOTE: this is not the most current release of GRCh38 in the Ensembl database, but it’s as current as we can obtain through AnnotationDbi.\nSince we are using AnnotationDbi to query the database, we can use the same functions that we used previously:\n\n# Install the library\n# BiocManager::install(\"EnsDb.Hsapiens.v86\")\n\n# Load the library\nlibrary(EnsDb.Hsapiens.v86)\n\n# Check object metadata\nEnsDb.Hsapiens.v86\n\nEnsDb for Ensembl:\n|Backend: SQLite\n|Db type: EnsDb\n|Type of Gene ID: Ensembl Gene ID\n|Supporting package: ensembldb\n|Db created by: ensembldb package from Bioconductor\n|script_version: 0.3.0\n|Creation time: Thu May 18 16:32:27 2017\n|ensembl_version: 86\n|ensembl_host: localhost\n|Organism: homo_sapiens\n|taxonomy_id: 9606\n|genome_build: GRCh38\n|DBSCHEMAVERSION: 2.0\n| No. of genes: 63970.\n| No. of transcripts: 216741.\n|Protein data available.\n\n# Explore the fields that can be used as keys\nkeytypes(EnsDb.Hsapiens.v86)\n\n [1] \"ENTREZID\"            \"EXONID\"              \"GENEBIOTYPE\"        \n [4] \"GENEID\"              \"GENENAME\"            \"PROTDOMID\"          \n [7] \"PROTEINDOMAINID\"     \"PROTEINDOMAINSOURCE\" \"PROTEINID\"          \n[10] \"SEQNAME\"             \"SEQSTRAND\"           \"SYMBOL\"             \n[13] \"TXBIOTYPE\"           \"TXID\"                \"TXNAME\"             \n[16] \"UNIPROTID\"          \n\n\nNow we can return all gene IDs for our gene list:\n\n# Return the Ensembl IDs for a set of genes\nannotations_edb &lt;- AnnotationDbi::select(\n  EnsDb.Hsapiens.v86, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENEBIOTYPE\"), # information to retrieve for given data\n  keytype = \"GENEID\") # type of data given in 'keys' argument\n\nWe can check for NA entries, and find that there are none:\n\nlength(which(is.na(annotations_edb$SYMBOL)))\n\n[1] 0\n\n\nThen we can again deduplicate, to remove the gene symbols which appear more than once:\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_edb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_edb &lt;- annotations_edb[non_duplicates_idx, ]\n\n\n\n\n\n\n\nNote\n\n\n\nIn this case we used the same build but a slightly older release, and we found little discrepancy. If your analysis was conducted using an older genome build (e.g., hg19), but used a newer build for annotation, some genes may be found to be not annotated (NA). Some of the genes have changed names in between versions (due to updates and patches), so may not be present in the newer version of the database."
  },
  {
    "objectID": "lessons/10_FA_over-representation_analysis.html",
    "href": "lessons/10_FA_over-representation_analysis.html",
    "title": "Functional Analysis for RNA-seq",
    "section": "",
    "text": "Approximate time: 120 minutes\nLearning Objectives:",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/10_FA_over-representation_analysis.html#over-representation-analysis",
    "href": "lessons/10_FA_over-representation_analysis.html#over-representation-analysis",
    "title": "Functional Analysis for RNA-seq",
    "section": "Over-representation analysis",
    "text": "Over-representation analysis\nThere are a plethora of functional enrichment tools that perform some type of “over-representation” analysis by querying databases containing information about gene function and interactions.\nThese databases typically categorize genes into groups (gene sets) based on shared function, involvement in a pathway, presence in a specific cellular location, or other categorizations, e.g. functional pathways, etc. Essentially, known genes are binned into categories that have been consistently named (controlled vocabulary) based on how the gene has been annotated functionally. These categories are independent of any organism; however, each organism has distinct categorizations available.\nTo determine whether any categories are over-represented, you can determine the probability of having the observed proportion of genes associated with a specific category in your gene list based on the proportion of genes associated with the same category in the background set (gene categorizations for the appropriate organism).\n\n\n\n\n\n\nThe statistical test that will determine whether something is actually over-represented is the Hypergeometric test.\n\nHypergeometric testing\nUsing the example of the first functional category above, hypergeometric distribution is a probability distribution that describes the probability of 25 genes (k) being associated with “Functional category 1”, for all genes in our gene list (n=1000), from a population of all of the genes in entire genome (N=13,000) which contains 35 genes (K) associated with “Functional category 1” [2].\nThe calculation of probability of k successes follows the formula:\n\n\n\nThis test will result in an adjusted p-value (after multiple test correction) for each category tested.\n\n\nGene Ontology project\nOne of the most widely-used categorizations is the Gene Ontology (GO) established by the Gene Ontology project.\n“The Gene Ontology project is a collaborative effort to address the need for consistent descriptions of gene products across databases” [3]. The Gene Ontology Consortium maintains the GO terms, and these GO terms are incorporated into gene annotations in many of the popular repositories for animal, plant, and microbial genomes.\nTools that investigate enrichment of biological functions or interactions often use the Gene Ontology (GO) categorizations – i.e., the GO terms – to determine whether any have significantly modified representation in a given list of genes. Therefore, to best use and interpret the results from these functional analysis tools, it is helpful to have a good understanding of the GO terms themselves and their organization.\n\nGO Ontologies\nTo describe the roles of genes and gene products, GO terms are organized into three independent controlled vocabularies (ontologies) in a species-independent manner:\n\nBiological process: refers to the biological role involving the gene or gene product, and could include “transcription”, “signal transduction”, and “apoptosis”. A biological process generally involves a chemical or physical change of the starting material or input.\nMolecular function: represents the biochemical activity of the gene product. Such activities could include “ligand”, “GTPase”, and “transporter”.\nCellular component: refers to the location in the cell of the gene product. Cellular components could include “nucleus”, “lysosome”, and “plasma membrane”.\n\nEach GO term has a term name (e.g., DNA repair) and a unique term accession number (GO:0005125), and a single gene product can be associated with many GO terms, since a single gene product “may function in several processes, contain domains that carry out diverse molecular functions, and participate in multiple alternative interactions with other proteins, organelles or locations in the cell” [4].\n\n\nGO term hierarchy\nSome gene products are well-researched, with vast quantities of data available regarding their biological processes and functions. However, other gene products have very little data available about their roles in the cell.\nFor example, the protein “p53” would contain a wealth of information on its roles in the cell, whereas another protein might only be known as a “membrane-bound protein” with no other information available.\nThe GO ontologies were developed to describe and query biological knowledge with differing levels of information available. To do this, GO ontologies are loosely hierarchical, ranging from general ‘parent’ terms to more specific ‘child’ terms. The GO ontologies are “loosely” hierarchical since ‘child’ terms can have multiple ‘parent’ terms.\nSome genes with less information may only be associated with general ‘parent’ terms or no terms at all, while other genes with a lot of information be associated with many terms.\n\n\n\nNature Reviews Cancer 7, 23-34 (January 2007)\n\n\nTips for working with GO terms",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/10_FA_over-representation_analysis.html#clusterprofiler",
    "href": "lessons/10_FA_over-representation_analysis.html#clusterprofiler",
    "title": "Functional Analysis for RNA-seq",
    "section": "clusterProfiler",
    "text": "clusterProfiler\nWe will be using clusterProfiler to perform over-representation analysis on GO terms associated with our list of significant genes. The tool takes as input a significant gene list and a background gene list and performs statistical enrichment analysis using hypergeometric testing. The basic arguments allow the user to select the appropriate organism and GO ontology (BP, CC, MF) to test.\n\nRunning clusterProfiler\nTo run clusterProfiler GO over-representation analysis, we will change our gene names into Ensembl IDs, since the tool works a bit easier with the Ensembl IDs.\nFirst load the following libraries:\n\n# Load libraries\nlibrary(DOSE)\nlibrary(pathview)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\n\nFor the different steps in the functional analysis, we require Ensembl and Entrez IDs. We will use the gene annotations that we generated previously to merge with our differential expression results. Before we do that, let’s subset our results tibble to only have the genes that were tested, i.e., genes whose adjusted p-values are not equal to NA.\n\n# Untested genes have padj = NA, so let's keep genes with padj != NA\nres_tableOE_tb_noNAs &lt;- filter(res_tableOE_tb, padj != \"NA\" )\n\n# Merge the AnnotationHub dataframe with the results \nres_ids &lt;- left_join(res_tableOE_tb_noNAs, annotations_ahb, by=c(\"gene\"=\"gene_id\")) \n\n\n\n\n\n\n\nNote\n\n\n\nIf you were unable to generate the annotations_ahb object, you can download the annotations to your data folder by right-clicking here and selecting “Save link as…”\nTo read in the object, you can run the following code: annotations_ahb &lt;- read.csv(\"annotations_ahb.csv\")\n\n\nTo perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n\n# Create background dataset for hypergeometric testing using all tested genes for significance in the results\nallOE_genes &lt;- as.character(res_ids$gene)\n\n# Extract significant results\nsigOE &lt;- dplyr::filter(res_ids, padj &lt; 0.05)\nsigOE_genes &lt;- as.character(sigOE$gene)\n\nNow we can perform the GO enrichment analysis and save the results:\n\n\n\n\n\n\nNotes for running clusterProfiler\n\n\n\nThe different organisms with annotation databases available to use with for the OrgDb argument can be found here.\nAlso, the keyType argument may be coded as keytype in different versions of clusterProfiler.\nFinally, the ont argument can accept either “BP” (Biological Process), “MF” (Molecular Function), and “CC” (Cellular Component) subontologies, or “ALL” for all three.\n\n\n\n# Run GO enrichment analysis \nego &lt;- enrichGO(gene = sigOE_genes, \n                universe = allOE_genes,\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Hs.eg.db, \n                ont = \"BP\", \n                pAdjustMethod = \"BH\", \n                qvalueCutoff = 0.05, \n                readable = TRUE)\n\n# Output results from GO analysis to a table\ncluster_summary &lt;- data.frame(ego)\n\n# View results\ncluster_summary %&gt;% head()\n\n                   ID                               Description GeneRatio\nGO:0080135 GO:0080135 regulation of cellular response to stress  205/3925\nGO:0098813 GO:0098813            nuclear chromosome segregation  126/3925\nGO:0006401 GO:0006401                     RNA catabolic process  121/3925\nGO:0006417 GO:0006417                 regulation of translation  145/3925\nGO:0000819 GO:0000819              sister chromatid segregation  101/3925\nGO:0043484 GO:0043484                regulation of RNA splicing   81/3925\n             BgRatio RichFactor FoldEnrichment   zScore       pvalue\nGO:0080135 492/13021  0.4166667       1.382272 5.678017 2.149930e-08\nGO:0098813 289/13021  0.4359862       1.446363 5.040680 6.968059e-07\nGO:0006401 280/13021  0.4321429       1.433613 4.818146 1.986663e-06\nGO:0006417 347/13021  0.4178674       1.386255 4.790517 2.064600e-06\nGO:0000819 227/13021  0.4449339       1.476047 4.752911 2.915791e-06\nGO:0043484 174/13021  0.4655172       1.544331 4.748288 3.351963e-06\n               p.adjust       qvalue\nGO:0080135 0.0001210626 0.0001137879\nGO:0098813 0.0019618569 0.0018439684\nGO:0006401 0.0029064405 0.0027317916\nGO:0006417 0.0029064405 0.0027317916\nGO:0000819 0.0030963784 0.0029103161\nGO:0043484 0.0030963784 0.0029103161\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 geneID\nGO:0080135 RAD52/BAD/CREBBP/MAPK8IP2/ERCC1/UFL1/SNAI2/FAS/CD44/BAK1/GRN/PARP3/AIFM2/HSPA5/ARID1B/HERPUD1/PIK3CB/FAM168A/PUM2/USP13/TMEM161A/SMARCD1/ATXN3/SMARCE1/ACTB/SIRT6/ZCWPW1/ZMPSTE24/TMED2/PPP1R15A/BAX/ATXN7L3/FUS/SIRT1/BCL7C/SMARCB1/MAPK1/TFIP11/XBP1/TELO2/YY1/CSNK2A1/ACTR5/USP14/PSMD10/MID1/SLC25A14/STUB1/RIPK2/EYA1/NBN/SGTA/PIAS4/YJU2/DNAJC2/CAV1/DNAJB6/NOD1/ZNHIT1/BCL7B/CREB3/CXCL12/C1QBP/DDX5/KAT2A/TMEM33/FBXW7/NSD2/CHORDC1/BCL7A/FOXM1/SPRING1/TIMELESS/LPCAT3/EYA4/OGG1/EIF4G1/INO80D/EFHD1/PRRX1/PARK7/ARHGEF2/PRDX1/RPA2/MAPKAP1/FKBP1B/SLF2/CLU/SHLD2/TWIST1/CYREN/MORF4L2/USP22/SOX4/EEF1E1/PRMT1/AUNIP/SMARCA4/INO80/TAF4/TRIM28/DNAJB1/SERINC3/DPF2/RNFT2/MDM2/TAF5L/ACTL6A/KLF4/MYC/KIAA0319/IER3/ACTR2/PDX1/TMBIM6/TMX1/IGF1R/MEAK7/PMAIP1/BRD4/APP/PTPRF/CERS2/DUSP10/PARP1/MANF/SKP2/EGFR/ATM/SLC7A11/PLA2R1/CEBPG/DDAH1/USP25/CREB3L1/PPP1R15B/CCAR2/CCDC117/UBQLN4/ZNF385A/RPL26/TAF6L/IER5/PPP4R2/MEAF6/PBRM1/CREBRF/BRD7/PLK1/OTUB1/NUDT16L1/DNAJC7/SEMA4C/USP47/NFRKB/NPAS2/TRIAP1/TADA3/BCL2L1/QARS1/EIF2AK3/KAT5/TADA2B/SMARCC1/KLHL15/RMI2/RUVBL1/NUPR1/ATAD5/SGF29/UBE2N/DMAP1/ERN1/GRINA/TAF7/SETD2/PTTG1IP/KMT5A/HSF1/MUC1/BRCC3/BCAP31/INSIG1/TAF9B/MCRS1/H2AX/NBR1/LRRK2/SF3B3/HMGB1/PPIA/TRRAP/PTPN1/SVIP/SPRED2/MTOR/OPA1/HSPA1A/BAG6/SPIRE2/DHFR/RTEL1/MARCHF6-DT/FIGNL2/PPP4R3B\nGO:0098813                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             POLDIP2/CDC27/BAZ1B/TACC3/NCAPH2/CENPQ/ARID1B/MSH4/NDC1/SMARCD1/RHOA/SIRT2/CDC42/TRIP13/SMC1A/SMARCE1/ACTB/MLH1/SPAG5/ZCWPW1/KIF22/NDC80/PIBF1/SEH1L/ZW10/TPX2/BIRC5/NUDC/KIF4A/CDC6/SIRT1/BCL7C/SMARCB1/CCNB1IP1/MYBL2/KIF3B/MAPRE1/CHMP4B/FAM83D/CEP192/CENPI/RAB11A/ARHGEF10/AKAP8/CCNE1/PPP2R1A/BCL7B/BCCIP/SMC3/KPNB1/RANGRF/BCL7A/CHMP3/CDC20/NSL1/STAG1/MLH3/TEX14/NCAPH/ZWINT/XRCC3/SMARCA4/INO80/CHMP1A/RAN/DPF2/CCNB1/PSRC1/CDCA8/ESPL1/USP44/ACTL6A/C9orf78/KIF23/ACTR2/KATNB1/KIF2C/CENPC/CDCA5/NCAPG2/ATM/INCENP/SPC25/SYCP2L/HNRNPU/SKA1/TTN/CCNB2/PMF1/SPC24/PBRM1/MAP9/DCAF13/GEM/BRD7/PLK1/GOLGA2/DDB1/KAT5/SMARCC1/ZWILCH/UBE2C/CCNE2/RMI2/CHMP6/AURKB/RRS1/RCC2/RCC1/MAPK15/SKA2/KMT5A/KNTC1/DRG1/KIF18B/SYCP2/ANAPC7/CHAMP1/EHMT2/HSPA1B/HSPA1A/MSH5/BAG6/KIFC1/LSM14A/UHRF1\nGO:0006401                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          CSDE1/RNH1/VIM/RNASET2/ZCCHC8/NSUN2/METTL1/EDC4/MRTO4/THRAP3/PUM2/YBX1/ELAVL1/ROCK1/SMG6/PABPC1/IGF2BP2/MLH1/TRAF5/TUT7/CNOT3/KHSRP/XRN2/FUS/ALKBH5/AGO1/CIRBP/DICER1/APEX1/E2F1/ELOB/POP1/RNASEH2A/PIAS4/DDX49/SMG9/LSM5/EXOSC3/LARP4B/CASC3/DDX5/ZPR1/RBM24/XRN1/SMG7/PPP1R8/SLIRP/NRDE2/TRIR/ZFP36/FXR2/LSM7/LSM4/ZC3H4/DKC1/GRSF1/RBM38/DHX34/CAPRIN1/TTC5/NCBP1/PNPT1/DNA2/SSB/LARP1B/SKIC8/TOB1/NT5C3B/AKT1/CNOT9/PNRC1/ATM/LSM14B/TIRAP/CARHSP1/HNRNPU/PRKCA/MOV10/LARP1/CNOT11/ZC3H18/IGF2BP1/BTG2/RBM47/ZC3H12A/WDR82/TENT2/FASTK/PATL1/DIS3L/POLR2G/FEN1/GDNF/EXOSC10/RNASEH1/PAIP1/RNASEH2C/ANGEL2/PDE12/HNRNPA0/ERN1/ZHX2/SAMD4B/RBM10/RBM33/ZFP36L1/SECISBP2/NANOS1/CNOT7/NBDY/DXO/HSPA1B/HSPA1A/LSM2/FASTKD5/XIST/NEAT1/OIP5-AS1/MALAT1/RBM8A/SYNCRIP\nGO:0006417                                                                                                                                                                                                                                                                                                                                                                                           CSDE1/PRKCH/SARS1/PUM2/EIF4B/YBX1/ELAVL1/PKM/ELP1/PABPC1/TCOF1/IGF2BP2/EIF4G3/MKNK1/DDX1/JMJD4/BZW1/PPP1R15A/CNOT3/MAPKAPK5/GCN1/AARS1/ALKBH5/AGO1/CIRBP/POLDIP3/EIF5/PCIF1/MTG2/CSNK2A1/CELF4/RBM3/EEF2K/AKT2/MTPN/HSPB1/EIF3B/EIF4H/LARP4B/CASC3/RPS6KB1/C1QBP/EIF4G2/DDX6/CAPRIN2/RBM24/XRN1/EIF1B/EIF4G1/NCL/IGFBP5/EIF2B2/PAIP2/SERP1/KHDRBS1/ACO1/TSFM/METTL8/PAIP2B/SOX4/STK35/PRMT1/ZFP36/FXR2/ILF3/SESN2/SHFL/UNK/EIF5A/ELP2/NAT10/CAPRIN1/BZW2/TACO1/DNAJC1/NCBP1/CPEB2/SSB/LARP1B/TARBP2/TOB1/APP/AKT1/CNOT9/PURB/OGT/EIF3H/INPP5E/EIF4EBP2/MTG1/LSM14B/GUF1/HNRNPU/MSI2/OTUD6B/LARP1/EIF4A2/RPUSD3/CNOT11/PPP1R15B/IGF2BP1/BTG2/ZNF385A/LARP4/RPL26/KBTBD8/ELP6/RPUSD4/NOLC1/TRUB2/ZNF598/POLR2G/ELP5/PA2G4/ENC1/EIF2AK3/PAIP1/PPP1CA/EIF1/PDIK1L/SLC35A4/SAMD4B/SHMT2/NGRN/KLHL25/COA3/EIF3C/RPS27L/ZFP36L1/SECISBP2/NANOS1/NHLRC3/DAPK1/CNOT7/MTOR/SELENOT/ATXN2/SARNP/IFRD2/DHFR/EIF5AL1/LSM14A/RBM8A/SYNCRIP/RCC1L\nGO:0000819                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 POLDIP2/CDC27/BAZ1B/TACC3/NCAPH2/ARID1B/SMARCD1/RHOA/TRIP13/SMC1A/SMARCE1/ACTB/SPAG5/KIF22/NDC80/PIBF1/SEH1L/ZW10/TPX2/BIRC5/NUDC/KIF4A/CDC6/SIRT1/BCL7C/SMARCB1/MYBL2/KIF3B/MAPRE1/CHMP4B/CEP192/CENPI/RAB11A/ARHGEF10/AKAP8/PPP2R1A/BCL7B/BCCIP/SMC3/KPNB1/RANGRF/BCL7A/CHMP3/CDC20/NSL1/STAG1/TEX14/NCAPH/ZWINT/XRCC3/SMARCA4/INO80/CHMP1A/RAN/DPF2/CCNB1/PSRC1/CDCA8/ESPL1/USP44/ACTL6A/KIF23/KATNB1/KIF2C/CENPC/CDCA5/NCAPG2/ATM/INCENP/SPC25/HNRNPU/SKA1/TTN/SPC24/PBRM1/MAP9/BRD7/PLK1/GOLGA2/KAT5/SMARCC1/ZWILCH/UBE2C/RMI2/CHMP6/AURKB/RRS1/RCC1/MAPK15/SKA2/KMT5A/KNTC1/DRG1/KIF18B/ANAPC7/CHAMP1/HSPA1B/HSPA1A/KIFC1/LSM14A/UHRF1\nGO:0043484                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     PTBP1/CLK1/CELF2/THRAP3/SFSWAP/U2AF2/DAZAP1/FAM50A/CLNS1A/MBNL3/RBM22/ATXN7L3/FUS/CIRBP/RBFOX2/RBM23/PRMT5/ACIN1/CELF4/PQBP1/RBM3/HNRNPL/SNRNP70/C1QBP/DDX5/KAT2A/ZPR1/HSPA8/PRPF19/NUP98/SRSF9/RBM24/NCL/WDR77/PRDX6/KHDRBS1/SMU1/SRSF6/USP22/AHNAK/RBM42/HNRNPH2/RBM39/GRSF1/RBM38/ARGLU1/HNRNPA1/TAF5L/NCBP1/TMBIM6/MBNL2/MBNL1/HNRNPU/RRP1B/TAF6L/ZNF326/RBM15/CCNL1/RBM47/FASTK/RBPMS2/SF1/HNRNPF/TADA3/EXOSC10/TADA2B/EIF1/SGF29/ERN1/ZBTB7A/PUF60/RBM10/RBM11/SF3B3/TRRAP/RPS26/AKAP17A/RBM20/HSPA1A/RBM15B/RBM8A\n           Count\nGO:0080135   205\nGO:0098813   126\nGO:0006401   121\nGO:0006417   145\nGO:0000819   101\nGO:0043484    81\n\n\n\n# Save results\nwrite.csv(cluster_summary, \"../results/clusterProfiler_Mov10oe.csv\")\n\n\n\n\n\n\n\nNote\n\n\n\nInstead of saving just the results summary from the ego object, it might also be beneficial to save the object itself. The save() function enables you to save it as a .rda file, e.g. save(ego, file=\"results/ego.rda\").\nThe complementary function to save() is the function load(), e.g. ego &lt;- load(file=\"results/ego.rda\").\nThis is a useful set of functions to know, since it enables one to preserve analyses at specific stages and reload them when needed. More information about these functions can be found here & here.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou can also perform GO enrichment analysis with only the up or down regulated genes in addition to performing it for the full list of significant genes. This can be useful to identify GO terms impacted in one direction and not the other. If very few genes are in any of these lists (&lt; 50, roughly) it may not be possible to get any significant GO terms.\n\n# Extract upregulated genes\nsigOE_up &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &gt; 0)\nsigOE_up_genes &lt;- as.character(sigOE_up$gene)\n\n## Extract downregulated genes\nsigOE_down &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &lt; 0)\nsigOE_down_genes &lt;- as.character(sigOE_down$gene)\n\nYou can then create ego_up & ego_down objects by running the enrichGO() function for gene = sigOE_up_genes or gene = sigOE_down_genes.\n\n\n\n\nVisualizing clusterProfiler results\nclusterProfiler has a variety of options for viewing the over-represented GO terms. We will explore the dotplot, enrichment plot, and the category netplot.\nThe dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 30 GO terms by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value.\n\n# Dotplot for the top 30 GO terms\ndotplot(ego, showCategory=30)\n\n\n\n\n\n\n\n\n\n# Save the figure: it has to be very large for the text labels to all fit!\nggsave(filename = \"results/plots_OE_ORA_dotplot.pdf\", width = 8, height = 20)\n\nThe next plot is the enrichment GO plot, which shows the relationship between the top 30 most significantly enriched GO terms (by padj), by grouping similar terms together. Before creating the plot, we will need to obtain the similarity between terms using the pairwise_termsim() function (instructions for emapplot). In the enrichment plot, the color represents the p-values relative to the other displayed terms (brighter red is more significant), and the size of the terms represents the number of genes that are significant from our list.\n\n# Add similarity matrix to the termsim slot of enrichment result\nego &lt;- enrichplot::pairwise_termsim(ego)\n\n# Enrichmap clusters the 30 most significant (by padj) GO terms to visualize relationships between terms\nemapplot(ego, showCategory = 30)\n\n\n\n\n\n\n\n\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_enrich.pdf\", width = 10, height = 10)\n\nFinally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the number of genes in the terms, with terms with more genes being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes.\n\n\n\n\n\n\nNote\n\n\n\nYou may need to install the ggnewscale package using install.packages(\"ggnewscale\") for the cnetplot() function to work.\n\n\n\n# To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector\nOE_foldchanges &lt;- sigOE$log2FoldChange\nnames(OE_foldchanges) &lt;- sigOE$gene\n\n# Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj)\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n\n\n\n\n\n\n\n# If some of the high fold changes are getting drowned out due to a large range, you could set a maximum fold change value\nOE_foldchanges &lt;- ifelse(OE_foldchanges &gt;  2,  2, OE_foldchanges)\nOE_foldchanges &lt;- ifelse(OE_foldchanges &lt; -2, -2, OE_foldchanges)\n\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n\n\n\n\n\n\n\n\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_net.pdf\", width = 10, height = 10)\n\nIf you are interested in significant processes that are not among the top five, you can subset your ego dataset to only display these processes:\n\n# Subsetting the ego results without overwriting original `ego` variable\nego2 &lt;- ego\nego2@result &lt;- ego@result[c(1,3,4,8,9),]\n\n# Plotting terms of interest\ncnetplot(ego2, \n         categorySize = \"pvalue\", \n         foldChange = OE_foldchanges, \n         showCategory = 5, \n         vertex.label.font = 6)",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html",
    "href": "lessons/11_FA_functional_class_scoring.html",
    "title": "Functional Analysis for RNA-seq",
    "section": "",
    "text": "Approximate time: 40 minutes\nLearning Objectives:",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html#functional-analysis-using-functional-class-scoring",
    "href": "lessons/11_FA_functional_class_scoring.html#functional-analysis-using-functional-class-scoring",
    "title": "Functional Analysis for RNA-seq",
    "section": "Functional analysis using functional class scoring",
    "text": "Functional analysis using functional class scoring\nIn addition to over-representation analysis, there are other types of analyses that can be equally important or informative for obtaining some biological insight from your results. The hypothesis behind functional class scoring (FCS) methods is that although large changes in individual genes can have significant effects on pathways (and will be detected via ORA methods), weaker but coordinated changes in sets of functionally related genes (i.e., pathways) can also have significant effects. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. This type of analysis can be particularly helpful if the differential expression analysis only outputs a small list of significant DE genes.",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "href": "lessons/11_FA_functional_class_scoring.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "title": "Functional Analysis for RNA-seq",
    "section": "Gene set enrichment analysis using clusterProfiler and Pathview",
    "text": "Gene set enrichment analysis using clusterProfiler and Pathview\nOne commonly used tool that is classified under Functional class scoring (FCS) is Gene Set Enrichment Analysis (GSEA). Gene set enrichment analysis utilizes the gene-level statistics or log2 fold changes for all genes to look to see whether gene sets for particular biological pathways are enriched among the large positive or negative fold changes.\n\n\n\nGene sets are pre-defined groups of genes that are functionally related. Commonly used gene sets include those derived from KEGG pathways, Gene Ontology terms, MSigDB, Reactome, or gene groups that share some other functional annotations, etc. [1].\n\nPreparation for GSEA\nThe clusterProfiler package offers several functions to perform GSEA using different genes sets, including but not limited to GO, KEGG, and MSigDb. We will use the KEGG gene sets in our examples below. The KEGG gene sets are defined using the Entrez identifiers, thus to perform the analysis we will need to acquire the corresponding Entrez IDs for our genes. We will also need to remove any genes that do not have an Entrez ID (NA values) and any duplicates (due to gene ID conversion) that may exist:\n\n# Remove any NA values (reduces the data by quite a bit)\nres_entrez &lt;- dplyr::filter(res_ids, entrezid != \"NA\")\n\n# Remove any Entrez duplicates\nres_entrez &lt;- res_entrez[which(duplicated(res_entrez$entrezid) == F), ]\n\nGSEA will use the log2 fold changes obtained from the differential expression analysis for every gene to perform the analysis. We will obtain a vector of fold changes for input to clusterProfiler, in addition to the associated Entrez IDs:\n\n# Extract the foldchanges\nfoldchanges &lt;- res_entrez$log2FoldChange\n\n# Name each fold change with the corresponding Entrez ID\nnames(foldchanges) &lt;- res_entrez$entrezid\n\nNext we need to order the fold changes in decreasing order. To do this we’ll use the sort() function, which takes a vector as input. This is in contrast to Tidyverse’s arrange(), which requires a data frame.\n\n# Sort fold changes in decreasing order\nfoldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\n# Confirm that foldchanges is sorted correctly\nhead(foldchanges)\n\n    4343     3310     4046      429   254122    10083 \n6.987221 6.501850 6.006265 4.608039 3.639205 2.979537 \n\n\n\n\nTheory of GSEA\nNow we are ready to perform GSEA. The details regarding GSEA can be found in the PNAS paper by Subramanian et al. We will describe briefly the steps outlined in the paper below:\n\n\n\nImage credit: Subramanian et al. Proceedings of the National Academy of Sciences Oct 2005, 102 (43) 15545-15550; DOI: 10.1073/pnas.0506580102\nThis image describes the theory of GSEA, with the ‘gene set S’ showing the metric used (in our case, ranked log2 fold changes) to determine enrichment of genes in the gene set. The left-most image is representing this metric used for the GSEA analysis. The log2 fold changes for each gene in the ‘gene set S’ is shown as a line in the middle image. The large positive log2 fold changes are at the top of the gene set image, while the largest negative log2 fold changes are at the bottom of the gene set image. In the right-most image, the gene set is turned horizontally, underneath which is an image depicting the calculations involved in determining enrichment, as described below.\nStep 1: Calculation of enrichment score:\nAn enrichment score for a particular gene set is calculated by walking down the list of log2 fold changes and increasing the running-sum statistic every time a gene in the gene set is encountered and decreasing it when genes are not part of the gene set. The size of the increase/decrease is determined by magnitude of the log2 fold change. Larger (positive or negative) log2 fold changes will result in larger increases or decreases. The final enrichment score is where the running-sum statistic is the largest deviation from zero.\nStep 2: Estimation of significance:\nThe significance of the enrichment score is determined using permutation testing, which performs rearrangements of the data points to determine the likelihood of generating an enrichment score as large as the enrichment score calculated from the observed data. Essentially, for this step, the first permutation would reorder the log2 fold changes and randomly assign them to different genes, reorder the gene ranks based on these new log2 fold changes, and recalculate the enrichment score. The second permutation would reorder the log2 fold changes again and recalculate the enrichment score again, and this would continue for the total number of permutations run. Therefore, the number of permutations run will increase the confidence in the significance estimates.\nStep 3: Adjust for multiple test correction\nAfter all gene sets are tested, the enrichment scores are normalized for the size of the gene set, then the p-values are corrected for multiple testing.\nThe GSEA output will yield the core genes in the gene sets that most highly contribute to the enrichment score. The genes output are generally the genes at or before the running sum reaches its maximum value (i.e., the most influential genes driving the differences between conditions for that gene set).\n\n\nPerforming GSEA\nFirst, we will set the seed so that we all obtain the same result:\n\nset.seed(123456)\n\n\n\n\n\n\n\nNote\n\n\n\nThe permutations are performed using random reordering, so every time we run the function we will get slightly different results. If we would like to use the same permutations every time we run a function, then we use the set.seed(123456) function prior to running. The input to set.seed() can be any number, but if you would want the same results, then you would need to use the same number as the lesson.\n\n\nTo perform the GSEA using KEGG gene sets with clusterProfiler, we can use the gseKEGG() function. The organisms with available KEGG pathway information are listed here.\n\n# Run GSEA using gene sets from KEGG pathways\ngseaKEGG &lt;- gseKEGG(\n  geneList = foldchanges, # ordered named vector of fold changes (Entrez IDs are the associated names)\n  organism = \"hsa\", # supported organisms listed below\n  minGSSize = 20, # minimum gene set size (# genes in set) - change to test more sets or recover sets with fewer # genes\n  pvalueCutoff = 0.05, # padj cutoff value\n  verbose = FALSE)\n\n# Extract the GSEA results\ngseaKEGG_results &lt;- gseaKEGG@result\n\n\n# Write results to file\nwrite.csv(gseaKEGG_results, \"results/gseaOE_kegg.csv\", quote = FALSE)\n\nHow many pathways are enriched? NOTE: The results may look slightly different for you.\n\n# Look at GSEA results\nhead(gseaKEGG_results)\n\n               ID                                       Description setSize\nhsa00190 hsa00190                         Oxidative phosphorylation     124\nhsa05012 hsa05012                                 Parkinson disease     238\nhsa05014 hsa05014                     Amyotrophic lateral sclerosis     331\nhsa05016 hsa05016                                Huntington disease     276\nhsa04714 hsa04714                                     Thermogenesis     213\nhsa05208 hsa05208 Chemical carcinogenesis - reactive oxygen species     199\n         enrichmentScore       NES       pvalue     p.adjust       qvalue rank\nhsa00190      -0.5613308 -2.253628 7.184082e-09 7.399605e-07 6.049753e-07 4108\nhsa05012      -0.4697490 -2.057186 3.757128e-09 7.399605e-07 6.049753e-07 4020\nhsa05014      -0.4252949 -1.933580 6.041944e-09 7.399605e-07 6.049753e-07 3056\nhsa05016      -0.4258820 -1.895742 1.538568e-07 1.188544e-05 9.717271e-06 3590\nhsa04714      -0.4576529 -1.964456 2.141965e-07 1.323734e-05 1.082256e-05 3590\nhsa05208      -0.4570364 -1.942055 3.896519e-07 1.720035e-05 1.406262e-05 3827\n                           leading_edge\nhsa00190 tags=50%, list=27%, signal=37%\nhsa05012 tags=47%, list=27%, signal=35%\nhsa05014 tags=34%, list=20%, signal=28%\nhsa05016 tags=43%, list=24%, signal=34%\nhsa04714 tags=38%, list=24%, signal=29%\nhsa05208 tags=40%, list=25%, signal=30%\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               core_enrichment\nhsa00190                                                                                                                                                                                                                                                                                                             533/518/10312/126328/506/1349/10632/1329/90423/4716/513/4722/1352/1353/515/4723/27089/523/4715/514/9377/100532726/516/4713/9551/4706/4717/4696/54539/4718/4728/4725/4514/4726/537/4714/1340/4720/4702/9296/23545/6391/10063/4729/535/9550/4708/528/527/4538/4519/4539/9114/155066/4535/4540/4513/4541/4508/4509/4536/4537\nhsa05012                              5689/126328/25800/90550/805/51465/2770/506/5714/292/1349/118424/1329/4716/513/3800/4722/515/7327/4723/293/29985/27089/5687/10131/55334/4715/23516/3799/10376/27173/514/9377/100532726/5705/516/4713/836/6647/4706/7311/91252/4717/4696/5685/54539/4718/5704/5691/4728/10383/5692/5702/5694/4725/5693/7846/842/4514/11315/203068/7416/4726/5701/5715/4714/1340/5695/1616/4720/4702/7419/4128/64837/5708/84790/7326/5690/808/6391/3798/25828/10105/5700/5709/5707/120892/2771/5688/7345/4729/5717/7332/581/598/5566/11047/4708/9817/4538/4519/4539/5567/51807/4535/5602/4540/4513/4541/4508/4509/4536/4537\nhsa05014                    311/514/9377/11258/5603/9217/100532726/637/5705/516/4713/836/6647/4706/10121/1769/4717/2876/56893/10762/8480/23511/4696/5685/7186/54539/4928/79139/4718/55916/5704/5691/2521/81929/4728/9883/10383/5692/5702/9776/5694/4725/5693/10482/5534/7846/842/4514/203068/7416/71/5216/4726/5701/5608/5715/140775/4714/4218/1340/5695/4686/1616/79902/4720/4702/51164/56000/64837/7415/220988/2475/5708/84790/5690/55706/6391/3798/5700/9782/5709/5532/84516/22863/5707/116442/5688/572/4729/5717/581/598/4747/84134/10189/11047/4708/2733/2878/4538/60/10452/4519/4539/51807/4535/55567/4540/4513/4541/4508/4509/4536/4537\nhsa05016 506/5714/5431/292/1349/4899/1329/29982/5432/4716/513/3800/4722/25942/515/4723/293/27089/5687/1212/6507/26100/4715/3799/10376/514/9377/11258/163/100532726/5705/516/4713/836/6647/5609/4706/10121/1769/4717/2876/161/7019/4696/5685/1211/7186/54539/4718/5704/5691/4728/10383/5692/5702/9776/5694/4725/5693/7846/842/4514/203068/7416/4726/5701/5715/4714/1340/10488/5695/4720/4702/51164/7419/5436/64837/3065/2475/5708/84790/5690/1175/5438/5434/6391/3798/6874/10105/5700/5709/2776/84516/22863/5707/5688/4729/5439/5717/581/1387/5441/11047/4708/2878/5435/4538/4519/4539/51807/4535/5602/55567/4540/4513/4541/4508/4509/4536/4537\nhsa04714                                                                                                                                                                                                    4716/513/6604/4722/1352/1353/515/4723/7248/27089/4715/7249/514/9377/5603/100532726/516/4713/9551/4706/6605/137682/4717/8193/4696/51422/29078/54539/4718/84987/51287/10818/4728/3991/116228/4725/4514/6602/71/4726/51548/4714/1340/10488/5564/4720/4702/2475/4893/6599/64223/107/6391/10063/65260/6597/4729/284184/28958/5566/2885/4708/3265/57492/84335/6598/86/4538/60/113/4519/4539/5567/4535/4540/4513/4541/4508/4509/4536/4537\nhsa05208                                                                                                                                                                                                                               5605/292/1349/873/6416/1329/5595/3845/65010/5970/4716/513/4722/369/515/4723/293/119391/27089/4715/514/9377/5603/100532726/516/4713/1545/6647/5609/4706/4717/4696/1535/54539/4718/405/208/4728/52/4725/5291/4514/5770/7416/4726/4714/5170/1340/4720/4702/207/7419/5781/4893/6391/10105/572/4729/1728/5594/2885/4708/3265/1571/9817/9020/4538/4519/4539/2353/4535/5602/4540/4513/4541/4508/4509/4536/4537\n\n\n\nThe first few columns of the results table identify the pathway information\nThe following columns include the associated statistics\nThe last column will report which genes are part of the ‘core enrichment’. These are the genes associated with the pathway which contributed to the observed enrichment score (i.e., in the extremes of the ranking). The genes are listed by EntrezID.\n\n\n\n\n\n\n\nNote\n\n\n\nThe DOSE package has a handy function which allows us to easily convert the list of Entrez identifiers into gene symbols. This is possible if and only if there is an OrgDb available for your organism. The function takes the gseaKEGG object as input and returns the same object with the gene symbols in the ‘core enrichment’ column.\n\n# Example code\ngseaKEGG_geneSymbol &lt;- setReadable(gseaKEGG, OrgDb = org.Hs.eg.db, keyType = \"ENTREZID\")\n\n\n\nLet’s explore the GSEA plot of enrichment of one of the pathways in the ranked list:\n\n# Plot the GSEA plot for a single enriched pathway, `hsa03008`\ngseaplot(gseaKEGG, geneSetID = 'hsa03008')\n\n\n\n\n\n\n\n\nIn this plot, the lines in plot represent the genes in the gene set ‘hsa03008’, and where they occur among the log2 fold changes. The largest positive log2 fold changes are on the left-hand side of the plot, while the largest negative log2 fold changes are on the right. The top plot shows the magnitude of the log2 fold changes for each gene, while the bottom plot shows the running sum, with the enrichment score peaking at the red dotted line (which is among the negative log2 fold changes). This suggests the down-regulation of this pathway.\nUse the Pathview R package to integrate the KEGG pathway data from clusterProfiler into pathway images:\n\n# First unload dplyr to avoid conflicts\ndetach(\"package:dplyr\", unload=TRUE)\n\n# Output images for a single significant KEGG pathway\npathview(gene.data = foldchanges,\n         pathway.id = \"hsa03008\",\n         species = \"hsa\",\n         limit = list(gene = 2, # value gives the max/min limit for foldchanges\n                      cpd = 1))\n\n\n\n\n\n\n\nWarning\n\n\n\nIf the below error message occurs: Error in detach(\"package:dplyr\", unload = T) : invalid 'name' argument, that means the dplyr package is not currently loaded. Ignore the message and continue to run pathview command.\n\n\n\n\n\n\n\n\nNote\n\n\n\nPathview may not display in your R Plots window. Instead, you may see a message such as Info: Working in directory /Users/yourname/Desktop/DEanalysis and Info: Writing image file hsa03008.pathview.png. This indicates that the image has instead been saved to that directory. You can open the pathview file to view it.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPrinting out Pathview images for all significant pathways can be easily performed as follows:\n\n# Output images for all significant KEGG pathways\n\n# Make a function to plot a single pathway\nget_kegg_plots &lt;- function(x) {\n  pathview(gene.data = foldchanges, \n           pathway.id = gseaKEGG_results$ID[x], \n           species = \"hsa\",\n           limit = list(gene = 2, cpd = 1))\n}\n\n# Run through that function for all pathways\npurrr::map(1:length(gseaKEGG_results$ID), \n           get_kegg_plots)\n\n\n\n\n\nIncorpororating other gene sets for GSEA\nThere are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, and use that as input.\nThe Molecular Signatures Database (also known as MSigDB) is a collection of annotated gene sets. It contains 8 major collections:\n\nH: hallmark gene sets\nC1: positional gene sets\nC2: curated gene sets\nC3: motif gene sets\nC4: computational gene sets\nC5: GO gene sets\nC6: oncogenic signatures\nC7: immunologic signatures\n\nUsers can download GMT files from Broad Institute and use the read.gmt() function to parse the files. Alternatively, there is an R package that already packed the MSigDB gene sets in tidy data format that can be used directly with clusterProfiler. The msigdbr package supports several species and some example code is provided below:\n\n# DO NOT RUN THIS CODE\n\n# Load library\nlibrary(msigdbr)\n\n# See what species are available\nmsigdbr_show_species()\n##  [1] \"Anolis carolinensis\"             \"Bos taurus\"                     \n##  [3] \"Caenorhabditis elegans\"          \"Canis lupus familiaris\"         \n##  [5] \"Danio rerio\"                     \"Drosophila melanogaster\"        \n##  [7] \"Equus caballus\"                  \"Felis catus\"                    \n##  [9] \"Gallus gallus\"                   \"Homo sapiens\"                   \n## [11] \"Macaca mulatta\"                  \"Monodelphis domestica\"          \n## [13] \"Mus musculus\"                    \"Ornithorhynchus anatinus\"       \n## [15] \"Pan troglodytes\"                 \"Rattus norvegicus\"              \n## [17] \"Saccharomyces cerevisiae\"        \"Schizosaccharomyces pombe 972h-\"\n## [19] \"Sus scrofa\"                      \"Xenopus tropicalis\"\n\n# Use a specific collection; example C6 oncogenic signatures\nm_t2g &lt;- msigdbr(species = \"Homo sapiens\", category = \"C6\") %&gt;% \n  dplyr::select(gs_name, entrez_gene)\n\n# Run GSEA\nmsig_GSEA &lt;- GSEA(foldchanges, TERM2GENE = m_t2g, verbose = FALSE)",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html#functional-analysis-pathway-topology-tools",
    "href": "lessons/11_FA_functional_class_scoring.html#functional-analysis-pathway-topology-tools",
    "title": "Functional Analysis for RNA-seq",
    "section": "Functional analysis: Pathway topology tools",
    "text": "Functional analysis: Pathway topology tools\n\n\n\nThe last main type of functional analysis technique is pathway topology analysis. Pathway topology analysis often takes into account gene interaction information along with the fold changes and adjusted p-values from differential expression analysis to identify dysregulated pathways. Depending on the tool, pathway topology tools explore how genes interact with each other (e.g., activation, inhibition, phosphorylation, ubiquitination, etc.) to determine the pathway-level statistics. Pathway topology-based methods utilize the number and type of interactions between gene product (our DE genes) and other gene products to infer gene function or pathway association.\nFor instance, the SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. We have step-by-step materials for using SPIA available.",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html#other-tools-for-functional-analysis",
    "href": "lessons/11_FA_functional_class_scoring.html#other-tools-for-functional-analysis",
    "title": "Functional Analysis for RNA-seq",
    "section": "Other Tools for Functional Analysis",
    "text": "Other Tools for Functional Analysis\n\nCo-expression clustering\nCo-expression clustering is often used to identify genes of novel pathways or networks by grouping genes together based on similar trends in expression. These tools are useful in identifying genes in a pathway, when their participation in a pathway and/or the pathway itself is unknown. These tools cluster genes with similar expression patterns to create ‘modules’ of co-expressed genes that often reflect functionally similar groups of genes. These ‘modules’ can then be compared across conditions or in a time-course experiment to identify any biologically relevant pathway or network information.\nYou can visualize co-expression clustering using heatmaps, which should be viewed as suggestive only; serious classification of genes needs better methods.\nThe way the tools perform clustering is by taking the entire expression matrix and computing pair-wise co-expression values. A network is then generated from which we explore the topology to make inferences on gene co-regulation. The WGCNA package (in R) is one example of a more sophisticated method for co-expression clustering (please note however that it is no longer maintained).",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/11_FA_functional_class_scoring.html#resources-for-functional-analysis",
    "href": "lessons/11_FA_functional_class_scoring.html#resources-for-functional-analysis",
    "title": "Functional Analysis for RNA-seq",
    "section": "Resources for functional analysis",
    "text": "Resources for functional analysis\n\ng:Profiler - http://biit.cs.ut.ee/gprofiler/index.cgi\nDAVID - https://david.ncifcrf.gov\nclusterProfiler - http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html\nGeneMANIA - http://www.genemania.org/\nGenePattern - http://www.broadinstitute.org/cancer/software/genepattern/ (need to register)\nWebGestalt - http://www.webgestalt.org (need to register)\nAmiGO - http://amigo.geneontology.org/amigo\nReviGO (visualizing GO analysis, input is GO terms) - http://revigo.irb.hr/\nWGCNA - https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/ (no longer maintained)\nGSEA - http://software.broadinstitute.org/gsea/index.jsp\nSPIA - https://www.bioconductor.org/packages/release/bioc/html/SPIA.html\nGAGE/Pathview - http://www.bioconductor.org/packages/release/bioc/html/gage.html",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq"
    ]
  },
  {
    "objectID": "lessons/pathway_topology.html",
    "href": "lessons/pathway_topology.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nSPIA\nThe SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. The blog post from Getting Genetics Done provides a step-by-step procedure for using and understanding SPIA.\n\n# Install package (if needed)\n# BiocManager::install(\"SPIA\")\n\n# Load package\nlibrary(SPIA)\n\nTo perform SPIA, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n\n# The background set is a vector of all the genes represented on the platform\nbackground_entrez &lt;- res_entrez$entrezid\n\n# Significant genes is a vector of fold changes where the names are ENTREZ gene IDs\nsig_res_entrez &lt;- res_entrez[which(res_entrez$padj &lt; 0.05), ]\nsig_entrez &lt;- sig_res_entrez$log2FoldChange\nnames(sig_entrez) &lt;- sig_res_entrez$entrezid\n\n# Look at the significant gene list input\nhead(sig_entrez)\n\n      7105       8813      55732       2729       4800       5893 \n-0.4197796  0.3410360 -0.2473067 -0.2696720 -0.2883368 -0.2728536 \n\n\nNow that we have our background and significant genes in the appropriate format, we can run SPIA (this will take a few minutes as it runs through all the pathways):\n\n# Run SPIA\nspia_result &lt;- spia(de=sig_entrez, all=background_entrez, organism=\"hsa\")\n\n\nDone pathway 1 : RNA transport..\nDone pathway 2 : RNA degradation..\nDone pathway 3 : PPAR signaling pathway..\nDone pathway 4 : Fanconi anemia pathway..\nDone pathway 5 : MAPK signaling pathway..\nDone pathway 6 : ErbB signaling pathway..\nDone pathway 7 : Calcium signaling pathway..\nDone pathway 8 : Cytokine-cytokine receptor int..\nDone pathway 9 : Chemokine signaling pathway..\nDone pathway 10 : NF-kappa B signaling pathway..\nDone pathway 11 : Phosphatidylinositol signaling..\nDone pathway 12 : Neuroactive ligand-receptor in..\nDone pathway 13 : Cell cycle..\nDone pathway 14 : Oocyte meiosis..\nDone pathway 15 : p53 signaling pathway..\nDone pathway 16 : Sulfur relay system..\nDone pathway 17 : SNARE interactions in vesicula..\nDone pathway 18 : Regulation of autophagy..\nDone pathway 19 : Protein processing in endoplas..\nDone pathway 20 : Lysosome..\nDone pathway 21 : mTOR signaling pathway..\nDone pathway 22 : Apoptosis..\nDone pathway 23 : Vascular smooth muscle contrac..\nDone pathway 24 : Wnt signaling pathway..\nDone pathway 25 : Dorso-ventral axis formation..\nDone pathway 26 : Notch signaling pathway..\nDone pathway 27 : Hedgehog signaling pathway..\nDone pathway 28 : TGF-beta signaling pathway..\nDone pathway 29 : Axon guidance..\nDone pathway 30 : VEGF signaling pathway..\nDone pathway 31 : Osteoclast differentiation..\nDone pathway 32 : Focal adhesion..\nDone pathway 33 : ECM-receptor interaction..\nDone pathway 34 : Cell adhesion molecules (CAMs)..\nDone pathway 35 : Adherens junction..\nDone pathway 36 : Tight junction..\nDone pathway 37 : Gap junction..\nDone pathway 38 : Complement and coagulation cas..\nDone pathway 39 : Antigen processing and present..\nDone pathway 40 : Toll-like receptor signaling p..\nDone pathway 41 : NOD-like receptor signaling pa..\nDone pathway 42 : RIG-I-like receptor signaling ..\nDone pathway 43 : Cytosolic DNA-sensing pathway..\nDone pathway 44 : Jak-STAT signaling pathway..\nDone pathway 45 : Natural killer cell mediated c..\nDone pathway 46 : T cell receptor signaling path..\nDone pathway 47 : B cell receptor signaling path..\nDone pathway 48 : Fc epsilon RI signaling pathwa..\nDone pathway 49 : Fc gamma R-mediated phagocytos..\nDone pathway 50 : Leukocyte transendothelial mig..\nDone pathway 51 : Intestinal immune network for ..\nDone pathway 52 : Circadian rhythm - mammal..\nDone pathway 53 : Long-term potentiation..\nDone pathway 54 : Neurotrophin signaling pathway..\nDone pathway 55 : Retrograde endocannabinoid sig..\nDone pathway 56 : Glutamatergic synapse..\nDone pathway 57 : Cholinergic synapse..\nDone pathway 58 : Serotonergic synapse..\nDone pathway 59 : GABAergic synapse..\nDone pathway 60 : Dopaminergic synapse..\nDone pathway 61 : Long-term depression..\nDone pathway 62 : Olfactory transduction..\nDone pathway 63 : Taste transduction..\nDone pathway 64 : Phototransduction..\nDone pathway 65 : Regulation of actin cytoskelet..\nDone pathway 66 : Insulin signaling pathway..\nDone pathway 67 : GnRH signaling pathway..\nDone pathway 68 : Progesterone-mediated oocyte m..\nDone pathway 69 : Melanogenesis..\nDone pathway 70 : Adipocytokine signaling pathwa..\nDone pathway 71 : Type II diabetes mellitus..\nDone pathway 72 : Type I diabetes mellitus..\nDone pathway 73 : Maturity onset diabetes of the..\nDone pathway 74 : Aldosterone-regulated sodium r..\nDone pathway 75 : Endocrine and other factor-reg..\nDone pathway 76 : Vasopressin-regulated water re..\nDone pathway 77 : Salivary secretion..\nDone pathway 78 : Gastric acid secretion..\nDone pathway 79 : Pancreatic secretion..\nDone pathway 80 : Carbohydrate digestion and abs..\nDone pathway 81 : Bile secretion..\nDone pathway 82 : Mineral absorption..\nDone pathway 83 : Alzheimer's disease..\nDone pathway 84 : Parkinson's disease..\nDone pathway 85 : Amyotrophic lateral sclerosis ..\nDone pathway 86 : Huntington's disease..\nDone pathway 87 : Prion diseases..\nDone pathway 88 : Cocaine addiction..\nDone pathway 89 : Amphetamine addiction..\nDone pathway 90 : Morphine addiction..\nDone pathway 91 : Alcoholism..\nDone pathway 92 : Bacterial invasion of epitheli..\nDone pathway 93 : Vibrio cholerae infection..\nDone pathway 94 : Epithelial cell signaling in H..\nDone pathway 95 : Pathogenic Escherichia coli in..\nDone pathway 96 : Shigellosis..\nDone pathway 97 : Salmonella infection..\nDone pathway 98 : Pertussis..\nDone pathway 99 : Legionellosis..\nDone pathway 100 : Leishmaniasis..\nDone pathway 101 : Chagas disease (American trypa..\nDone pathway 102 : African trypanosomiasis..\nDone pathway 103 : Malaria..\nDone pathway 104 : Toxoplasmosis..\nDone pathway 105 : Amoebiasis..\nDone pathway 106 : Staphylococcus aureus infectio..\nDone pathway 107 : Tuberculosis..\nDone pathway 108 : Hepatitis C..\nDone pathway 109 : Measles..\nDone pathway 110 : Influenza A..\nDone pathway 111 : HTLV-I infection..\nDone pathway 112 : Herpes simplex infection..\nDone pathway 113 : Epstein-Barr virus infection..\nDone pathway 114 : Pathways in cancer..\nDone pathway 115 : Transcriptional misregulation ..\nDone pathway 116 : Viral carcinogenesis..\nDone pathway 117 : Colorectal cancer..\nDone pathway 118 : Renal cell carcinoma..\nDone pathway 119 : Pancreatic cancer..\nDone pathway 120 : Endometrial cancer..\nDone pathway 121 : Glioma..\nDone pathway 122 : Prostate cancer..\nDone pathway 123 : Thyroid cancer..\nDone pathway 124 : Basal cell carcinoma..\nDone pathway 125 : Melanoma..\nDone pathway 126 : Bladder cancer..\nDone pathway 127 : Chronic myeloid leukemia..\nDone pathway 128 : Acute myeloid leukemia..\nDone pathway 129 : Small cell lung cancer..\nDone pathway 130 : Non-small cell lung cancer..\nDone pathway 131 : Asthma..\nDone pathway 132 : Autoimmune thyroid disease..\nDone pathway 133 : Systemic lupus erythematosus..\nDone pathway 134 : Rheumatoid arthritis..\nDone pathway 135 : Allograft rejection..\nDone pathway 136 : Graft-versus-host disease..\nDone pathway 137 : Arrhythmogenic right ventricul..\nDone pathway 138 : Dilated cardiomyopathy..\nDone pathway 139 : Viral myocarditis..\n\n# Look at the results\nhead(spia_result, n=20)\n\n                                     Name    ID pSize NDE         pNDE\n1                    Viral carcinogenesis 05203   179  85 1.105913e-07\n2   Pathogenic Escherichia coli infection 05130    47  26 1.384417e-04\n3                           RNA transport 03013   145  63 1.364787e-04\n4            Epstein-Barr virus infection 05169   182  73 7.872927e-04\n5            Systemic lupus erythematosus 05322    74  35 6.338994e-04\n6                     Parkinson's disease 05012   120  50 1.935891e-03\n7                          Focal adhesion 04510   182  65 2.836833e-02\n8                   p53 signaling pathway 04115    66  32 6.225200e-04\n9                          Bladder cancer 05219    40  20 4.025368e-03\n10                             Cell cycle 04110   121  51 1.299369e-03\n11               Chronic myeloid leukemia 05220    70  29 1.719907e-02\n12              Circadian rhythm - mammal 04710    21  10 5.446312e-02\n13                       HTLV-I infection 05166   226  87 1.219991e-03\n14               ECM-receptor interaction 04512    70  26 8.644146e-02\n15                             Alcoholism 05034   124  49 7.371891e-03\n16                 MAPK signaling pathway 04010   224  76 5.975551e-02\n17 Cytokine-cytokine receptor interaction 04060   122  38 3.298457e-01\n18                 Small cell lung cancer 05222    80  32 2.221126e-02\n19       Regulation of actin cytoskeleton 04810   180  60 1.136433e-01\n20              Vibrio cholerae infection 05110    48  21 2.055235e-02\n            tA pPERT           pG        pGFdr       pGFWER    Status\n1   1.06476367 0.106 2.257992e-07 0.0000309345 0.0000309345 Activated\n2  -2.68535900 0.508 7.428320e-04 0.0508839887 0.1017679775 Inhibited\n3   0.14039420 0.821 1.131312e-03 0.0516632252 0.1549896757 Activated\n4  -3.29767850 0.320 2.339543e-03 0.0801293411 0.3205173645 Inhibited\n5   0.63886550 0.552 3.134455e-03 0.0843101831 0.4294203963 Activated\n6  -3.38846958 0.223 3.776445e-03 0.0843101831 0.5173729580 Inhibited\n7  22.00835240 0.018 4.381136e-03 0.0843101831 0.6002156717 Activated\n8  -0.07045235 0.977 5.111940e-03 0.0843101831 0.7003358416 Inhibited\n9  -4.12392474 0.185 6.108373e-03 0.0843101831 0.8368471586 Inhibited\n10  2.88206442 0.578 6.154028e-03 0.0843101831 0.8431018308 Activated\n11 -7.14491710 0.051 7.051281e-03 0.0844021190 0.9660255137 Inhibited\n12 -5.85306921 0.017 7.392886e-03 0.0844021190 1.0000000000 Inhibited\n13 -0.28565758 0.945 8.952757e-03 0.0913882483 1.0000000000 Inhibited\n14  6.50476159 0.014 9.338945e-03 0.0913882483 1.0000000000 Activated\n15 -7.40641835 0.234 1.270050e-02 0.1124219731 1.0000000000 Inhibited\n16  8.95882802 0.030 1.312957e-02 0.1124219731 1.0000000000 Activated\n17  7.49673694 0.006 1.429906e-02 0.1129193776 1.0000000000 Activated\n18  9.11228085 0.093 1.483612e-02 0.1129193776 1.0000000000 Activated\n19 18.84748586 0.020 1.610715e-02 0.1161410145 1.0000000000 Activated\n20 -1.35210996 0.118 1.702923e-02 0.1166502561 1.0000000000 Inhibited\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               KEGGLINK\n1            http://www.genome.jp/dbget-bin/show_pathway?hsa05203+1739+5829+578+3661+5700+1108+3725+836+581+572+5366+7187+7188+1642+5594+10488+64764+90993+9586+6777+5291+5293+5966+1959+1019+55697+5902+2648+6850+3718+595+894+896+890+4193+28973+898+9134+1233+7419+3265+3845+4893+10971+7529+7531+7532+7534+6502+2965+1387+9114+1026+5315+3065+5922+998+387+81+88+2957+991+3665+3106+3107+3133+3134+5566+5567+2885+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370\n2                                                                                                                                                                                                                                                                                                          http://www.genome.jp/dbget-bin/show_pathway?hsa05130+10376+51807+7277+7846+84790+999+10971+7534+3875+1499+2017+6093+998+5578+9181+387+4691+10381+10383+203068+347733+10092+10093+10552+60+71\n3                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa03013+11260+5901+7514+4686+1207+79760+3837+10073+9939+22794+22985+10482+56000+5411+10189+29107+55916+10762+4928+79902+81929+8480+23225+94026+9883+55706+5905+6612+10419+1917+51068+10209+10289+1964+8661+8662+8663+8666+8667+8668+10556+10775+10799+10940+84321+79228+132430+26986+80336+1968+8894+10605+1973+1974+1981+1982+8672+1983+1975+10460+8892+26999+9513\n4                                                                   http://www.genome.jp/dbget-bin/show_pathway?hsa05169+3113+3106+3107+3133+3134+9612+10971+7529+7531+7532+7534+3303+3304+3305+3306+3310+3312+3315+4609+3065+1387+890+6502+8737+7187+7188+9020+3654+960+5602+3725+3718+5291+5293+207+208+6850+5336+5432+5433+5434+5435+5436+5438+5439+5441+11128+171568+51728+55718+661+84265+3661+9451+7431+7514+5901+5566+5567+1457+1460+1026+4193+3588+5700+5701+5702+5704+5705+5707+5708+5709+5717\n5                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa05322+720+717+3111+3113+3014+8329+8334+8336+92815+94239+9555+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+126961+3020+8357+554313+8360+8362+8367+8370+6628+6632+6634+81+88+6741\n6                                                                                                                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa05012+120892+7332+9246+2861+11315+7345+4535+4536+4537+4538+4539+4540+4541+4697+4702+4706+4708+4713+4714+4715+4717+4718+4720+4725+4726+4728+4729+54539+6391+27089+440567+4519+1340+1349+4513+4514+9377+4508+4509+506+515+518+10105+293+7416+7419+7326+7327+842+836\n7                                                                                                                         http://www.genome.jp/dbget-bin/show_pathway?hsa04510+3693+22801+3655+3672+3675+3676+3678+2318+998+85366+10627+1729+5499+6093+207+208+5170+55742+7408+5291+5293+81+88+824+5829+5578+387+5923+1280+1288+1289+1292+1302+284217+3908+3909+3911+3912+3915+7058+7059+857+331+572+2002+5594+595+894+896+3265+2885+1956+3480+5156+5159+5154+5228+25759+1398+2889+5602+3725+1499+60+71\n8                                                                                                                                                                                                                                                                                     http://www.genome.jp/dbget-bin/show_pathway?hsa04115+1647+4616+472+898+9134+8493+7161+900+6241+1643+1026+64393+9538+355+51512+581+8795+842+4193+1019+595+894+896+64065+51246+143686+83667+85417+891+9133+836+5366\n9                                                                                                                                                                                                                                                                                                                                                 http://www.genome.jp/dbget-bin/show_pathway?hsa05219+3265+4313+5228+3576+1956+999+1026+4609+1612+4193+1869+1870+2261+1019+595+9252+5594+369+3845+4893\n10                                                                                                                                                                                          http://www.genome.jp/dbget-bin/show_pathway?hsa04110+51343+4171+4172+4173+4176+4998+51434+996+6500+8454+5347+472+10971+7529+7531+7532+7534+1026+4193+1387+6502+9088+9700+8243+1647+4616+8317+991+994+990+993+85417+891+9133+890+1019+902+898+9134+595+894+896+9126+10274+1874+4609+7709+7027+1869+1870+3065\n11                                                                                                                                                                                                                                                                                                     http://www.genome.jp/dbget-bin/show_pathway?hsa05220+2122+598+5781+3065+1487+4609+7048+7046+6777+4193+572+1026+2885+25759+9846+1398+1869+1870+1019+595+207+208+5291+5293+5594+369+3265+3845+4893\n12                                                                                                                                                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa04710+79365+8553+1408+4862+9572+5187+8863+6500+8454+8945\n13 http://www.genome.jp/dbget-bin/show_pathway?hsa05166+6513+10725+4773+11261+5532+5534+3718+6777+3106+3107+3133+3134+4609+8295+10524+894+3265+3845+4893+6237+293+7416+7419+7514+5901+8498+107+113+5566+5567+467+7494+7046+7048+5425+5427+56655+1026+51434+996+991+9133+5902+55697+9020+115650+5602+3725+598+331+5156+5159+5154+5291+5293+207+208+11211+8322+1855+1857+1499+1739+1019+595+896+1869+1870+2002+2005+2353+1958+1959+8061+3111+3113+2648+1387+6929+581+4605+23373+64784+4488+7538+472+94241\n14                                                                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa04512+284217+3908+3909+3911+3912+3915+1280+1288+1289+1292+1302+1605+7058+7059+3655+3676+3161+961+6382+6385+3693+22801+3678+3675+3672+960\n15                                                                                                                                                                                http://www.genome.jp/dbget-bin/show_pathway?hsa05034+5499+5566+10488+64764+90993+9586+814+3065+808+2771+2782+2786+2790+2792+2030+3265+3845+4893+369+5594+2354+3014+8329+8334+8336+92815+94239+9555+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370+126961+3020+8357+4915+25759+2885\n16                                                        http://www.genome.jp/dbget-bin/show_pathway?hsa04010+5923+11221+80824+5495+9448+5321+3925+9020+5594+8649+5578+5566+5567+9693+5922+3265+3845+4893+6237+10235+2768+2885+5156+5159+2261+2263+1956+4915+785+8912+8913+9254+5154+2247+2256+8074+994+9252+7867+4149+1649+2005+2002+5536+207+208+3315+1647+4616+1616+836+7046+7048+355+8550+998+23542+5602+1398+409+2122+3303+3304+3305+3306+3310+3312+3725+4773+11261+5532+5534+2318+2353+4609+8569\n17                                                                                                                                                                                                                                                http://www.genome.jp/dbget-bin/show_pathway?hsa04060+659+3588+8809+657+7046+7048+268+83729+3625+3624+60401+115650+3604+355+8744+970+53832+3815+1956+5159+5156+4254+1435+5154+7173+85480+3953+1271+9180+3589+1233+1235+6387+3576+27242+51330+8795+8793\n18                                                                                                                                                                                                                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa05222+898+9134+595+3655+3675+9063+6257+5915+207+208+842+4149+4609+5291+5293+2272+1288+284217+3908+3909+3911+3912+3915+331+598+7187+7188+9618+1869+1870+1019+6502\n19                                                                                                                                   http://www.genome.jp/dbget-bin/show_pathway?hsa04810+7114+10092+10093+10552+5216+10163+55845+50649+10152+26999+10458+1072+3985+79837+8396+1729+81+88+4478+5962+5829+5499+10627+85366+6093+9459+998+387+9138+8826+5594+369+5291+5293+1398+22801+3655+3672+3675+3676+3678+3682+3693+3265+3845+4893+6237+2768+1956+2261+2263+5156+5159+2247+2256+5154+8074+2149+60+71\n20                                                                                                                                                                                                                                                                                                                                         http://www.genome.jp/dbget-bin/show_pathway?hsa05110+155066+23545+527+528+535+537+9114+9296+9550+5578+6558+5336+5566+5567+29927+55176+60+71+9601+10945+11014\n\n\nSPIA outputs a table showing significantly dysregulated pathways based on over-representation and signaling perturbations accumulation. The table shows the following information:\n\npSize: the number of genes on the pathway\nNDE: the number of DE genes per pathway\ntA: the observed total perturbation accumulation in the pathway\npNDE: the probability to observe at least NDE genes on the pathway using a hypergeometric model (similar to ORA)\npPERT: the probability to observe a total accumulation more extreme than tA only by chance\npG: the p-value obtained by combining pNDE and pPERT\npGFdr and pGFWER are the False Discovery Rate and Bonferroni adjusted global p-values, respectively\nStatus: gives the direction in which the pathway is perturbed (activated or inhibited)\nKEGGLINK gives a web link to the KEGG website that displays the pathway image with the differentially expressed genes highlighted in red\n\nWe can view the significantly dysregulated pathways by viewing the over-representation and perturbations for each pathway.\n\n# To avoid an error, remove any rows where `pPERT` is NA\nspia_result &lt;- spia_result %&gt;% filter(!is.na(pPERT))\n\n# Plot significant pathways\nplotP(spia_result, threshold=0.05)\n\n\n\n\n\n\n\n\nIn this plot, each pathway is a point and the coordinates are the log of pNDE (using a hypergeometric model) and the p-value from perturbations, pPERT. The oblique lines in the plot show the significance regions based on the combined evidence.\nIf we choose to explore the significant genes from our dataset occurring in these pathways, we can subset our SPIA results:\n\n# Look at pathway 05203 and view kegglink\nsubset(spia_result, ID == \"05203\")\n\n                  Name    ID pSize NDE         pNDE       tA pPERT           pG\n1 Viral carcinogenesis 05203   179  85 1.105913e-07 1.064764 0.106 2.257992e-07\n        pGFdr      pGFWER    Status\n1 3.09345e-05 3.09345e-05 Activated\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    KEGGLINK\n1 http://www.genome.jp/dbget-bin/show_pathway?hsa05203+1739+5829+578+3661+5700+1108+3725+836+581+572+5366+7187+7188+1642+5594+10488+64764+90993+9586+6777+5291+5293+5966+1959+1019+55697+5902+2648+6850+3718+595+894+896+890+4193+28973+898+9134+1233+7419+3265+3845+4893+10971+7529+7531+7532+7534+6502+2965+1387+9114+1026+5315+3065+5922+998+387+81+88+2957+991+3665+3106+3107+3133+3134+5566+5567+2885+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370\n\n\nThen, if we click on the KEGGLINK, we can view the genes within our dataset from these perturbed pathways:\n\n\n\nKEGG pathway with significant genes highlighted"
  },
  {
    "objectID": "lessons/07_DGE_summarizing_workflow.html",
    "href": "lessons/07_DGE_summarizing_workflow.html",
    "title": "Summary of DGE workflow",
    "section": "",
    "text": "Approximate time: 15 minutes",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/07_DGE_summarizing_workflow.html#learning-objectives",
    "href": "lessons/07_DGE_summarizing_workflow.html#learning-objectives",
    "title": "Summary of DGE workflow",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIdentify the R commands needed to run a complete differential expression analysis using DESeq2",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/07_DGE_summarizing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "href": "lessons/07_DGE_summarizing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "title": "Summary of DGE workflow",
    "section": "Summary of differential expression analysis workflow",
    "text": "Summary of differential expression analysis workflow\nWe have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below:\n\nObtaining gene-level counts from Salmon using tximport\n\n\n# Run tximport\ntxi &lt;- tximport(files, \n                type=\"salmon\", \n                tx2gene=t2g, \n                countsFromAbundance = \"lengthScaledTPM\")\n\n# \"files\" is a vector wherein each element is the path to the salmon quant.sf file, and each element is named with the name of the sample.\n# \"t2g\" is a 2 column data frame which contains transcript IDs mapped to geneIDs (in that order)\n\n\nCreating the dds object:\n\n\n# Check that the row names of the metadata equal the column names of the **raw counts** data\nall(colnames(txi$counts) == rownames(metadata))\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, \n                                colData = metadata, \n                                design = ~ condition)\n\n\nExploratory data analysis (PCA & hierarchical clustering) - identifying outliers and sources of variation in the data:\n\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, \n            blind=TRUE)\n\n# Plot PCA \nplotPCA(rld, \n        intgroup=\"condition\")\n\n# Extract the rlog matrix from the object and compute pairwise correlation values\nrld_mat &lt;- assay(rld)\nrld_cor &lt;- cor(rld_mat)\n\n# Plot heatmap\npheatmap(rld_cor, \n         annotation = metadata)\n\n\nRun DESeq2:\n\n\n# **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = metadata, design = ~ covariate + condition)\n\n# Run DESeq2 differential expression analysis\ndds &lt;- DESeq(dds)\n\n# **Optional step** - Output normalized counts to save as a file to access outside RStudio\n# normalized_counts &lt;- counts(dds, normalized=TRUE)\n\n\nCheck the fit of the dispersion estimates:\n\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\nCreate contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions:\n\n\n# Specify contrast for comparison of interest\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Output results of Wald test for contrast\nres &lt;- results(dds, \n               contrast = contrast, \n               alpha = 0.05)\n\n# Shrink the log2 fold changes to be more accurate\nres &lt;- lfcShrink(dds, \n                 coef = \"sampletype_group1_vs_group2\", \n                 type = \"apeglm\")    \n# The coef will be dependent on what your contrast was. and should be identical to what is stored in resultsNames()\n\n\nOutput significant results:\n\n\n# Set thresholds\npadj.cutoff &lt; - 0.05\n\n# Turn the results object into a tibble for use with tidyverse functions\nres_tbl &lt;- res %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset the significant results\nsig_res &lt;- dplyr::filter(res_tbl, \n                         padj &lt; padj.cutoff)\n\n\nVisualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc.\nPerform analysis to extract functional significance of results: GO or KEGG enrichment, GSEA, etc.\nMake sure to output the versions of all tools used in the DE analysis:\n\n\nsessionInfo()\n\nFor better reproducibility, it can help to create RMarkdown reports, which save all code, results, and visualizations as nicely formatted html reports. We have a very basic example of a report linked here. To create these reports we have additional materials available.",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/R_refresher.html",
    "href": "lessons/R_refresher.html",
    "title": "R refresher",
    "section": "",
    "text": "Approximate time: 45 minutes"
  },
  {
    "objectID": "lessons/R_refresher.html#learning-objectives",
    "href": "lessons/R_refresher.html#learning-objectives",
    "title": "R refresher",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the various data types and data structures (including tibbles) used by R\nUse functions in R and describe how to get help with arguments\nDescribe how to install and use packages in R\nUse the pipe (%&gt;%) from the dplyr package\nDescribe the syntax used by ggplot2 for making plots"
  },
  {
    "objectID": "lessons/R_refresher.html#setting-up",
    "href": "lessons/R_refresher.html#setting-up",
    "title": "R refresher",
    "section": "Setting up",
    "text": "Setting up\n\nLet’s create a new project directory for this review:\n\n\nCreate a new project called R_refresher.\nCreate a new R script called reviewing_R.R.\nCreate the following folders in the project directory - data, figures.\nDownload a counts file to the data folder by right-clicking here.\n\n\nNow that we have our directory structure setup, let’s load our libraries and read in our data:\n\n\nLoad the tidyverse library.\nUse read.csv() to read in the downloaded file and save it in the object/variable counts.\n\nWhat is the syntax for a function?\nHow do we get help for using a function?\n\nWhat is the data structure of counts?\n\nWhat main data structures are available in R?\n\nWhat are the data types of the columns?\n\nWhat data types are available in R?"
  },
  {
    "objectID": "lessons/R_refresher.html#creating-vectorsfactors-and-dataframes",
    "href": "lessons/R_refresher.html#creating-vectorsfactors-and-dataframes",
    "title": "R refresher",
    "section": "Creating vectors/factors and dataframes",
    "text": "Creating vectors/factors and dataframes\n\nWe are performing RNA-seq on cancer samples with genotypes of p53 wildtype (WT) and knock-down (KO). You have 8 samples total, with 4 replicates per genotype. Write the R code you would use to construct your metadata table as described below.\n\n\nCreate the vectors/factors for each column. (Hint: you can type out each vector/factor, or if you want the process go faster try exploring the rep() function.)\nPut them together into a dataframe called meta.\nUse the rownames() function to assign row names to the dataframe. (Hint: you can type out the row names as a vector, or if you want the process go faster try exploring the paste0() function.)\n\nYour finished metadata table should have information for the variables sex, stage, genotype, and myc levels:\n\n\n\n\nsex\nstage\ngenotype\nmyc\n\n\n\n\nKO1\nM\n1\nKO\n23\n\n\nKO2\nF\n2\nKO\n4\n\n\nKO3\nM\n2\nKO\n45\n\n\nKO4\nF\n1\nKO\n90\n\n\nWT1\nM\n2\nWT\n34\n\n\nWT2\nF\n1\nWT\n35\n\n\nWT3\nM\n1\nWT\n9\n\n\nWT4\nF\n2\nWT\n10"
  },
  {
    "objectID": "lessons/R_refresher.html#exploring-data",
    "href": "lessons/R_refresher.html#exploring-data",
    "title": "R refresher",
    "section": "Exploring data",
    "text": "Exploring data\nNow that we have created our metadata dataframe, it’s often a good idea to get some descriptive statistics about the data before performing any analyses.\n\nSummarize the contents of the meta object. How many data types are represented?\nCheck that the row names in the meta dataframe are identical to the column names in counts (content and order).\nConvert the existing stage column into a factor data type."
  },
  {
    "objectID": "lessons/R_refresher.html#extracting-data",
    "href": "lessons/R_refresher.html#extracting-data",
    "title": "R refresher",
    "section": "Extracting data",
    "text": "Extracting data\n\nUsing the meta dataframe created in the previous question, perform the following exercises (questions DO NOT build upon each other):\n\n\nReturn only the genotype and sex columns using [].\nReturn the genotype values for samples 1, 7, and 8 using [].\nUse filter() to return all data for those samples with genotype WT.\nUse filter()/select()to return only the stage and genotype columns for those samples with myc &gt; 50.\nAdd a column called pre_treatment to the beginning of the dataframe with the values T, F, T, F, T, F, T, F.\n\nWhy might this design be problematic?\n\nUsing %&gt;%, create a tibble of the meta object and call it meta_tb (make sure you don’t lose the rownames!)\nChange the names of the columns to: “A”, “B”, “C”, “D”, “E”."
  },
  {
    "objectID": "lessons/R_refresher.html#visualizing-data",
    "href": "lessons/R_refresher.html#visualizing-data",
    "title": "R refresher",
    "section": "Visualizing data",
    "text": "Visualizing data\n\nOften it is easier to see the patterns or nature of our data when we explore it visually with a variety of graphics. Let’s use ggplot2 to explore differences in the expression of the Myc gene based on genotype.\n\n\nPlot a boxplot of the expression of Myc for the KO and WT samples using theme_minimal() and give the plot new axes names and a centered title."
  },
  {
    "objectID": "lessons/R_refresher.html#preparing-for-downstream-analysis-tools",
    "href": "lessons/R_refresher.html#preparing-for-downstream-analysis-tools",
    "title": "R refresher",
    "section": "Preparing for downstream analysis tools",
    "text": "Preparing for downstream analysis tools\n\nMany different statistical tools or analytical packages expect all data needed as input to be in the structure of a list. Let’s create a list of our count and metadata in preparation for a downstream analysis.\n\n\nCreate a list called project1 with the meta and counts objects, as well as a new vector with all the sample names extracted from one of the 2 data frames.\n\nRscript with answers"
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-1",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the RNA-seq and differential gene expression analysis workflows\nExplain the experiment and its objectives\nCreate a project in R\nSet up for the analysis of RNA-seq data",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#review-of-the-dataset",
    "href": "lessons/01a_RNAseq_processing_workflow.html#review-of-the-dataset",
    "title": "Genomic annotations",
    "section": "Review of the dataset",
    "text": "Review of the dataset\nFor this workshop, we will be using a publicly available RNA-seq dataset that is part of a larger study described in Kenny PJ et al., 2014.\nThe RNA-seq was performed on HEK293F cells that were transfected either with a MOV10 transgene, siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below.\nUsing these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition.\n\n\n\n\n\n\n\n\n\nWhat is the purpose of these datasets? What does Mov10 do?\n\n\n\nThe authors are investigating interactions between various genes involved in Fragile X syndrome, a disease in which there is aberrant production of the FMRP protein.\nFMRP, a protein that is “most commonly found in the brain, is essential for normal cognitive development and female reproductive function. Mutations of this gene can lead to fragile X syndrome, intellectual disability, premature ovarian failure, autism, Parkinson’s disease, developmental delays and other cognitive deficits.” - from Wikipedia\nMOV10 is a putative RNA helicase that is also associated with FMRP in the context of the microRNA pathway.\n\n\nThe hypothesis the paper is testing is that FMRP and MOV10 associate and regulate the translation of a subset of RNAs.\n\n\n\nOur questions:\n\nWhat patterns of expression can we identify with the loss or gain of MOV10?\nAre there any genes shared between the two conditions?",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#rna-seq-workflow-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#rna-seq-workflow-1",
    "title": "Genomic annotations",
    "section": "RNA-seq workflow",
    "text": "RNA-seq workflow\nFor this dataset, raw sequence reads were obtained from the Sequence Read Archive (SRA). These reads were then processed using the RNA-seq workflow as detailed in the pre-reading for this workshop. All steps were performed on the command line (Linux/Unix), including a thorough quality control assessment. If you are interested, we have the MultiQC html report for this dataset linked here for you to peruse.\nThe directories of output from the mapping/quantification step of the workflow (Salmon) is the data that we will be using. These transcript abundance estimates, often referred to as ‘pseudocounts’, will be the starting point for our differential gene expression analysis.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#setting-up",
    "href": "lessons/01a_RNAseq_processing_workflow.html#setting-up",
    "title": "Genomic annotations",
    "section": "Setting up",
    "text": "Setting up\nLet’s get started by opening up RStudio and setting up a new project for this analysis.\n\nGo to the File menu and select New Project.\nIn the New Project window, choose New Directory. Then, choose New Project. Name your new directory DEanalysis and then “Create the project as subdirectory of:” the Desktop (or location of your choice).\nThe new project should automatically open in RStudio.\n\n\n\n\nTo check whether or not you are in the correct working directory, use getwd(). The path Desktop/DEanalysis should be returned to you in the console. Within your working directory, use the New folder button in the bottom right panel to create three new directories: scripts, meta, and results. Remember the key to a good analysis is keeping organized from the start! (NOTE: we will be downloading our data folder.)\nNow we need to grab the files that we will be working with for the analysis. There are two things we need to download.\n\nFirst we need the Salmon results for the full dataset. Right click on the links below, and choose the “Save link as …” option to download directly into your project directory:\n\n\nSalmon data for the Mov10 full dataset\n\nOnce you have the zip file downloaded you will want to decompress it. This will create a data directory with sub-directories that correspond to each of the samples in our dataset.\n\nNext, we need the annotation file that maps our transcript identifiers to gene identifiers. We have created this file for you using the R Bioconductor package AnnotationHub. For now, we will use it as is, but later in the workshop we will spend some time showing you how to create one for yourself. Right click on the links below, and choose the “Save link as …” option to download directly into the data folder in your project directory.\n\n\nAnnotation file\n\nFinally, go to the File menu and select New File, then select R Script. This should open up a script editor in the top left hand corner. This is where we will be typing and saving all commands required for this analysis. In the script editor, type in header lines:\n# HBC RNA-seq DGE workshop\n# Gene-level differential expression analysis using DESeq2\nNow save the file as de_script.R within the scripts directory. When finished, your project directory should now look similar to this:\n\nFinally, make sure you change working directory to the scripts folder to ensure that all the file paths will be correct when we run our scripts. You can change this by going to the top menu bar and selecting Session &gt; Set Working Directory &gt; To Source File Location (because the script we have open is saved to this folder) or by running the code below in your console:\n#| eval: false\n\n# Make sure we are working from the folder where our script is saved\nsetwd(\"./scripts\")\n\nLoading libraries\nFor this analysis we will be using several R packages, some which have been installed from CRAN and others from Bioconductor. To use these packages (and the functions contained within them), we need to load the libraries. Add the following to your script and don’t forget to comment liberally!\n#| warning: false\n#| message: false\n\n# Setup\n# Bioconductor and CRAN libraries used\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(DEGreport)\nlibrary(tximport)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n\nLoading data\nThe main output of Salmon is a quant.sf file, and we have one of these for each individual sample in our dataset. A screenshot of the file is displayed below:\n\nFor each transcript that was assayed in the reference, we have:\n\nThe transcript identifier\nThe transcript length (in bp)\nThe effective length (described in detail below)\nTPM (transcripts per million), which is computed using the effective length\nThe estimated read count (‘pseudocount’)\n\n\n\n\n\n\n\nWhat exactly is the effective length?\n\n\n\nThe effective length for a transcript is the essentially the number of possible start positions for a read or fragment within that transcript. The sequence composition of a transcript affects how many reads are sampled from it. While two transcripts might be of identical actual length, depending on the sequence composition we are more likely to generate fragments from one versus the other. The transcript that has a higher likelihood of being sampled will end up with the larger effective length. The effective length is transcript length that has been “corrected” to include factors due to sequence-specific and GC biases.\n\n\nWe will be using the R Bioconductor package tximport to prepare the quant.sf files for DESeq2. The first thing we need to do is create a variable that contains the paths to each of our quant.sf files. Then we will add names to our quant files, which will allow us to easily distinguish between samples in the final output matrix.\n# List all directories containing data  \nsamples &lt;- list.files(path = \"../data\", full.names = TRUE, pattern = \"salmon$\")\n\n# Obtain a vector of all filenames including the path\nfiles &lt;- file.path(samples, \"quant.sf\")\n\n# Since all quant files have the same name, it is useful to have names for each element\nnames(files) &lt;- str_replace(samples, \"../data/\", \"\") %&gt;% \n                str_replace(\".salmon\", \"\")\nOur Salmon index was generated with transcript sequences listed by Ensembl IDs, but tximport needs to know which genes these transcripts came from. We will use the annotation table that we downloaded to extract transcript to gene information.\n# Load the annotation table for GrCh38\ntx2gene &lt;- read.delim(\"../data/tx2gene_grch38_ens94.txt\")\n\n# Take a look at it \ntx2gene %&gt;% head()\ntx2gene is a three-column data frame linking transcript ID (column 1) to gene ID (column 2) to gene symbol (column 3). We will take the first two columns as input to tximport. The column names are not relevant, but the column order is (i.e., transcript ID must be first).\nNow we are ready to run tximport.\n#| eval: false\n\n?tximport # let's take a look at the arguments for the tximport function\nThe tximport() function imports transcript-level estimates from various external software (e.g., Salmon, Kallisto) and summarizes to the gene-level (default) or outputs transcript-level matrices. There are optional arguments to use the abundance estimates as they appear in the quant.sf files or to calculate alternative values.\nFor our analysis we need non-normalized or “raw” count estimates at the gene-level for performing DESeq2 analysis.\nSince the gene-level count matrix is a default (txOut=FALSE) there is only one additional argument for us to modify to specify how to obtain our “raw” count values. The options for countsFromAbundance are as follows:\n\nno (default): This will take the values in TPM (as our scaled values) and NumReads (as our “raw” counts) columns, and collapse it down to the gene-level.\nscaledTPM: This is taking the TPM scaled up to library size as our “raw” counts.\nlengthScaledTPM: This is used to generate the “raw” count table from the TPM (rather than summarizing the NumReads column). “Raw” count values are generated by using the TPM value x featureLength x library size. These represent quantities that are on the same scale as original counts, except no longer correlated with transcript length across samples.\n\n\n\n\n\n\n\nLet’s review how TPM values are calculated:\n\n\n\n\nDivide the read counts by the length of each gene in kilobases. This gives you reads per kilobase (RPK).\nCount up all the RPK values in a sample and divide this number by 1,000,000. This is your “per million” scaling factor.\nDivide the RPK values by the “per million” scaling factor. This gives you TPM.\n\n\n\n# Run tximport\ntxi &lt;- tximport(files, type = \"salmon\", tx2gene = tx2gene[,c(\"tx_id\", \"ensgene\")],\n                countsFromAbundance = \"lengthScaledTPM\")\n\n\n\n\n\n\nAn additional argument for tximport\n\n\n\nWhen performing your own analysis, you may find that the reference transcriptome file you obtain from Ensembl will have version numbers included on your identifiers (i.e., ENSG00000265439.2). This will cause a discrepancy with the tx2gene file, since the annotation databases don’t usually contain version numbers (i.e., ENSG00000265439). To get around this issue you can use the argument ignoreTxVersion = TRUE. The logical value indicates whether to split the tx id on the ‘.’ character to remove version information, for easier matching.\n\n\n\n\nViewing data\nThe txi object is a simple list containing matrices of the abundance, counts, and length. Another list element ‘countsFromAbundance’ carries through the character argument used in the tximport call. The length matrix contains the average transcript length for each gene, which can be used as an offset for gene-level analysis.\nattributes(txi)\nWe will be using the txi object as is for input into DESeq2, but will save it until the next lesson. For now let’s take a look at the count matrix. You will notice that there are decimal values, so let’s round to the nearest whole number and convert it into a dataframe. We will save it to a variable called data that we can play with.\n# Look at the counts\ntxi$counts %&gt;% head()\n# Write the counts to an object\ndata &lt;- txi$counts %&gt;% \n  round() %&gt;% \n  data.frame()\n\n\n\n\n\n\nWhat if I don’t have Salmon pseudocounts as input?\n\n\n\nUntil recently, the standard approach for RNA-seq analysis had been to map our reads using a splice-aware aligner (e.g., STAR) and then use the resulting BAM files as input to counting tools like featureCounts and htseq-count to obtain our final expression matrix. The field has now moved towards using lightweight alignment tools like Salmon as standard practice. If you are still working with data generated using the older standard approach we have some materials linked here on using DESeq2 with a raw count matrix as your starting point.\n\n\n\n\nCreating metadata\nOf great importance is keeping track of the information about our data. At minimum, we need to at least have a file which maps our samples to the corresponding sample groups that we are investigating. We will use the column headers from the counts matrix as the row names of our metadata file and have a single column to identify each sample as “MOV10_overexpression”, “MOV10_knockdown”, or “control”.\n# Create a sample table / metadata\nsampletype &lt;- factor(c(rep(\"control\",              3),\n                       rep(\"MOV10_knockdown\",      2),\n                       rep(\"MOV10_overexpression\", 3)))\nmeta &lt;- data.frame(sampletype, row.names = colnames(txi$counts))\nNow we are all set to start our analysis!\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(data, \"../data/intermediate_txi_counts.RDS\")\nsaveRDS(txi,  \"../data/intermediate_txi.RDS\")\nsaveRDS(meta, \"../data/metadata.RDS\")\n\nNext Lesson\n\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(ggplot2)\n\n# load objects needed to render this lesson\ndata &lt;- readRDS(\"../data/intermediate_txi_counts.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-2",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the characteristics of RNA-seq count data\nCompare different mathematical models for count data\nIdentify the most appropriate model for RNA-seq count data\nExplain the benefits of biological replicates for identifying true differences between sample groups",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#count-matrix",
    "href": "lessons/01a_RNAseq_processing_workflow.html#count-matrix",
    "title": "Genomic annotations",
    "section": "Count matrix",
    "text": "Count matrix\nWhen we start our differential gene expression analysis we begin with a matrix summarizing the gene-level expression in each sample of your dataset. The rows in the matrix correspond to genes, and the columns correspond to samples. In each position of the matrix you will have an integer value representing the total number of sequence reads that originated from a particular gene in a sample.\n\n\n\nThe higher the number of counts indicates more reads are associated with that gene and suggests a higher level of expression of that gene. However, this is not necessarily true and we will delve deeper into this later in this lesson and in the course.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#characteristics-of-rna-seq-count-data",
    "href": "lessons/01a_RNAseq_processing_workflow.html#characteristics-of-rna-seq-count-data",
    "title": "Genomic annotations",
    "section": "Characteristics of RNA-seq count data",
    "text": "Characteristics of RNA-seq count data\nTo get an idea about how RNA-seq counts are distributed, let’s plot a histogram of the counts for a single sample, ‘Mov10_oe_1’:\n# Plot the distribution of counts for Mov10_oe_1\nggplot(data) +\n  geom_histogram(aes(x = Mov10_oe_1), stat = \"bin\", bins = 200) +\n  xlab(\"Raw expression counts\") +\n  ylab(\"Number of genes\")\nThis plot illustrates some common features of RNA-seq count data:\n\na low number of counts associated with a large proportion of genes\na long right tail due to the lack of any upper limit for expression\nlarge dynamic range\n\nLooking at the shape of the histogram, we see that it is not normally distributed. For RNA-seq data this will always be the case. Moreover, the underlying data, as we observed earlier, is integer counts instead rather than continuous measurements. We need to take these characteristics into account when deciding on what statistical model to use.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#modeling-count-data",
    "href": "lessons/01a_RNAseq_processing_workflow.html#modeling-count-data",
    "title": "Genomic annotations",
    "section": "Modeling count data",
    "text": "Modeling count data\nCount data in general can be modeled with various distributions:\n\nBinomial distribution: Gives you the probability of getting a number of heads upon tossing a coin a number of times. Based on discrete events and used in situations when you have a certain number of cases. Thus, it gives the probability of getting r events out of n trials.\nPoisson distribution: For use when the number of cases is very large (i.e., people who buy lottery tickets), but the probability of an event is very small (probability of winning). The Poisson is similar to the binomial as it is also based on discrete events, but used with data from an infinite sample. Thus it gives the probability of getting r events in a population. It is appropriate for data where mean == variance.\n\n\n\n\n\n\n\nNote\n\n\n\nDetails provided by Rafael Irizarry in the EdX class.\n\n\nSo what do we use for RNA-seq count data?\nWith RNA-Seq data, a very large number of RNAs are represented and the probability of pulling out a particular transcript is very small. This scenario is most similar to the lottery described above, suggesting that perhaps the Poisson distribution is most appropriate. However, this will depend on the relationship between mean and variance in our data.\n\nMean versus variance\nTo assess the properties of the data we are working with, we can use the three samples corresponding to the ‘Mov10 overexpression’ replicates. First compute a vector of mean values, then compute a vector of variance values. Finally, plot these values against each other to evaluate the relationship between them.\n# Calculate the mean and variance for each gene for the Mov10 overexpression replicates\n# The second argument '1' of 'apply' function indicates the function being applied to rows\n#     Use '2' if applied to columns\nmean_counts &lt;- apply(data[,6:8], 1, mean) \nvariance_counts &lt;- apply(data[,6:8], 1, var)\ndf &lt;- data.frame(mean_counts, variance_counts)\nYour plot should look like the scatterplot below. Each data point represents a gene and the red line represents x = y.\n# Plot the mean vs variance\nggplot(df) +\n  geom_point(aes(x = mean_counts, y = variance_counts)) + \n  scale_y_log10(limits = c(1,1e9)) +\n  scale_x_log10(limits = c(1,1e9)) +\n  # Add a line for x = y (slope = 1)\n  geom_abline(intercept = 0, slope = 1, color = \"red\")\n\nThe mean is not equal to the variance (the scatter of data points does not fall on the diagonal).\nFor the genes with high mean expression, the variance across replicates tends to be greater than the mean (scatter is above the red line).\nFor the genes with low mean expression we see quite a bit of scatter. We usually refer to this as “heteroscedasticity”. That is, for a given expression level in the low range we observe a lot of variability in the variance values.\n\n\n\n\n\n\n\nExercise\n\n\n\nEvaluate the relationship between mean and variance for the control replicates (Irrel_kd samples). Note the differences or similarities in the plot compared to the one using the overexpression replicates.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#an-alternative-the-negative-binomial-distribution",
    "href": "lessons/01a_RNAseq_processing_workflow.html#an-alternative-the-negative-binomial-distribution",
    "title": "Genomic annotations",
    "section": "An alternative: The Negative Binomial distribution",
    "text": "An alternative: The Negative Binomial distribution\nOur data fail to satisfy the criteria for a the Poisson distribution, and typical RNA-seq data will do the same. If the proportions of mRNA stayed exactly constant between the biological replicates for a sample group, we could expect a Poisson distribution (where mean == variance). However, we always expect some amount of variability between replicates (we’ll discuss this in more detail later in the lesson). Alternatively, if we continued to add more replicates (i.e., &gt; 20) we should eventually see the scatter start to reduce and the high expression data points move closer to the red line. So, in theory, if we had enough replicates we could use the Poisson.\nIn practice, a large number of replicates can be either hard to obtain (depending on how samples are obtained) and/or can be unaffordable. It is more common to see datasets with only a handful of replicates (~3-5) and reasonable amount of variation between them. The distribution that fits RNA-seq data best, given this type of variability between replicates, is the Negative Binomial. Essentially, the Negative Binomial is a good approximation for data where the mean &lt; variance, as is the case with RNA-Seq count data.\n\n\n\n\n\n\nNote\n\n\n\nIf we use the Poisson, this will underestimate variability, leading to an increase in false positive DE genes.\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nAn RNA-seq experiment was conducted on mice forebrain to evaluate the effect of increasing concentrations of a treatment. For each of the five different concentrations we have n = 5 mice, for a total of 25 samples. If we observed little to no variability between replicates, what might this suggest about our samples?\nWhat type of mean-variance relationship would you expect to see for this dataset?",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#replicates-and-variability",
    "href": "lessons/01a_RNAseq_processing_workflow.html#replicates-and-variability",
    "title": "Genomic annotations",
    "section": "Replicates and variability",
    "text": "Replicates and variability\nBiological replicates represent multiple samples (e.g., RNA from different mice) that correspond to the same sample class or group. Intuitively, we would expect samples from the same sample group (i.e., that are under similar conditions/perturbations) to exhibit a similar transcriptional profile. In most cases, there will be a high degree of similarity of samples within a group but there will also inevitably be many differences. The source of this variability on a gene’s expression can be attributed to many factors, some of which are identifiable and others that remain unknown.\n\n\n\nWith differential expression analysis, we are looking for genes that change in expression between two or more groups. For example,\n\ncase vs. control\ncorrelation of expression with some variable or clinical outcome\n\nHowever, there is much more going on with your data than what you are anticipating. Genes that vary in expression level is a consequence of not only the experimental variable(s) of interest but also due to extraneous sources. The goal of differential expression analysis is to identify and correct for sources of variation such that we can separate the “interesting” from the “uninteresting”.\nLet’s take a closer look at the figure below as an example. Expression (counts) is plotted here for ‘GeneA’ in the ‘untreated’ and ‘treated’ groups. Each dot corresponds to expression for a single sample, and the dots are colored based on which group they belong to.\n\n\n\nThe mean expression level of GeneA for the ‘treated’ group is twice as large as the mean expression level for the ‘untreated’ group. But is the difference in expression between groups significant given the amount of variation observed within groups (across replicates)?\nIt is possible that the difference is not actually significant. We need to take into account the variation in the data (and where it might be coming from) when determining whether genes are differentially expressed. Modeling our data with the negative binomial distribution allows us to do this.\n\nHow many replicates are enough?\nMore is always better! At minimum we recommend three replicates for each sample group, but if you can increase that by any number it is in your best interest. The value of additional replicates is that as you add more data, you get increasingly precise estimates of group means, and ultimately greater confidence in the ability to reliably distinguish differences between sample classes.\nHaving many replicates allow us to:\n\nestimate variation for each gene\nrandomize out unknown covariates\nspot outliers\nimprove precision of expression and fold-change estimates\n\nThe figure below is taken from a study directly evaluating the relationship between sequencing depth and number of replicates on the number of differentially expressed genes [1].\n\n\n\nNote that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#differential-expression-with-deseq2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#differential-expression-with-deseq2",
    "title": "Genomic annotations",
    "section": "Differential expression with DESeq2",
    "text": "Differential expression with DESeq2\nDESeq2 is a popular tool for gene-level differential expression analysis. It uses the negative binomial distribution, employing a slightly more stringent approach compared to some methods yet having a good balance between sensitivity and specificity (reducing both false positives and false negatives).\n\n\n\n\n\n\nOther tools for Differential Expression Analysis\n\n\n\nThere are a number of software packages that have been developed for differential expression analysis of RNA-seq data. Most adopt the negative binomial approach; however, there are other tools based on non-parametric methods suitable for larger sample sizes. An extensive comparison of these methods can be found in Soneson and Dleorenzi, 2013.\n\n\nWe will be using DESeq2 for the analysis in this workshop. The analysis steps with DESeq2 are shown in the flowchart below in green and blue.\n\n\n\nWe will go in-depth into each of these steps in the following lessons, but additional details and helpful suggestions regarding DESeq2 can be found in the DESeq2 vignette.\n\nNext Lesson\n\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(ggplot2)\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\ntxi  &lt;- readRDS(\"../data/intermediate_txi.RDS\")\nmeta &lt;- readRDS(\"../data/metadata.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-3",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-3",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nList different “uninteresting factors” considered during normalization\nDescribe some common normalization methods and recommendations for its use\nCreate a DESeqDataSet object and discuss the structure of the object\nDemonstrate how to normalize counts using DESeq2",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#normalization",
    "href": "lessons/01a_RNAseq_processing_workflow.html#normalization",
    "title": "Genomic annotations",
    "section": "Normalization",
    "text": "Normalization\nThe first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples.\n\nThe counts of mapped reads for each gene is the result of RNA expression (“interesting” part) in addition to many other factors (“uninteresting” part). Normalization is the process of adjusting raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples.\nThe main “uninteresting” factors often considered during normalization are:\n\nSequencing depth: Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have twice the expression in Sample A relative to Sample B. However, this is the consequence of Sample A having doubled sequencing depth.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the figure above, each pink and green rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron.\n\n\n\nGene length: Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example below, Gene X and Gene Y have similar levels of expression, but the number of reads mapped to Gene X would be many more than the number mapped to Gene Y because Gene X is longer.\n\nRNA composition: A few highly differentially expressed genes between samples, differences in the number of genes expressed between samples, or presence of contamination can skew some types of normalization methods. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses [1].\nIn the example below, imagine the sequencing depths are similar between Sample A and Sample B, and every gene except for gene DE presents similar expression level between samples. The counts in Sample B would be greatly skewed by the DE gene, which takes up most of the counts. Other genes for Sample B would therefore appear to be less expressed than those same genes in Sample A.\n\n\nWhile normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples.\n\nCommon normalization methods\nSeveral common normalization methods have been developed to account for these differences:\n\n\n\nNormalization method\nDescription\nAccounted factors\nRecommendations for use\n\n\n\n\nCPM (counts per million)\ncounts scaled by total number of reads\nsequencing depth\ngene count comparisons between replicates of the same sample group; NOT for within sample comparisons or DE analysis\n\n\nTPM (transcripts per kilobase million)\ncounts per length of transcript (kb) per million reads mapped\nsequencing depth and gene length\ngene count comparisons within a sample or between samples of the same sample group; NOT for DE analysis\n\n\nRPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped)\nsimilar to TPM\nsequencing depth and gene length\ngene count comparisons between genes within a sample; NOT for between sample comparisons or DE analysis\n\n\nDESeq2’s median of ratios [1]\ncounts divided by sample-specific size factors determined by median ratio of gene counts relative to geometric mean per gene\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\nEdgeR’s trimmed mean of M values (TMM) [2]\nuses a weighted trimmed mean of the log expression ratios between samples\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\n\n\n\nRPKM/FPKM: not recommended for between sample comparisons\nWhile TPM and RPKM/FPKM normalization methods both account for sequencing depth and gene length, RPKM/FPKM are not recommended. The reason is that the normalized count values output by the RPKM/FPKM method are not comparable between samples.\nUsing RPKM/FPKM normalization, the total number of RPKM/FPKM normalized counts for each sample will be different. Therefore, you cannot compare the normalized counts for each gene equally between samples.\nRPKM-normalized counts table\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nXCR1\n5.5\n5.5\n\n\nWASHC1\n73.4\n21.8\n\n\n…\n…\n…\n\n\nTotal RPKM-normalized counts\n1,000,000\n1,500,000\n\n\n\nFor example, in the table above, sampleA has a greater proportion of counts associated with XCR1 (5.5/1,000,000) than sampleB (5.5/1,500,000), even though the RPKM count values are the same. Therefore, we cannot directly compare the counts for XCR1 (or any other gene) between sampleA and sampleB, because the total number of normalized counts are different between samples.\n\n\n\n\n\n\nNote\n\n\n\nThis video by StatQuest shows in more detail why TPM should be used in place of RPKM/FPKM if needing to normalize for sequencing depth and gene length.\n\n\n\n\nDESeq2-normalized counts: Median of ratios method\nSince tools for differential expression analysis are comparing the counts of the same gene between sample groups, gene length does not need to be accounted for by the tool. However, sequencing depth and RNA composition do need to be taken into account.\nTo normalize for sequencing depth and RNA composition, DESeq2 uses the median of ratios method. On the user-end there is only one step, but on the back-end there are multiple steps involved, as described below.\n\n\n\n\n\n\nNote\n\n\n\nThe steps below describe in detail some of the steps performed by DESeq2 when you run a single function to get DE genes. Basically, for a typical RNA-seq analysis, you would not run these steps individually.\n\n\nStep 1: creates a pseudo-reference sample (row-wise geometric mean)\nFor each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples.\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\n\n\n\n\nEF2A\n1489\n906\nsqrt(1489 * 906) = 1161.5\n\n\nABCD1\n22\n13\nsqrt(22 * 13) = 17.7\n\n\n…\n…\n…\n…\n\n\n\nStep 2: calculates ratio of each sample to the reference\nFor every gene in every sample, the ratios (sample/ref) are calculated (as shown below). Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample.\n\n\n\n\n\n\n\n\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\nratio of sampleA/ref\nratio of sampleB/ref\n\n\n\n\nEF2A\n1489\n906\n1161.5\n1489/1161.5 = 1.28\n906/1161.5 = 0.78\n\n\nABCD1\n22\n13\n16.9\n22/16.9 = 1.30\n13/16.9 = 0.77\n\n\nMEFV\n793\n410\n570.2\n793/570.2 = 1.39\n410/570.2 = 0.72\n\n\nBAG1\n76\n42\n56.5\n76/56.5 = 1.35\n42/56.5 = 0.74\n\n\nMOV10\n521\n1196\n883.7\n521/883.7 = 0.590\n1196/883.7 = 1.35\n\n\n…\n…\n…\n…\n\n\n\n\n\nStep 3: calculate the normalization factor for each sample (size factor)\nThe median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value:\nnormalization_factor_sampleA &lt;- median(c(1.28, 1.3, 1.39, 1.35, 0.59))\nnormalization_factor_sampleB &lt;- median(c(0.78, 0.77, 0.72, 0.74, 1.35))\nThe figure below illustrates the median value for the distribution of all gene ratios for a single sample (y-axis is the frequency).\n\nThe median of ratios method makes the assumption that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not affect the median ratio values). This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes.\n\n\n\n\n\n\nNote\n\n\n\nUsually these size factors are around 1. If you see large variations between samples, it is important to take note as it might indicate the presence of extreme outliers.\n\n\nStep 4: calculate the normalized count values using the normalization factor\nThis is performed by dividing each raw count value in a given sample by that sample’s normalization factor, generating normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for sampleA was 1.3 and the median ratio for sampleB was 0.77, you could calculate normalized counts as follows:\nRaw Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489\n906\n\n\nABCD1\n22\n13\n\n\n…\n…\n…\n\n\n\nNormalized Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489 / 1.3 = 1145.39\n906 / 0.77 = 1176.62\n\n\nABCD1\n22 / 1.3 = 16.92\n13 / 0.77 = 16.88\n\n\n…\n…\n…\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPlease note that normalized count values are not whole numbers.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#count-normalization-of-mov10-dataset-using-deseq2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#count-normalization-of-mov10-dataset-using-deseq2",
    "title": "Genomic annotations",
    "section": "Count normalization of Mov10 dataset using DESeq2",
    "text": "Count normalization of Mov10 dataset using DESeq2\nNow that we know the theory of count normalization, we will normalize the counts for the Mov10 dataset using DESeq2. This requires a few steps:\n\nEnsure that the row names of the metadata dataframe are present and are in the same order as the column names of the counts dataframe.\nCreate a DESeqDataSet object\nGenerate the normalized counts\n\n\n1. Match the metadata and counts data\nWe should always make sure that we have sample names that match between the two files, and that the samples are in the same order. DESeq2 will output an error if this is not the case.\n# Check that sample names match in both files\nall(colnames(txi$counts) %in% rownames(meta))\nall(colnames(txi$counts) == rownames(meta))\nIf your data does not match, you could use the match() function to rearrange them.\n\n\n\n\n\n\nExercise\n\n\n\nSuppose we have sample names matching in the counts matrix and metadata file, but they are in different order. Write the line(s) of code to create a new matrix with columns re-ordered such that they are identical to the row names of the metadata.\n\n\n\n\n2. Create DESEq2 object\nBioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also results). These custom data structures are similar to lists in that they can contain multiple different data types/structures. But unlike lists, they have pre-specified data slots, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions.\nLet’s start by creating the DESeqDataSet object, and then we can talk a bit more about what is stored inside it. To create the object, we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have one column we are interested in, which is ~sampletype. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels.\nOur count matrix input is stored in the txi list object. So we need to specify that using the DESeqDataSetFromTximport() function, which will extract the counts component and round the values to the nearest whole number.\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n\n\n\n\n\nNote\n\n\n\nSince we had created a data variable in the last lesson that contains the counts, we could have also used that as input. However, in that case we would want to use the DESeqDataSetFromMatrix() function.\n\n\n\n\n\nDESeq2 object structure\n\n\nYou can use DESeq-specific functions to access the different slots and retrieve information. For example, suppose we want to retrieve the original count matrix, we would use counts() function (Note: we nest it within the head() function so that we can see just the first few lines of the matrix. You could also use the View() function to view the result in the script editor rather than in the console):\nhead(counts(dds))\nAs we go through the workflow, we will use relevant functions to check what information is stored inside our object.\n\n\n3. Generate the Mov10 normalized counts\nThe next step is to normalize the count data in order to make fair gene comparisons between samples.\n\nTo perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors. We will demonstrate this function in the example below, but in a typical RNA-seq analysis, this step is automatically performed by the DESeq() function, which we will discuss later.\n# Estimate size factors\ndds &lt;- estimateSizeFactors(dds)\nBy assigning the results back to the dds object, we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factors of each sample using:\n# Look at size factors\nsizeFactors(dds)\nNow, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE.\n# Get normalized counts matrix\nnormalized_counts &lt;- counts(dds, normalized=TRUE)\nWe can save this normalized data matrix to file for later use:\n# Save normalized counts matrix\nwrite.table(normalized_counts, file=\"../data/normalized_counts.txt\", sep=\"\\t\", quote=FALSE, col.names=NA)\n\n\n\n\n\n\nNote\n\n\n\nDESeq2 doesn’t actually use normalized counts; rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that perform differential expression analysis that use the negative binomial model.\n\n\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(dds, \"../data/intermediate_dds.RDS\")\n\nNext Lesson\n\nApproximate time: 80 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(ggplot2)\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\ndds  &lt;- readRDS(\"../data/intermediate_dds.RDS\")\nmeta &lt;- readRDS(\"../data/metadata.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-4",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-4",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nRecognize the importance of methods for count data transformation\nDescribe the PCA (principal component analysis) technique\nInterpret different examples of PCA plots\nEvaluate sample quality using PCA and hierachical clustering",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#sample-level-qc",
    "href": "lessons/01a_RNAseq_processing_workflow.html#sample-level-qc",
    "title": "Genomic annotations",
    "section": "Sample-level QC",
    "text": "Sample-level QC\nA useful initial step in an RNA-seq analysis is often to assess overall similarity between samples:\n\nWhich samples are similar to each other, which are different?\nDoes this fit to the expectation from the experiment’s design?\nWhat are the major sources of variation in the dataset?\n\nTo explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. These methods/tools allow us to check how well similar the replicates are to each other (clustering) and to make sure that the experimental condition is the major source of variation in the data. Sample-level QC can also help identify any samples behaving like outliers; we can further explore any potential outliers to determine whether they need to be removed prior to DE analysis.\n\n\n\nThese unsupervised clustering methods are run using log2 transformed normalized counts. The log2 transformation improves the distances/clustering for visualization. Instead of using an ordinary log2 transform, we will be using regularized log transform (rlog), to avoid any bias from the abundance of low-count genes; Note 1 below explains this in more detail.\n\n\n\nImage adapted from “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014\n\n\n\n\n\n\nNote 1\n\n\n\n“Many common statistical methods for exploratory analysis of multidimensional data, especially methods for clustering and ordination (e.g., principal-component analysis and the like), work best for (at least approximately) homoskedastic data; this means that the variance of an observable quantity (i.e., here, the expression strength of a gene) does not depend on the mean. In RNA-seq data, however, variance grows with the mean. For example, if one performs PCA directly on a matrix of normalized read counts, the result typically depends only on the few most strongly expressed genes because they show the largest absolute differences between samples. A simple and often used strategy to avoid this is to take the logarithm of the normalized count values plus a small pseudocount; however, now the genes with low counts tend to dominate the results because, due to the strong Poisson noise inherent to small count values, they show the strongest relative differences between samples.\nAs a solution, DESeq2 offers the regularized-logarithm transformation, or rlog for short. For genes with high counts, the rlog transformation differs not much from an ordinary log2 transformation. For genes with lower counts, however, the values are shrunken towards the genes’ averages across all samples. Using an empirical Bayesian prior in the form of a ridge penality, this is done such that the rlog-transformed data are approximately homoskedastic.” - From the “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014 (the DESeq2 vignette is the updated version of this doc).\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe DESeq2 vignette suggests large datasets (100s of samples) to use the variance-stabilizing transformation (vst) instead of rlog for transformation of the counts, since the rlog function might take too long to run and the vst() function is faster with similar properties to rlog.\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). This is a very important technique used in the QC and analysis of both bulk and single-cell RNAseq data.\nTo better understand how it works, please go through this YouTube video from StatQuest that explains PCA. Alternatively, we have prepared a PCA lesson. After you have gone through the material, please proceed with the interpretation section below.\n\n\nInterpreting PCA plots\nEssentially, if two samples have similar levels of expression for the genes that contribute significantly to the variation represented by a given PC (Principal Component), they will be plotted close together on the axis that represents that PC. Therefore, we would expect that biological replicates to have similar scores (because our expectation is that the same genes are changing) and cluster together. This is easiest to understand by visualizing some example PCA plots.\nWe have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment.\n\n\n\nWhen visualizing on PC1 and PC2, we don’t see the samples separate by treatment, so we decide to explore other sources of variation present in the data. We hope that we have included all possible known sources of variation in our metadata table, and we can use these factors to color the PCA plot.\n\n\n\nWe start with the factor cage, but the cage factor does not seem to explain the variation on PC1 or PC2.\n\n\n\nThen, we color by the sex factor, which appears to separate samples on PC2. This is good information to take note of, as we can use it downstream to account for the variation due to sex in the model and regress it out.\n\n\n\nNext we explore the strain factor and find that it explains the variation on PC1.\n\n\n\nIt’s great that we have been able to identify the sources of variation for both PC1 and PC2. By accounting for it in our model, we should be able to detect more genes differentially expressed due to treatment.\nWorrisome about this plot is that we see two samples that do not cluster with the correct strain. This would indicate a likely sample swap and should be investigated to determine whether these samples are indeed the labeled strains. If we found there was a switch, we could swap the samples in the metadata. However, if we think they are labeled correctly or are unsure, we could just remove the samples from the dataset.\nStill we haven’t found if treatment is a major source of variation after strain and sex. So, we explore PC3 and PC4 to see if treatment is driving the variation represented by either of these PCs.\n\n\n\nWe find that the samples separate by treatment on PC3, and are optimistic about our DE analysis since our condition of interest, treatment, is separating on PC3 and we can regress out the variation driving PC1 and PC2.\nDepending on how much variation is explained by the first few principal components, you may want to explore more (i.e., consider more components and plot pairwise combinations). Even if your samples do not separate clearly by the experimental variable, you may still get biologically relevant results from the DE analysis. If you are expecting very small effect sizes, then it’s possible the signal is drowned out by extraneous sources of variation. In situations where you can identify those sources, it is important to account for these in your model, as it provides more power to the tool for detecting DE genes.\n\n\n\nHierarchical Clustering Heatmap\nSimilar to PCA, hierarchical clustering is another, complementary, method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.\nThe hierarchical tree along the axes indicates which samples are more similar to each other, i.e., cluster together. The color blocks at the top indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Our expectation would be that the samples cluster together similar to the groupings we’ve observed in the PCA plot.\nIn the plot below, we would be quite concerned about ‘Wt_3’ and ‘KD_3’ samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "title": "Genomic annotations",
    "section": "Mov10 quality assessment and exploratory analysis using DESeq2",
    "text": "Mov10 quality assessment and exploratory analysis using DESeq2\nNow that we have a good understanding of the QC steps normally employed for RNA-seq, let’s implement them for the Mov10 dataset we are going to be working with.\n\nTransform normalized counts for the MOV10 dataset\nTo improve the distances/clustering for the PCA and hierarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these transformed counts for determining differential expression.\n\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\nThe blind=TRUE argument is to make sure that the rlog() function does not take our sample groups into account - i.e., does the transformation in an unbiased manner. When performing quality assessment, it is important to include this option. The DESeq2 vignette has more details about this.\nThe rlog() function returns a DESeqTransform object, another type of DESeq-specific object. The reason you don’t just get a matrix of transformed values is because all of the parameters (e.g., size factors) that went into computing the rlog transform are stored in that object. We use this object to plot the PCA and hierarchical clustering figures for quality assessment.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog() funtion can be a bit slow when you have &gt; ~20 samples. In these situations the vst() function is much faster and performs a similar transformation appropriate for use with plotPCA(). It’s typically just a few seconds with vst() due to optimizations and the nature of the transformation.\n\n\n\n\nPrincipal component analysis (PCA) for the MOV10 dataset\nWe are now ready for the QC steps, let’s start with PCA!\nDESeq2 has a built-in function for generating PCA plots using ggplot2 under the hood. This is great because it saves us having to type out lines of code and having to fiddle with the different ggplot2 layers. In addition, it takes the rlog object as an input directly, hence saving us the trouble of extracting the relevant information from it.\nThe function plotPCA() requires two arguments as input: a DESeqTransform object and the “intgroup” (interesting group), i.e., the name of the column in our metadata that has information about the experimental sample groups.\n# Plot PCA \nplotPCA(rld, intgroup=\"sampletype\")\n\n\n\n\n\n\nExercise\n\n\n\n\nWhat does the above plot tell you about the similarity of samples?\nDoes it fit the expectation from the experimental design?\nWhat do you think the %variance information (in the axes titles) tell you about the data in the context of the PCA?\n\n\n\nBy default plotPCA() uses the top 500 most variable genes. You can change this by adding the ntop= argument and specifying how many of the genes you want the function to consider.\n\n\n\n\n\n\nNote\n\n\n\nThe plotPCA() function will only return the values for PC1 and PC2. If you would like to explore the additional PCs in your data or if you would like to identify genes that contribute most to the PCs, you can use the prcomp() function. For example, to plot any of the PCs we could run the following code:\n# Input is a matrix of log transformed values\nrld &lt;- rlog(dds, blind=T)\nrld_mat &lt;- assay(rld)\npca &lt;- prcomp(t(rld_mat))\n\n# Create data frame with metadata and PC3 and PC4 values for input to ggplot\ndf &lt;- cbind(meta, pca$x)\nggplot(df) + geom_point(aes(x=PC3, y=PC4, color = sampletype))\nResources are available to learn how to do more complex inquiries using the PCs.\n\n\n\n\nHierarchical Clustering for the MOV10 dataset\nThere is no built-in function in DESeq2 for plotting the heatmap for displaying the pairwise correlation between all the samples and the hierarchical clustering information; we will use the pheatmap() function from the pheatmap package. This function cannot use the DESeqTransform object as input, but requires a matrix or dataframe. So, the first thing to do is retrieve that information from the rld object using a function called assay() (from the SummarizedExperiment package) that converts the data in a DESeqTransform object to a simple 2-dimensional data structure (a matrix in this case).\n# Extract the rlog matrix from the object\n# \"assay()\" is part of the \"SummarizedExperiment\" package, which is a DESeq2 dependency and is loaded with the DESeq2 library\nrld_mat &lt;- assay(rld)\nNext, we need to compute the pairwise correlation values for all the samples. We can do this using the cor() function:\n# Compute pairwise correlation values\n# cor() is a base R function\nrld_cor &lt;- cor(rld_mat)\nLet’s take a look at the column and row names of the correlation matrix.\n# Check the output of cor(), make note of the row names and column names\nhead(rld_cor)\nhead(meta)\nYou will notice that they match the names we have given our samples in the metadata data frame we started with. It is important that these match, so we can use the annotation argument below to plot a color block across the top. This block enables easy visualization of the hierarchical clustering.\nLet’s plot the heatmap!\nWhen you plot using pheatmap(), the hierarchical clustering information is used to place similar samples together and this information is represented by the tree structure along the axes. The annotation argument accepts a dataframe as input; in our case it is the meta dataframe.\n# Load pheatmap package\nlibrary(pheatmap)\n\n# Plot heatmap using the correlation matrix and the metadata object\npheatmap(rld_cor, annotation = meta)\nOverall, we observe pretty high correlations across the board (&gt; 0.999) suggesting no outlying sample(s). Also, similar to the PCA plot, you see the samples clustering together by sample group. Together, these plots suggest to us that the data are of good quality and we have the green light to proceed to differential expression analysis.\n\n\n\n\n\n\nNote\n\n\n\nThe pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot.\nheat.colors &lt;- RColorBrewer::brewer.pal(6, \"Blues\")\npheatmap(rld_cor, annotation = meta, color = heat.colors,\n         border_color = NA, fontsize = 10, fontsize_row = 10, height=20)\nCurious about all of the available color palettes offered by the RColorBrewer package? Try typing in your console display.brewer.all() and see what happens!\n\n\n\nNext Lesson\n\nApproximate time: 30 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(DESeq2)\n\n# load or re-create objects needed to render this lesson\ntxi  &lt;- readRDS(\"../data/intermediate_txi.RDS\")\nmeta &lt;- readRDS(\"../data/metadata.RDS\")\nsampletype &lt;- meta$sampletype",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-5",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-5",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDemonstrate the use of the design formula with simple and complex designs\nConstruct R code to execute the differential expression analysis workflow with DESeq2",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#running-deseq2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#running-deseq2",
    "title": "Genomic annotations",
    "section": "Running DESeq2",
    "text": "Running DESeq2\nPrior to performing the differential expression analysis, it is a good idea to know what sources of variation are present in your data, either by exploration during the QC and/or prior knowledge. Once you know the major sources of variation, you can remove them prior to analysis or control for them in the statistical model by including them in your design formula.\nThis step is critical as each additional factor in your design formula reduces your power. HOWEVER, failing to include important sources of variation can give you inaccurate results.\n\nDesign formula\nA design formula tells the statistical software which sources of variation to test for. This includes both your factor of interest as well as any additional covariates that are sources of variation. For example, if you know that sex is a significant source of variation in your data, then sex should be included in your model. The design formula should have all of the factors in your metadata that account for major sources of variation in your data.\nFor example, suppose you have the following metadata:\n\n\n\nIf you want to examine the expression differences between treatments, and you know that major sources of variation include sex and age, then your design formula would be:\ndesign = ~ sex + age + treatment\nThe tilde (~) should always precede your factors and tells DESeq2 to model the counts using the following formula. Note the factors included in the design formula need to match the column names in the metadata.\n\n\n\n\n\n\nDoes the order of variables matter?\n\n\n\nIn short, the order of variables in your design formula will not change the final results (i.e., the coefficients returned are the always the same). Typically, it has been best practice to list the variable that is your main effect in the last position of your design formula. In this way, the default result that is returned to you when using the results() function will be for your main effect.\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\nSuppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written?\nBased on our Mov10 metadata dataframe, which factors could we include in our design formula?\nWhat would you do if you wanted to include a factor in your design formula that is not in your metadata?\n\n\n\n\nComplex designs\nDESeq2 also allows for the analysis of complex designs. You can explore interactions or ‘the difference of differences’ by specifying for it in the design formula. For example, if you wanted to explore the effect of sex on the treatment effect, you could specify for it in the design formula as follows:\ndesign = ~ sex + age + treatment + sex:treatment\nThere are additional recommendations for complex designs in the DESeq2 vignette. In addition, Limma documentation offers additional insight into creating more complex design formulas.\n\n\n\n\n\n\nNote\n\n\n\nNeed help figuring out what information should be present in your metadata? We have additional materials highlighting bulk RNA-seq planning considerations. Please take a look at these materials before starting an experiment to help with proper experimental design.\n\n\n\n\n\nMOV10 DE analysis\nNow that we know how to specify the model to DESeq2, we can run the differential expression pipeline on the raw counts.\nTo get our differential expression results from our raw count data, we only need to run 2 lines of code!\nFirst we create a DESeqDataSet as we did in the ‘Count normalization’ lesson and specify the txi object which contains our raw counts, the metadata variable, and provide our design formula:\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\nThen, to run the actual differential expression analysis, we use a single call to the function DESeq().\n#| eval: false\n\n# Run analysis\ndds &lt;- DESeq(dds)\nBy re-assigning the results of the function back to the same variable name (dds), we can fill in the slots of our DESeqDataSet object.\n\n\n\nEverything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs:\n#| echo: false\n#| message: true\n\n&lt;&lt;run_deseq&gt;&gt;\nWe will discuss what is occurring in each of these steps in the next few lessons, but the code to execute these steps is encompassed in the two lines above.\n\n\n\n\n\n\nNote\n\n\n\nThere are individual functions available in DESeq2 that would allow us to carry out each step in the workflow in a step-wise manner, rather than a single call. We demonstrated one example when generating size factors to create a normalized matrix. By calling DESeq(), the individual functions for each step are run for you.\n\n\n\n\n\n\n\n\nExercise\n\n\n\nLet’s suppose our experiment has the following metadata:\n\n\n\n\ngenotype\ntreatment\n\n\n\n\nsample1\nWT\nev\n\n\nsample2\nWT\nev\n\n\nsample3\nWT\nev\n\n\nsample4\nWT\nev\n\n\nsample5\nKO_geneA\nev\n\n\nsample6\nKO_geneA\nev\n\n\nsample7\nKO_geneA\nev\n\n\nsample8\nKO_geneA\nev\n\n\nsample9\nWT\ntreated\n\n\nsample10\nWT\ntreated\n\n\nsample11\nWT\ntreated\n\n\nsample12\nWT\ntreated\n\n\nsample13\nKO_geneA\ntreated\n\n\nsample14\nKO_geneA\ntreated\n\n\nsample15\nKO_geneA\ntreated\n\n\nsample16\nKO_geneA\ntreated\n\n\n\nHow would the design formula be structured to perform the following analyses?\n\nTest for the effect of treatment.\nTest for the effect of genotype, while regressing out the variation due to treatment.\nTest for the effect of genotype on the treatment effects.\n\n\n\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(dds, \"../data/intermediate_dds_2_ran_deseq.RDS\")\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\ndds  &lt;- readRDS(\"../data/intermediate_dds_2_ran_deseq.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-6",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-6",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain the different steps involved in running DESeq()\nExamine size factors and understand the source of differences\nInspect gene-level dispersion estimates\nRecognize the importance of dispersion during differential expression analysis",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#deseq2-differential-gene-expression-analysis-workflow",
    "href": "lessons/01a_RNAseq_processing_workflow.html#deseq2-differential-gene-expression-analysis-workflow",
    "title": "Genomic annotations",
    "section": "DESeq2 differential gene expression analysis workflow",
    "text": "DESeq2 differential gene expression analysis workflow\nPreviously, we created the DESeq2 object using the appropriate design formula and running DESeq2 using the two lines of code:\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\nWe completed the entire workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below:\n\n\n\nWe will be taking a detailed look at each of these steps to better understand how DESeq2 is performing the statistical analysis and what metrics we should examine to explore the quality of our analysis.\n\nStep 1: Estimate size factors\nThe first step in the differential expression analysis is to estimate the size factors, which is exactly what we already did to normalize the raw counts.\n\n\n\nDESeq2 will automatically estimate the size factors when performing the differential expression analysis. However, if you have already generated the size factors using estimateSizeFactors(), as we did earlier, then DESeq2 will use these values.\nTo normalize the count data, DESeq2 calculates size factors for each sample using the median of ratios method discussed previously in the ‘Count normalization’ lesson.\n\nMOV10 DE analysis: examining the size factors\nLet’s take a quick look at size factor values we have for each sample:\n# Check the size factors\nsizeFactors(dds)\nThese numbers should be identical to those we generated initially when we had run the function estimateSizeFactors(dds). Take a look at the total number of reads for each sample:\n# Total number of raw counts per sample\ncolSums(counts(dds))\nHow do the numbers correlate with the size factor?\nWe see that the larger size factors correspond to the samples with higher sequencing depth, which makes sense, because to generate our normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.\nNow take a look at the total depth after normalization using:\n# Total number of normalized counts per sample\ncolSums(counts(dds, normalized=T))\nHow do the values across samples compare with the total counts taken for each sample?\nYou might have expected the counts to be the exact same across the samples after normalization. However, DESeq2 also accounts for RNA composition during the normalization procedure. By using the median ratio value for the size factor, DESeq2 should not be biased to a large number of counts sucked up by a few DE genes; however, this may lead to the size factors being quite different than what would be anticipated just based on sequencing depth.\n\n\n\nStep 2: Estimate gene-wise dispersion\nThe next step in the differential expression analysis is the estimation of gene-wise dispersions. Before we get into the details, we should have a good idea about what dispersion is referring to in DESeq2.\n\n\n\nIn RNA-seq count data, we know:\n\nTo determine differentially expressed genes, we evaluate the variation of expression between groups (of interest) and compare that to the variation within the groups (between replicates).\nFor each individual gene, the mean is not equal to the variance.\n\n\nGenes that are highly expressed will have a more consistent level of variations, but it will be higher than the mean.\nLowly expressed genes will exhibit variation that hovers around the mean (but with a higher amount of variability).\n\nThis complicated relationship means that we cannot just use the observed variance to account for within-group variation. Instead DESeq2 uses dispersion.\n\n\n\nWhat is dispersion?\nThe dispersion parameter models the within-group variability by describing how much the variance deviates from the mean. A dispersion of 1 would indicate that there is no deviance from the mean (i.e., mean == variance). A typical RNA-seq dataset will exhibit some amount of biological variability present across replicates and so we will always have dispersion values less than one.\n\n\n\n\nEffect on dispersion\n\n\n\n\nVariance increases\nDispersion increases\n\n\nMean expression increases\nDispersion decreases\n\n\n\nDispersion values in DESeq2\nDESeq2 estimates the dispersion for each gene based on the gene’s expression level (mean counts of within-group replicates) and observed variance across replicates, as we demonstrated with the formula above. In this way, the dispersion estimates for genes with the same mean will differ only based on their variance. Therefore, the dispersion estimates reflect the variance in gene expression for a given mean value.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this plot we have dispersion on the y-axis and mean normalized counts on the x-axis. Each black dot represents a gene and its intial maximum likelihood dispersion estimate (MLE) given the observed data. Simply looking at the trend of black dots, we observe an inverse relationship between mean and dispersion. More detail on the fitted red line and blue dots will be described later in this lesson.\n\n\nSince we have only a few (3-6) replicates per group, the dispersion estimates for each gene are often unreliable. As we walk through the next few steps, we will discuss how this issue is resolved.\n\n\nStep 3: Fit curve to gene-wise dispersion estimates\nThe next step in the workflow is to fit a curve to the gene-wise dispersion estimates. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability but, across all genes, there will be a distribution of reasonable estimates of dispersion.\n\n\n\nThis curve is displayed as a red line in the figure presented below. This fitted line allows DESeq2 to utilize information across all genes to generate more accurate estimates using a method called ‘shrinkage’ (described in Step 4).\n\n\n\n\n\nStep 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve\nThe next step in the workflow is to shrink the gene-wise dispersion estimates toward the expected dispersion values.\n\n\n\nDESeq2 assumes that genes with similar expression levels should have similar dispersion. As such, the fitted curve provides a range of expected dispersion values a range of mean expression level.\nIf the initial estimate (black dot) is much lower than the fitted curve, then values are shrunken (blue dots) towards the red line. Dispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation; however, genes with extremely high dispersion values are not (see right side figure below; these genes are shown surrounded by blue circle). This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons [1].\n\n\n\nMAP, maximum a posteriori; MLE, maximum-likelihood estimate. For more detailed information please see Love MI, Huber W, Anders S, Genome Biology 2014\nThe strength of the shrinkage for each gene depends on:\n\nhow close gene dispersions are from the curve\nsample size (more samples = less shrinkage)\n\nThis dispersion shrinkage method is particularly important to reduce false positives in the differential expression analysis. This step allows for more accurate identification of differentially expressed genes when sample sizes are small.\n\n\nInterpretation of the dispersion plot\nTo create this plot with your data, you use the function:\n# Plot dispersion estimates\nplotDispEsts(dds)\nThis is a good plot to examine to ensure your data is a good fit for the DESeq2 model. Evaluate the plot to see:\n\nWhether the data points generally scatter around the curve, with the dispersion decreasing with increasing mean expression levels.\nHow much shrinkage you get across the whole range of means in your data. For any experiment with low degrees of freedom, you will expect to see more shrinkage.\nIf the data scatter in a cloud or different shapes, then you might want to explore your data more to see if you have contamination (mitochondrial, etc.) or outlier samples.\n\nExamples of worrisome dispersion plots are shown below:\nThe plot below shows a cloud of dispersion values, which do not generally follow the curve. This would be worrisome and suggests a bad fit of the data to the model.\n\n\n\nThe next plot shows the dispersion values initially decreasing, then increasing with larger expression values. The larger mean expression values should not have larger dispersions based on our expectations - we expect decreasing dispersions with increasing mean. This indicates that there is less variation for more highly expressed genes than expected. This also indicates that there could be an outlier sample or contamination present in our analysis.\n\n\n\n\nMOV10 DE analysis: exploring the dispersion estimates and assessing model fit\nLet’s take a look at the dispersion estimates for our MOV10 data:\n# Plot dispersion estimates\nplotDispEsts(dds)\nSince we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model?\nWe see a nice decrease in dispersion with increasing mean expression, which is good. We also see the dispersion estimates generally surround the curve, which is also expected. Overall, this plot looks good. We do see strong shrinkage, which is likely due to the fact that we have only two replicates for one of our sample groups. The more replicates we have, the less shrinkage is applied to the dispersion estimates, and the more DE genes are able to be identified. We would generally recommend having at least 4 biological replicates per condition for better estimation of variation.\n\n\n\n\n\n\nExercise\n\n\n\nGiven the dispersion plot below, would you have any concerns regarding the fit of your data to the model?\n\nIf not, what aspects of the plot makes you feel confident about your data?\nIf so, what are your concerns? What would you do to address them?\n\n\n\n\n\n\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\ndds  &lt;- readRDS(\"../data/intermediate_dds.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-7",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-7",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the process of model fitting\nCompare two methods for hypothesis testing (Wald test vs. LRT)\nRecognize the importance of multiple test correction\nIdentify different methods for multiple test correction",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#generalized-linear-model",
    "href": "lessons/01a_RNAseq_processing_workflow.html#generalized-linear-model",
    "title": "Genomic annotations",
    "section": "Generalized Linear Model",
    "text": "Generalized Linear Model\nAs described earlier, the count data generated by RNA-seq exhibits overdispersion (variance &gt; mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a negative binomial distribution to model the RNA-seq counts using the equation below:\n\n\n\nThe two parameters required are the size factor and the dispersion estimate. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.\n\n\n\n\n\n\nNote\n\n\n\n“In statistics, the generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows for response variables that have error distribution models other than a normal distribution. The GLM generalizes linear regression by allowing the linear model to be related to the response variable via a link function and by allowing the magnitude of the variance of each measurement to be a function of its predicted value.” (Wikipedia).\n\n\nAfter the model is fit, coefficients are estimated for each sample group along with their standard error. The coefficents are the estimates for the log2 foldchanges, and will be used as input for hypothesis testing.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#hypothesis-testing",
    "href": "lessons/01a_RNAseq_processing_workflow.html#hypothesis-testing",
    "title": "Genomic annotations",
    "section": "Hypothesis testing",
    "text": "Hypothesis testing\nThe first step in hypothesis testing is to set up a null hypothesis for each gene. In our case, the null hypothesis is that there is no differential expression across the two sample groups (LFC == 0). Notice that we can do this without observing any data, because it is based on a thought experiment. Second, we use a statistical test to determine if, based on the observed data, the null hypothesis is true.\n\nWald test\nIn DESeq2, the Wald test is the default used for hypothesis testing when comparing two groups. The Wald test is a test usually performed on parameters that have been estimated by maximum likelihood. In our case we are testing each gene model coefficient (LFC), which was derived using parameters like dispersion that were estimated using maximum likelihood. If there are more than 2 sample classes within a variable (for example, if you had low, medium, and high treatment levels) then DESeq2 will generate two pairwise comparisons when low is set as the control (see here for more info): low vs. medium, and low vs. high.\nDESeq2 implements the Wald test by:\n\nTaking the LFC and dividing it by its standard error, resulting in a z-statistic\nThe z-statistic is compared to a standard normal distribution, and a p-value is computed reporting the probability that a z-statistic at least as extreme as the observed value would be selected at random\nIf the p-value is small, we reject the null hypothesis and state that there is evidence against the null (i.e., the gene is differentially expressed).\n\nThe model fit and Wald test were already run previously as part of the DESeq() function:\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\n\nLikelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test (LRT) as an alternative hypothesis test for when we are comparing more than two sample classes. Rather than evaluating whether a gene’s expression is up- or down-regulated in one class compared to another, the LRT identifies genes that are changing in expression in any direction across the different sample classes.\nHow does this compare to the Wald test?\nThe Wald test (default) only estimates one model per gene and evaluates the null hypothesis that LFC == 0.\nFor the Likelihood Ratio Test is also performed on parameters that have been estimated by maximum likelihood. For this test two models are estimated per gene; the fit of one model is compared to the fit of the other model.\n\n\n\n\nm1 is the reduced model (i.e., the design formula with your main factor term removed)\nm2 is the full model (i.e., the full design formula you provided when creating your dds object)\n\n\n\n\n\n\n\nImportant\n\n\n\nThis type of test can be especially useful in analyzing time course experiments.\n\n\nHere, we are evaluating the null hypothesis that the full model fits just as well as the reduced model. If we reject the null hypothesis, this suggests that there is a significant amount of variation explained by the full model (and our main factor of interest), therefore the gene is differentially expressed across the different levels. DESeq2 implements the LRT by using an Analysis of Deviance (ANODEV) to compare the two model fits. It is shown that LR follows a chi-squared distribution, and this can be used to calculate and associated p-value.\nTo use the LRT, we use the DESeq() function but this time adding two arguments:\n\nspecifying that we want to use the LRT test\nthe ‘reduced’ model\n\n# The full model was specified previously with the `design = ~ sampletype`:\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = meta, ~ sampletype)\n\n# Likelihood ratio test\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\nSince our ‘full’ model only has one factor (sampletype), the ‘reduced’ model (removing that factor) leaves us with nothing in our design formula. DESeq2 cannot fit a model with nothing in the design formula, and so in the scenario where you have no additional covariates the intercept is modeled using the syntax ~ 1.\n\n\n\n\n\n\nExercise\n\n\n\nYou are studying brain maturation and growth patterns in mouse cortex and have obtained RNA-seq data for a total of 24 mice. These samples were acquired at 2 developmental stages (3 dpf and 10 dpf) and with or without treatment using a growth inhibitor (Monoamine oxidase (MAO) inhibitors). For each developmental stage and treatment combination you have 6 replicates. You also have sex information for these mice (12 males and 12 females).\n\nWhat steps are necessary to take to decide what your model should be?\nWhat is an appropriate hypothesis test if you are testing for expression differences across the developmental stages?\nProvide the line of code used to create the dds object.\nProvide the line of code used to run DESeq2.\nWould you use a different hypothesis test if you had 3 developmental timepoints?",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#multiple-test-correction",
    "href": "lessons/01a_RNAseq_processing_workflow.html#multiple-test-correction",
    "title": "Genomic annotations",
    "section": "Multiple test correction",
    "text": "Multiple test correction\nRegardless of whether we use the Wald test or the LRT, each gene that has been tested will be associated with a p-value. It is this result which we use to determine which genes are considered significantly differentially expressed. However, we cannot use the p-value directly.\n\nWhat does the p-value mean?\nA gene with a significance cut-off of p &lt; 0.05, means there is a 5% chance it is a false positive. For example, if we test 20,000 genes for differential expression, at p &lt; 0.05 we would expect to find 1,000 genes by chance. If we found 3,000 genes to be differentially expressed total, roughly one third of our genes are false positives! We would not want to sift through our “significant” genes to identify which ones are true positives.\nSince each p-value is the result of a single test (single gene), the more genes we test, the more we inflate the false positive rate. This is the multiple testing problem.\n\n\nCorrecting the p-value for multiple testing\nThere are a few common approaches for multiple test correction:\n\nBonferroni: The adjusted p-value is calculated by: p-value * m (m = total number of tests). This is a very conservative approach with a high probability of false negatives, so is generally not recommended.\nFDR/Benjamini-Hochberg: Benjamini and Hochberg (1995) defined the concept of False Discovery Rate (FDR) and created an algorithm to control the expected FDR below a specified level given a list of independent p-values. More info about BH.\nQ-value / Storey method: The minimum FDR that can be attained when calling that feature significant. For example, if gene X has a q-value of 0.013 it means that 1.3% of genes that show p-values at least as small as gene X are false positives.\n\nDESeq2 helps reduce the number of genes tested by removing those genes unlikely to be significantly DE prior to testing, such as those with low number of counts and outlier samples (gene-level QC). However, multiple test correction is also implemented to reduce the False Discovery Rate using an interpretation of the Benjamini-Hochberg procedure.\nSo what does FDR &lt; 0.05 mean?\nBy setting the FDR cutoff to &lt; 0.05, we’re saying that the proportion of false positives we expect amongst our differentially expressed genes is 5%. For example, if you call 500 genes as differentially expressed with an FDR cutoff of 0.05, you expect 25 of them to be false positives.\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(dds_lrt, \"../data/intermediate_dds_lrt.RDS\")\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\ndds &lt;- readRDS(\"../data/intermediate_dds_2_ran_deseq.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-8",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-8",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss the steps required to generate a results table for pairwise comparisons (Wald test)\nSummarize the different levels of gene filtering\nExplain log fold change shrinkage",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#specifying-contrasts",
    "href": "lessons/01a_RNAseq_processing_workflow.html#specifying-contrasts",
    "title": "Genomic annotations",
    "section": "Specifying contrasts",
    "text": "Specifying contrasts\nIn our dataset, we have a single variable in our design formula that has three sample classes (levels) so we can make three possible pairwise comparisons:\n\nControl vs. Mov10 overexpression\nControl vs. Mov10 knockdown\nMov10 knockdown vs. Mov10 overexpression\n\nWe are really only interested in #1 and #2 from above. When we initially created our dds object, we had provided ~ sampletype as our design formula, indicating that sampletype is our main factor of interest.\nTo indicate which two sample classes we are interested in comparing, we need to specify contrasts. The contrasts are used as input to the DESeq2 results() function to extract the desired results.\n\n\n\n\n\n\nNote\n\n\n\nIf we run the results() function without specifying contrast or name, it will return the comparison of the last level of the last variable in the design formula over the first level of this variable. If the order of levels are not specified, they are ordered alphabetically by DESeq2.\n\n\nContrasts can be specified in two different ways (with the first method more commonly used):\n\nContrasts can be supplied as a character vector with exactly three elements: the name of the factor (of interest) in the design formula and the name of the two factors levels to compare. The factor level given last is the base level for the comparison. The syntax is given below:\n\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# Set up contrast\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\n\nContrasts can be given as a list of 2 character vectors: the names of the fold changes for the level of interest, and the names of the fold changes for the base level. These names should match identically to the elements of resultsNames(object). This method can be useful for combining interaction terms and main effects.\n\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# See what names to use\nresultsNames(dds)\n\n# Set up contrast\ncontrast &lt;- list(resultsNames(dds)[1], resultsNames(dds)[2])\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\nAlternatively, if you only had two factor levels, you could do nothing and not worry about specifying contrasts (i.e. results(dds)). In this case, DESeq2 will choose what your base factor level based on alphabetical order of the levels.\nTo start, we want to evaluate expression changes between the MOV10 overexpression samples and the control samples. As such we will use the first method for specifying contrasts and create a character vector:\n# Define contrasts for MOV10 overexpression\ncontrast_oe &lt;- c(\"sampletype\", \"MOV10_overexpression\", \"control\")\n\n\n\n\n\n\nDoes it matter what I choose to be my base level?\n\n\n\nYes, it does matter. Deciding what level is the base level will determine how to interpret the fold change that is reported. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in our factor level of interest relative to the base level. Thus, if leaving it up to DESeq2 to decide on the contrasts, be sure to check that the alphabetical order coincides with the fold change direction you are anticipating.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#the-results-table",
    "href": "lessons/01a_RNAseq_processing_workflow.html#the-results-table",
    "title": "Genomic annotations",
    "section": "The results table",
    "text": "The results table\nNow that we have our contrast created, we can use it as input to the results() function. Let’s take a quick look at the help manual for the function:\n#| eval: false\n\n?results\nYou will see we have the option to provide a wide array of arguments and tweak things from the defaults as needed. As we go through the lesson we will keep coming back to the help documentation to discuss some arguments that are good to know about.\n# Extract results for MOV10 overexpression vs control\nres_tableOE &lt;- results(dds, contrast=contrast_oe, alpha = 0.05)\n\n\n\n\n\n\nNote\n\n\n\nFor our analysis, in addition to the contrast argument we will also provide a value of 0.05 for the alpha argument. We will describe this in more detail when we talk about gene-level filtering.\n\n\nThe results table that is returned to us is a DESeqResults object, which is a simple subclass of DataFrame. In many ways it can be treated like a dataframe (i.e., when accessing/subsetting data); however, it is important to recognize that there are differences for downstream steps like visualization.\n# Check what type of object is returned\nclass(res_tableOE)\nNow let’s take a look at what information is stored in the results:\n# What is stored in results?\nres_tableOE %&gt;% \n  data.frame() %&gt;% \n  head()\nWe have six columns of information reported for each gene (row). We can use the mcols() function to extract information on what the values stored in each column represent:\n#| eval: false\n\n# Get information on each column in results\nmcols(res_tableOE, use.names=T)\n\nbaseMean: mean of normalized counts for all samples\nlog2FoldChange: log2 fold change\nlfcSE: standard error\nstat: Wald statistic\npvalue: Wald test p-value\npadj: BH adjusted p-values",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#p-values",
    "href": "lessons/01a_RNAseq_processing_workflow.html#p-values",
    "title": "Genomic annotations",
    "section": "P-values",
    "text": "P-values\nThe p-value is a probability value used to determine whether there is evidence to reject the null hypothesis. A smaller p-value means that there is stronger evidence in favor of the alternative hypothesis. However, because we are performing a test for each individual gene we need to correct these p-values for multiple testing.\nThe padj column in the results table represents the p-value adjusted for multiple testing, and is the most important column of the results. Typically, a threshold such as padj &lt; 0.05 is a good starting point for identifying significant genes. The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR). There are other corrections methods available and can be changed by adding the pAdjustMethod argument to the results() function.\n\nGene-level filtering\nLet’s take a closer look at our results table. As we scroll through it, you will notice that for selected genes there are NA values in the pvalue and padj columns. What does this mean?\n\n\n\nThe missing values represent genes that have undergone filtering as part of the DESeq() function. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. DESeq2 does not physically remove any genes from the original counts matrix, and so all genes will be present in your results table. The genes omitted by DESeq2 meet one of the three filtering criteria outlined below:\n1. Genes with zero counts in all samples\nIf, within a row, all samples have zero counts, there is no expression information and therefore these genes are not tested.\n# Filter genes by zero expression\nres_tableOE[which(res_tableOE$baseMean == 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\nThe baseMean column for these genes will be zero, and the log2 fold change estimates, p-value, and adjusted p-value will all be set to NA.\n2. Genes with an extreme count outlier\nThe DESeq() function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook’s distance. Cook’s distance is a measure of how much a single sample is influencing the fitted coefficients for a gene, and a large value of Cook’s distance is intended to indicate an outlier count. Genes that contain a Cook’s distance above a threshold are flagged; however, at least 3 replicates are required for flagging, as it is difficult to judge which sample might be an outlier with only 2 replicates. We can turn off this filtering by using the cooksCutoff argument in the results() function.\n# Filter genes that have an extreme outlier\nres_tableOE[which(is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) &\n                    res_tableOE$baseMean &gt; 0), ] %&gt;% \n  data.frame() %&gt;% \n  head()\nIf a gene contains a sample with an extreme count outlier, then the p-value and adjusted p-value will be set to NA.\n3. Genes with a low mean normalized counts\nDESeq2 defines a low mean threshold, that is empirically determined from your data, in which the fraction of significant genes can be increased by reducing the number of genes that are considered for multiple testing. This is based on the notion that genes with very low counts are not likely to see significant differences typically due to high dispersion.\n\n\n\nImage courtesy of slideshare presentation from Joachim Jacob, 2014.\nAt a user-specified value (alpha = 0.05), DESeq2 evaluates the change in the number of significant genes as it filters out increasingly bigger portions of genes based on their mean counts, as shown in the figure above. The point at which the number of significant genes reaches a peak is the low mean threshold that is used to filter genes that undergo multiple testing. There is also an argument to turn off the filtering off by setting independentFiltering = F.\n# Filter genes below the low mean threshold\nres_tableOE[which(!is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) & \n                    res_tableOE$baseMean &gt; 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\nIf a gene is filtered by independent filtering, then only the adjusted p-value will be set to NA.\n\n\n\n\n\n\nImportant\n\n\n\nDESeq2 will perform the filtering outlined above by default; however, other DE tools such as EdgeR will not. Filtering is a necessary step, even if you are using limma-voom and/or edgeR’s quasi-likelihood methods. Be sure to follow pre-filtering steps when using other tools, as outlined in their user guides found on Bioconductor, as they generally perform much better.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#fold-change",
    "href": "lessons/01a_RNAseq_processing_workflow.html#fold-change",
    "title": "Genomic annotations",
    "section": "Fold change",
    "text": "Fold change\nAnother important column in the results table is the log2FoldChange. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also add a fold change threshold. Keep in mind when setting that value that we are working with log2 fold changes, so a cutoff of log2FoldChange &lt; 1 would translate to an actual fold change of 2.\n\n\n\n\n\n\nAn alternative approach to add the fold change threshold:\n\n\n\nThe results() function has an option to add a fold change threshold using the lfcThrehsold argument. This method is more statistically motivated, and is recommended when you want a more confident set of genes based on a certain fold-change. It actually performs a statistical test against the desired threshold, by performing a two-tailed test for log2 fold changes greater than the absolute value specified. The user can change the alternative hypothesis using altHypothesis and perform two one-tailed tests as well. This is a more conservative approach, so expect to retrieve a much smaller set of genes!\n\n\nThe fold changes reported in the results table are calculated by:\nlog2 (normalized_counts_group1 / normalized_counts_group2)\nThe problem is, these fold change estimates are not entirely accurate, as they do not account for the large dispersion we observe with low read counts. To address this, the log2 fold changes need to be adjusted.\n\nMore accurate LFC estimates\nTo generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:\n\nLow counts\nHigh dispersion values\n\nLFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.\n\n\n\nIllustration taken from the DESeq2 paper.\nIn the figure above, we have an example using two genes: green gene and purple gene. For each gene, the expression values are plotted for each sample in the two different mouse strains (C57BL/6J and DBA/2J). Both genes have the same mean values for the two sample groups, but the green gene has little variation within group while the purple gene has high levels of variation. For the green gene with low within group variation, the unshrunken LFC estimate (vertex of the green solid line) is very similar to the shrunken LFC estimate (vertex of the green dotted line). However, LFC estimates for the purple gene are quite different due to the high dispersion. So even though two genes can have similar normalized count values, they can have differing degrees of LFC shrinkage. Notice the LFC estimates are shrunken toward the prior (black solid line).\nShrinking the log2 fold changes will not change the total number of genes that are identified as significantly differentially expressed. The shrinkage of fold change is to help with downstream assessment of results. For example, if you wanted to subset your significant genes based on fold change for further evaluation, you may want to use shruken values. Additionally, for functional analysis tools such as GSEA that require fold change values as input, you would want to provide shrunken values.\nTo generate the shrunken log2 fold change estimates, you have to run an additional step on your results object (that we will create below) with the function lfcShrink().\n# Save the unshrunken results to compare\nres_tableOE_unshrunken &lt;- res_tableOE\n\n# Apply fold change shrinkage\nres_tableOE &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_overexpression_vs_control\", type=\"apeglm\")\nDepending on the version of DESeq2 you are using, the default method for shrinkage estimation will differ. The defaults can be changed by adding the argument type in the lfcShrink() function as we have above. For most recent versions of DESeq2, type=\"normal\" is the default and was the only method in earlier versions. It has been shown that in most situations there are alternative methods that have less bias than the ’normal` method, and therefore we chose to use apeglm.\nNote that the stat column is no longer present in the results table. You can compare by inspecting the output of res_tableOE and res_tableOE_unshrunken in the R console. If you run type=\"apeglm\" or type=\"ashr\", you do not get a stat column because these don’t really make sense in the context of the posterior quantities that are returned.\n\n\n\n\n\n\nShrinkage\n\n\n\nFor more information on shrinkage, the DESeq2 vignette has an Extended section on shrinkage estimators that is quite useful.\n\n\n\n\n\n\n\n\ncontrast vs coef\n\n\n\nWhen using the alternative methods, rather than using the contrast argument, you will be required to specify coef. Using contrast forms an expanded model matrix, treating all factor levels equally, and averages over all distances between all pairs of factor levels to estimate the prior. Using coef means looking only at that column of the model matrix (so usually that would be one level against the reference level) and estimates the prior for that coefficient from the distribution of those MLE of coefficients. When using coef, the shrinkage depends on which level is chosen as reference.\n\n\n\n\n\n\n\n\nHow do I know what to value to provide to the coef argument?\n\n\n\nThe value you provide here needs to match identically to what is stored in the column header of the coefficients table. To see what values you have to work with you can use resultsNames(dds).",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#ma-plot",
    "href": "lessons/01a_RNAseq_processing_workflow.html#ma-plot",
    "title": "Genomic annotations",
    "section": "MA plot",
    "text": "MA plot\nA plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot.\nLet’s start with the unshrunken results:\n# MA plot using unshrunken fold changes\nplotMA(res_tableOE_unshrunken, ylim=c(-2,2))\nAnd now the shrunken results:\n# MA plot using shrunken fold changes\nplotMA(res_tableOE, ylim=c(-2,2))\nIn the first plot, you have the unshrunken fold change values, and you can see the abundance of scatter for the the lowly-expressed genes. That is, many of the low expressors exhibit very high fold changes. After shrinkage, we see the fold changes are much smaller estimates.\nIn addition to the comparison described above, this plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression. Generally, we would expect to see significant genes across the full range of expression levels.\n\n\n\n\n\n\nExcercise\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\nNow that we have results for the overexpression results, do the same for the Control vs. Knockdown samples.\n\nCreate a contrast vector called contrast_kd.\nUse contrast vector in the results() to extract a results table and store that to a variable called res_tableKD.\nShrink the LFC estimates using lfcShrink() and assign it back to res_tableKD.\n\n\n\n#| echo: false\n\n# Define contrasts for MOV10 knockdown\ncontrast_kd &lt;- c(\"sampletype\", \"MOV10_knockdown\", \"control\")\n\n# Extract results for MOV10 knockdown vs control\nres_tableKD &lt;- results(dds, contrast=contrast_kd, alpha = 0.05)\n\n# Apply fold change shrinkage\nres_tableKD &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_knockdown_vs_control\", type=\"apeglm\")\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(res_tableOE, \"../data/intermediate_res_tableOE.RDS\")\nsaveRDS(res_tableKD, \"../data/intermediate_res_tableKD.RDS\")\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 20 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\nlibrary(DESeq2)\n\n# load objects needed to render this lesson\nres_tableOE &lt;- readRDS(\"../data/intermediate_res_tableOE.RDS\")\nres_tableKD &lt;- readRDS(\"../data/intermediate_res_tableKD.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-9",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-9",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nEvaluate the number of differentially expressed genes produced for each comparison\nConstruct R objects containing significant genes from each comparison",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#summarizing-results",
    "href": "lessons/01a_RNAseq_processing_workflow.html#summarizing-results",
    "title": "Genomic annotations",
    "section": "Summarizing results",
    "text": "Summarizing results\nTo summarize the results table, a handy function in DESeq2 is summary(). Confusingly it has the same name as the function used to inspect data frames. This function, when called with a DESeq results table as input, will summarize the results using a default threshold of padj &lt; 0.1. However, since we had set the alpha argument to 0.05 when creating our results table, the summary() function should also use the threshold FDR &lt; 0.05. (Note that padj/FDR is used even though the output says p-value &lt; 0.05.) Let’s start with the OE vs control results:\n# Summarize results\nsummary(res_tableOE, alpha = 0.05)\nIn addition to the number of genes up- and down-regulated at the default threshold, the function also reports the number of genes that were tested (genes with non-zero total read count), and the number of genes not included in multiple test correction due to a low mean count.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#extracting-significant-differentially-expressed-genes",
    "href": "lessons/01a_RNAseq_processing_workflow.html#extracting-significant-differentially-expressed-genes",
    "title": "Genomic annotations",
    "section": "Extracting significant differentially expressed genes",
    "text": "Extracting significant differentially expressed genes\nLet’s first create variables that contain our threshold criteria. We will only be using the adjusted p-values in our criteria:\n# Set thresholds\npadj.cutoff &lt;- 0.05\nWe can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble:\n# Create a tibble of results\nres_tableOE_tb &lt;- res_tableOE %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\nNow we can subset that table to only keep the significant genes using our pre-defined thresholds:\n# Subset the tibble to keep only significant genes\nsigOE &lt;- res_tableOE_tb %&gt;%\n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Take a quick look at this tibble\nsigOE\n\n\n\n\n\n\nExercise\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\n\nUsing the same p-adjusted threshold as above (padj.cutoff &lt; 0.05), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.\nHow many genes are differentially expressed in the Knockdown compared to Control? How does this compare to the overexpression significant gene list (in terms of numbers)?\n\n\n\n#| echo: false\n\n# Create a tibble of results\nres_tableKD_tb &lt;- res_tableKD %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset the tibble to keep only significant genes\nsigKD &lt;- res_tableKD_tb %&gt;%\n  dplyr::filter(padj &lt; padj.cutoff)\nNow that we have extracted the significant results, we are ready for visualization!\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(res_tableOE_tb, \"../data/intermediate_res_tableOE_tb.RDS\")\nsaveRDS(sigOE,          \"../data/intermediate_res_sigOE.RDS\")\nsaveRDS(sigKD,          \"../data/intermediate_res_sigKD.RDS\")\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 75 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\nlibrary(DESeq2)\nlibrary(ggrepel)\nlibrary(pheatmap)\n\n# load objects needed to render this lesson\nmeta           &lt;- readRDS(\"../data/metadata.RDS\")\ndds            &lt;- readRDS(\"../data/intermediate_dds_2_ran_deseq.RDS\")\ntx2gene     &lt;- read.delim(\"../data/tx2gene_grch38_ens94.txt\")\nres_tableOE_tb &lt;- readRDS(\"../data/intermediate_res_tableOE_tb.RDS\")\npadj.cutoff &lt;- 0.05\nsigOE &lt;- res_tableOE_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff)",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-10",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-10",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nSetup results data for application of visualization techniques\nDescribe different data visualization useful for exploring results from a DGE analysis\nCreate a volcano plot to evaluate relationship amongst DGE statistics\nCreate a heatmap to illustrate expression changes of differentially expressed genes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#visualizing-the-results",
    "href": "lessons/01a_RNAseq_processing_workflow.html#visualizing-the-results",
    "title": "Genomic annotations",
    "section": "Visualizing the results",
    "text": "Visualizing the results\nWhen we are working with large amounts of data, it can be useful to display that information graphically to gain more insight. During this lesson, we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data. Many of these plots can be helpful in visualizing other types of data as well.\nWe will be working with three different data objects we have already created in earlier lessons:\n\nMetadata for our samples (a dataframe): meta\nNormalized expression data for every gene in each of our samples (a matrix): normalized_counts\nTibble versions of the DESeq2 results we generated in the last lesson: res_tableOE_tb and res_tableKD_tb\n\nFirst, let’s create a metadata tibble from the data frame (don’t lose the row names!)\n# Make metadata tibble\nmov10_meta &lt;- meta %&gt;% \n  rownames_to_column(var=\"samplename\") %&gt;% \n  as_tibble()\nNext, let’s bring in a column with gene symbols to the normalized_counts object, so we can use them to label our plots. Ensembl IDs are great for many things, but the gene symbols are much more recognizable to us, as biologists.\n# DESeq2 creates a matrix when you use the counts() function\n# First convert normalized_counts to a data frame and transfer the row names to a new column called \"gene\"\nnormalized_counts &lt;- counts(dds, normalized=TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") \n  \n# Next, merge together (ensembl IDs) the normalized counts data frame\n# with a subset of the annotations in the tx2gene data frame (only the columns for ensembl gene IDs and gene symbols)\ngrch38annot &lt;- tx2gene %&gt;% \n  dplyr::select(ensgene, symbol) %&gt;% \n  dplyr::distinct()\n\n# This will bring in a column of gene symbols\nnormalized_counts &lt;- merge(normalized_counts, grch38annot, by.x=\"gene\", by.y=\"ensgene\")\n\n# Now create a tibble for the normalized counts\nnormalized_counts &lt;- normalized_counts %&gt;%\n  as_tibble()\n\n# View at the tibble to make sure it looks correct\nnormalized_counts %&gt;% head()\n\n\n\n\n\n\nA possible alternative to the above:\n\n\n\nnormalized_counts &lt;- counts(dds, normalized=TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  as_tibble() %&gt;%\n  left_join(grch38annot, by=c(\"gene\" = \"ensgene\"))\n\n\n\nPlotting signicant DE genes\nOne way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes.\n\nUsing DESeq2 plotCounts() to plot expression of a single gene\nTo pick out a specific gene of interest to plot, for example MOV10, we can use the plotCounts() from DESeq2. plotCounts() requires that the gene specified matches the original input to DESeq2, which in our case was Ensembl IDs.\n#| fig.width: 8\n\n# Find the Ensembl ID of MOV10\ngrch38annot[grch38annot$symbol == \"MOV10\", \"ensgene\"]\n\n# Plot expression for single gene\nplotCounts(dds, gene=\"ENSG00000155363\", intgroup=\"sampletype\") \n\n\n\n\n\n\nNote\n\n\n\nThis DESeq2 function only allows for plotting the counts of a single gene at a time, and is not flexible regarding the appearance.\n\n\n\n\nUsing ggplot2 to plot expression of a single gene\nIf you wish to change the appearance of this plot, we can save the output of plotCounts() to a variable specifying the returnData=TRUE argument, then use ggplot():\n# Save plotcounts to a data frame object\nd &lt;- plotCounts(dds, gene=\"ENSG00000155363\", intgroup=\"sampletype\", returnData=TRUE)\n\n# What is the data output of plotCounts()?\nd %&gt;% head()\n\n# Plot the MOV10 normalized counts, using the samplenames (rownames(d)) as labels\nggplot(d, aes(x = sampletype, y = count, color = sampletype)) + \n  # Scatterplot but allow points to \"jitter\" so they are not on top of each other\n  geom_point(position=position_jitter(w = 0.1,h = 0)) +\n  # Label points\n  geom_text_repel(aes(label = rownames(d))) +\n  # Add title and plot tweaks\n  ggtitle(\"MOV10\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\nLabel points\n\n\n\nNote that in the plot above, we are using geom_text_repel() from the ggrepel package to label our individual points on the plot.\n\n\n\n\n\n\n\n\nPlot more than one gene\n\n\n\nIf you are interested in plotting the expression of multiple genes all together, please refer to the short lesson linked here where we demo this for the top 20 most significantly expressed genes.\n\n\n\n\n\nHeatmap\nIn addition to plotting subsets, we could also extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap().\n# Extract normalized expression for significant genes from the OE and control samples (2:4 and 7:9)\nnorm_OEsig &lt;- normalized_counts[,c(1:4,7:9)] %&gt;% \n  dplyr::filter(gene %in% sigOE$gene)  \nNow let’s draw the heatmap using pheatmap:\n# Set a color palette\nheat_colors &lt;- RColorBrewer::brewer.pal(6, \"YlOrRd\")\n\n# Run pheatmap using the metadata dataframe for the annotation\npheatmap(norm_OEsig[2:7], \n         color = heat_colors, \n         cluster_rows = TRUE, \n         show_rownames = FALSE,\n         annotation = meta, \n         border_color = NA, \n         fontsize = 10, \n         scale = \"row\", \n         fontsize_row = 10, \n         height = 20)\n\n\n\n\n\n\nNote\n\n\n\nThere are several additional arguments we have included in the function for aesthetics. One important one is scale=\"row\", in which Z-scores are plotted, rather than the actual normalized count value.\nZ-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed after the clustering, so that it only affects the graphical aesthetics, and the color visualization is improved.\n\n\n\n\nVolcano plot\nThe above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log-transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.\nTo generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values and, for the purposes of this visualization, a log2fold change cutoff.\n# Obtain logical vector where TRUE values denote padj values &lt; 0.05 and fold change &gt; 1.5 in either direction\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% \n  dplyr::mutate(threshold_OE = padj &lt; 0.05 & abs(log2FoldChange) &gt;= log2(1.5))\nNow we can start plotting. The geom_point object is most applicable, as this is essentially a scatter plot:\n# Volcano plot\nggplot(res_tableOE_tb) +\n  geom_point(aes(x = log2FoldChange, y = -log10(padj),\n                 # Color by whether or not gene is DE by padj and log2FC\n                 colour = threshold_OE)) +\n  # You could choose to limit the y-axis to look at the shape of the data without outliers\n  # scale_y_continuous(limits = c(0,50)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))  \nThis is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the volcano plot using geom_text_repel().\nFirst, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot.\n# Add all the gene symbols as a column from the grch38 table using bind_cols()\nres_tableOE_tb &lt;- bind_cols(res_tableOE_tb,\n                            symbol = grch38annot$symbol[match(res_tableOE_tb$gene, grch38annot$ensgene)])\n\n# Create an empty column to indicate which genes to label\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::mutate(genelabels = \"\")\n\n# Sort by padj values \nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::arrange(padj)\n\n# Populate the genelabels column with contents of the gene symbols column for the first 10 rows, i.e., the top 10 most significantly expressed genes\nres_tableOE_tb$genelabels[1:10] &lt;- as.character(res_tableOE_tb$symbol[1:10])\n\n# Look at the new table\nhead(res_tableOE_tb)\nNext, we plot it as before with an additional layer for geom_text_repel() wherein we can specify the column of gene labels we just created.\n# Volcano plot with labels on some points\nggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) +\n  # Color by whether or not gene is DE by padj and log2FC\n  geom_point(aes(colour = threshold_OE)) +\n  # Only label the top 10 DEG we identified above\n  geom_text_repel(aes(label = genelabels)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25))) \n\n\n\n\n\n\nAn R package for visualization of DGE results\n\n\n\nThe Bioconductor package DEGreport can use the DESeq2 results output to make the top 20 genes and the volcano plots generated above by writing much fewer lines of code. The caveat of these functions is you lose the ability to customize plots as we have demonstrated above.\nIf you are interested, the example code below shows how you can use DEGreport to create similar plots. Note that this is example code, do not run.\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# Plot normalized expression of top n (20) genes\nDEGreport::degPlot(dds = dds, # dds object is output from DESeq2\n                   res = res, n = 20, xs = \"type\", group = \"condition\")\n\n# Plot labeled volcano plot\nDEGreport::degVolcano(\n  data.frame(res[,c(\"log2FoldChange\",\"padj\")]), # table - 2 columns\n  plot_text = data.frame(res[1:10,c(\"log2FoldChange\",\"padj\",\"id\")])) # table to add names\n\n# Available in the newer version for R 3.4\nDEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group = \"condition\")\n\n\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(normalized_counts, \"../data/intermediate_normalized_counts_with_gene_names.RDS\")\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 15 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-11",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-11",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIdentify the R commands needed to run a complete differential expression analysis using DESeq2",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "href": "lessons/01a_RNAseq_processing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "title": "Genomic annotations",
    "section": "Summary of differential expression analysis workflow",
    "text": "Summary of differential expression analysis workflow\nWe have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below:\n\nObtaining gene-level counts from Salmon using tximport\n\n#| eval: false\n\n# Run tximport\ntxi &lt;- tximport(files, \n                type=\"salmon\", \n                tx2gene=t2g, \n                countsFromAbundance = \"lengthScaledTPM\")\n\n# \"files\" is a vector wherein each element is the path to the salmon quant.sf file, and each element is named with the name of the sample.\n# \"t2g\" is a 2 column data frame which contains transcript IDs mapped to geneIDs (in that order)\n\nCreating the dds object:\n\n#| eval: false\n\n# Check that the row names of the metadata equal the column names of the **raw counts** data\nall(colnames(txi$counts) == rownames(metadata))\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, \n                                colData = metadata, \n                                design = ~ condition)\n\nExploratory data analysis (PCA & hierarchical clustering) - identifying outliers and sources of variation in the data:\n\n#| eval: false\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, \n            blind=TRUE)\n\n# Plot PCA \nplotPCA(rld, \n        intgroup=\"condition\")\n\n# Extract the rlog matrix from the object and compute pairwise correlation values\nrld_mat &lt;- assay(rld)\nrld_cor &lt;- cor(rld_mat)\n\n# Plot heatmap\npheatmap(rld_cor, \n         annotation = metadata)\n\nRun DESeq2:\n\n#| eval: false\n\n# **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = metadata, design = ~ covariate + condition)\n\n# Run DESeq2 differential expression analysis\ndds &lt;- DESeq(dds)\n\n# **Optional step** - Output normalized counts to save as a file to access outside RStudio\n# normalized_counts &lt;- counts(dds, normalized=TRUE)\n\nCheck the fit of the dispersion estimates:\n\n#| eval: false\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\nCreate contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions:\n\n#| eval: false\n\n# Specify contrast for comparison of interest\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Output results of Wald test for contrast\nres &lt;- results(dds, \n               contrast = contrast, \n               alpha = 0.05)\n\n# Shrink the log2 fold changes to be more accurate\nres &lt;- lfcShrink(dds, \n                 coef = \"sampletype_group1_vs_group2\", \n                 type = \"apeglm\")    \n# The coef will be dependent on what your contrast was. and should be identical to what is stored in resultsNames()\n\nOutput significant results:\n\n#| eval: false\n\n# Set thresholds\npadj.cutoff &lt; - 0.05\n\n# Turn the results object into a tibble for use with tidyverse functions\nres_tbl &lt;- res %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset the significant results\nsig_res &lt;- dplyr::filter(res_tbl, \n                         padj &lt; padj.cutoff)\n\nVisualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc.\nPerform analysis to extract functional significance of results: GO or KEGG enrichment, GSEA, etc.\nMake sure to output the versions of all tools used in the DE analysis:\n\n#| eval: false\n\nsessionInfo()\nFor better reproducibility, it can help to create RMarkdown reports, which save all code, results, and visualizations as nicely formatted html reports. We have a very basic example of a report linked here. To create these reports we have additional materials available.\nApproximate time: 60 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\nlibrary(DESeq2)\nlibrary(DEGreport)\n\n# load objects needed to render this lesson\ndds_lrt &lt;- readRDS(\"../data/intermediate_dds_lrt.RDS\")\nsigOE   &lt;- readRDS(\"../data/intermediate_res_sigOE.RDS\")\nsigKD   &lt;- readRDS(\"../data/intermediate_res_sigKD.RDS\")\ndds     &lt;- readRDS(\"../data/intermediate_dds.RDS\")\nmeta    &lt;- readRDS(\"../data/metadata.RDS\")\npadj.cutoff &lt;- 0.05",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-12",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-12",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nApply the Likelihood Ratio Test (LRT) for hypothesis testing\nCompare results generated from the LRT to results obtained using the Wald test\nIdentify shared expression profiles from the LRT significant gene list",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "href": "lessons/01a_RNAseq_processing_workflow.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "title": "Genomic annotations",
    "section": "Exploring results from the Likelihood ratio test (LRT)",
    "text": "Exploring results from the Likelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test as an alternative when evaluating expression change across more than two levels. Genes that are identified as significant are those that are changing in expression in any direction across the different factor levels.\nGenerally, this test will result in a larger number of genes than the individual pairwise comparisons. While the LRT is a test of significance for differences of any level(s) of the factor, one should not expect it to be exactly equal to the union of sets of genes using Wald tests (although we do expect a high degree of overlap).",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#the-results-table-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#the-results-table-1",
    "title": "Genomic annotations",
    "section": "The results() table",
    "text": "The results() table\nTo extract the results from our dds_lrt object we can use the same results() function we had used with the Wald test. There is no need for contrasts since we are not making a pairwise comparison.\n\n\n\n\n\n\nNote\n\n\n\nIn an earlier lesson on hypothesis testing, we had you create the object dds_lrt. If you are having trouble finding the object, please run the code:\n#| eval: false\n\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\n\n\n# Extract results for LRT\nres_LRT &lt;- results(dds_lrt)\nLet’s take a look at the results table:\n# View results for LRT\nres_LRT  \nThe results table output looks similar to the Wald test results, with identical columns to what we observed previously.\n\nWhy are fold changes reported for an LRT test?\nFor analyses using the likelihood ratio test, the p-values are determined solely by the difference in deviance between the full and reduced model formula. A single log2 fold change is printed in the results table for consistency with other results table outputs, but is not associated with the actual test.\nColumns relevant to the LRT test:\n\nbaseMean: mean of normalized counts for all samples\nstat: the difference in deviance between the reduced model and the full model\npvalue: the stat value is compared to a chi-squared distribution to generate a pvalue\npadj: BH adjusted p-values\n\nAdditional columns:\n\nlog2FoldChange: log2 fold change\nlfcSE: standard error\n\n\n\n\n\n\n\nNote\n\n\n\nPrinted at the top of the the results table are the two sample groups used to generate the log2 fold change values that we observe in the results table. This can be controlled using the name argument; the value provided to name must be an element of resultsNames(dds).",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#identifying-significant-genes",
    "href": "lessons/01a_RNAseq_processing_workflow.html#identifying-significant-genes",
    "title": "Genomic annotations",
    "section": "Identifying significant genes",
    "text": "Identifying significant genes\nWhen filtering significant genes from the LRT we threshold only the padj column. How many genes are significant at padj &lt; 0.05?\n# Create a tibble for LRT results\nres_LRT_tb &lt;- res_LRT %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset to return genes with padj &lt; 0.05\nsigLRT_genes &lt;- res_LRT_tb %&gt;% \n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Get number of significant genes\nnrow(sigLRT_genes)\n\n# Compare to numbers we had from Wald test\nnrow(sigOE) # overexpression vs control\nnrow(sigKD) # knockdown vs control\nThe number of significant genes observed from the LRT is quite high. This list includes genes that can be changing in any direction across the three factor levels (control, KO, overexpression). To reduce the number of significant genes, we can increase the stringency of our FDR threshold (padj.cutoff).\n\n\n\n\n\n\nExercise\n\n\n\n\nCompare the resulting gene list from the LRT test to the gene lists from the Wald test comparisons.\n\nHow many of the sigLRT_genes overlap with the significant genes in sigOE?\nHow many of the sigLRT_genes overlap with the significant genes in sigKD?",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "href": "lessons/01a_RNAseq_processing_workflow.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "title": "Genomic annotations",
    "section": "Identifying clusters of genes with shared expression profiles",
    "text": "Identifying clusters of genes with shared expression profiles\nWe now have this list of ~7K significant genes that we know are changing in some way across the three different sample groups. What do we do next?\nA good next step is to identify groups of genes that share a pattern of expression change across the sample groups (levels). To do this we will be using a clustering tool called degPatterns from the ‘DEGreport’ package. The degPatterns tool uses a hierarchical clustering approach based on pair-wise correlations between genes, then cuts the hierarchical tree to generate groups of genes with similar expression profiles. The tool cuts the tree in a way to optimize the diversity of the clusters, such that the variability inter-cluster &gt; the variability intra-cluster.\nBefore we begin clustering, we will first subset our rlog transformed normalized counts to retain only the differentially expressed genes (padj &lt; 0.05). In our case, it may take some time to run the clustering on 7K genes, and so for class demonstration purposes we will subset to keep only the top 1000 genes sorted by p-adjusted value.\n\n\n\n\n\n\nWhere do I get rlog transformed counts?\n\n\n\nThis rlog transformation was applied in an earlier lesson when we performed QC analysis. If you do not see this in your environment, run the following code:\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\nrld_mat &lt;- assay(rld)\n\n\n# Subset results for faster cluster finding (for classroom demo purposes)\nclustering_sig_genes &lt;- sigLRT_genes %&gt;%\n  arrange(padj) %&gt;%\n  head(n=1000)\n\n# Obtain rlog values for those significant genes\ncluster_rlog &lt;- rld_mat[clustering_sig_genes$gene, ]\nThe rlog transformed counts for the significant genes are input to degPatterns along with a few additional arguments:\n\nmetadata: the metadata dataframe that corresponds to samples\ntime: character column name in metadata that will be used as variable that changes\ncol: character column name in metadata to separate samples\n\nOnce the clustering is finished running, you will get your command prompt back in the console and you should see a figure appear in your plot window. The genes have been clustered into four different groups. For each group of genes, we have a boxplot illustrating expression change across the different sample groups. A line graph is overlayed to illustrate the trend in expression change.\n# Use the `degPatterns` function from the 'DEGreport' package to show gene clusters across sample groups\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"sampletype\", col = NULL)\nSuppose we are interested in the genes which show a decreased expression in the knockdown samples and increase in the overexpression. According to the plot there are 275 genes that share this expression profile. To find out what these genes are, let’s explore the output. What type of data structure is the clusters output?\n# What type of data structure is the `clusters` output?\nclass(clusters)\nWe can see what objects are stored in the list by using names(clusters). There is a dataframe stored inside. This is the main result so let’s take a look at it. The first column contains the genes, and the second column contains the cluster number to which they belong.\n# Let's see what is stored in the `df` component\nhead(clusters$df)\nSince we are interested in Group 1, we can filter the dataframe to keep only those genes:\n# Extract the Group 1 genes\ngroup1 &lt;- clusters$df %&gt;%\n  dplyr::filter(cluster == 1)\nAfter extracting a group of genes, we can use annotation packages to obtain additional information. We can also use these lists of genes as input to downstream functional analysis tools to obtain more biological insight and see whether the groups of genes share a specific function.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 20 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-13",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-13",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss time course analyses with DESeq2",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#time-course-analyses-with-lrt",
    "href": "lessons/01a_RNAseq_processing_workflow.html#time-course-analyses-with-lrt",
    "title": "Genomic annotations",
    "section": "Time course analyses with LRT",
    "text": "Time course analyses with LRT\nDespite the popularity of static measurement of gene expression, time-course capturing of biological processes is essential to reflect their dynamic nature, particularly when patterns are complex and are not simply ascending or descending. When working with this type of data, the Likelihood Ratio Test (LRT) is especially helpful. We can use the LRT to explore whether there are any significant differences across a series of timepoints and further evaluate differences observed between sample classes.\nFor example, suppose we have an experiment looking at the effect of treatment over time on mice of two different genotypes. We could use a design formula for our ‘full model’ that would include the major sources of variation in our data: genotype, treatment, time, and our main condition of interest, which is the difference in the effect of treatment over time (treatment:time).\n\n\n\n\n\n\nWarning\n\n\n\nThis is just example code for our hypothetical experiment. You should not run this code.\n\n\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\nfull_model &lt;- ~ genotype + treatment + time + treatment:time\nTo perform the LRT test, we also need to provide a reduced model, that is the full model without the treatment:time term:\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\nreduced_model &lt;- ~ genotype + treatment + time\nThen, we could run the LRT by using the following code:\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\ndds &lt;- DESeqDataSetFromMatrix(countData = raw_counts,\n                              colData = metadata,\n                              design = ~ genotype + treatment + time + treatment:time)\n\ndds_lrt_time &lt;- DESeq(dds, test=\"LRT\", reduced = ~ genotype + treatment + time)\nTo understand what kind of gene expression patterns will be identified as differentially expressed, we have a few examples below. In the plots below we have time on the x-axis and gene expression on the y-axis. In this dataset there are two samples for each time point, one having undergone some treatment (red) and the other without (blue).\nFor this figure, we are depicting the type of genes that will not be identified as differentially expressed. Here, we observe that GeneX is differentially expressed between the time points, however there is no difference in that expression pattern between the treatment groups.\n\n\n\nThe type of gene expression patterns we do expect the LRT to return are those that exhibit differences in the effect of treatment over time. In the example below, GeneX displays a different expression pattern over time for the two treatment groups.\n\n\n\nContinuing with our example dataset, after running the LRT we can determine the set of significant genes using a threshold of padj &lt; 0.05. The next step would be to sort those genes into groups based on shared expression patterns, and we could do this using degPatterns(). Here, you will notice that we make use of the col argument since we have two groups that we are comparing to one another.\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"time\", col = \"treatment\")\nDepending on what type of shared expression profiles exist in your data, you can then extract the groups of genes associated with the patterns of interest and move on to functional analysis for each of the gene groups of interest.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website\nApproximate time: 120 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\n\n# load objects needed to render this lesson\nres_tableOE_tb  &lt;- readRDS(\"../data/intermediate_res_tableOE_tb.RDS\")\nannotations_ahb &lt;- readRDS(\"../data/intermediate_annotations_ahb.RDS\")\nLearning Objectives:\n\nDetermine how functions are attributed to genes using Gene Ontology terms\nDescribe the theory of how functional enrichment tools yield statistically enriched functions or interactions\nDiscuss functional analysis using over-representation analysis, and functional class scoring\nIdentify popular functional analysis tools for over-representation analysis",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#over-representation-analysis",
    "href": "lessons/01a_RNAseq_processing_workflow.html#over-representation-analysis",
    "title": "Genomic annotations",
    "section": "Over-representation analysis",
    "text": "Over-representation analysis\nThere are a plethora of functional enrichment tools that perform some type of “over-representation” analysis by querying databases containing information about gene function and interactions.\nThese databases typically categorize genes into groups (gene sets) based on shared function, involvement in a pathway, presence in a specific cellular location, or other categorizations, e.g. functional pathways, etc. Essentially, known genes are binned into categories that have been consistently named (controlled vocabulary) based on how the gene has been annotated functionally. These categories are independent of any organism; however, each organism has distinct categorizations available.\nTo determine whether any categories are over-represented, you can determine the probability of having the observed proportion of genes associated with a specific category in your gene list based on the proportion of genes associated with the same category in the background set (gene categorizations for the appropriate organism).\n\n\n\n\n\n\nThe statistical test that will determine whether something is actually over-represented is the Hypergeometric test.\n\nHypergeometric testing\nUsing the example of the first functional category above, hypergeometric distribution is a probability distribution that describes the probability of 25 genes (k) being associated with “Functional category 1”, for all genes in our gene list (n=1000), from a population of all of the genes in entire genome (N=13,000) which contains 35 genes (K) associated with “Functional category 1” [2].\nThe calculation of probability of k successes follows the formula:\n\n\n\nThis test will result in an adjusted p-value (after multiple test correction) for each category tested.\n\n\nGene Ontology project\nOne of the most widely-used categorizations is the Gene Ontology (GO) established by the Gene Ontology project.\n“The Gene Ontology project is a collaborative effort to address the need for consistent descriptions of gene products across databases” [3]. The Gene Ontology Consortium maintains the GO terms, and these GO terms are incorporated into gene annotations in many of the popular repositories for animal, plant, and microbial genomes.\nTools that investigate enrichment of biological functions or interactions often use the Gene Ontology (GO) categorizations – i.e., the GO terms – to determine whether any have significantly modified representation in a given list of genes. Therefore, to best use and interpret the results from these functional analysis tools, it is helpful to have a good understanding of the GO terms themselves and their organization.\n\nGO Ontologies\nTo describe the roles of genes and gene products, GO terms are organized into three independent controlled vocabularies (ontologies) in a species-independent manner:\n\nBiological process: refers to the biological role involving the gene or gene product, and could include “transcription”, “signal transduction”, and “apoptosis”. A biological process generally involves a chemical or physical change of the starting material or input.\nMolecular function: represents the biochemical activity of the gene product. Such activities could include “ligand”, “GTPase”, and “transporter”.\nCellular component: refers to the location in the cell of the gene product. Cellular components could include “nucleus”, “lysosome”, and “plasma membrane”.\n\nEach GO term has a term name (e.g., DNA repair) and a unique term accession number (GO:0005125), and a single gene product can be associated with many GO terms, since a single gene product “may function in several processes, contain domains that carry out diverse molecular functions, and participate in multiple alternative interactions with other proteins, organelles or locations in the cell” [4].\n\n\nGO term hierarchy\nSome gene products are well-researched, with vast quantities of data available regarding their biological processes and functions. However, other gene products have very little data available about their roles in the cell.\nFor example, the protein “p53” would contain a wealth of information on its roles in the cell, whereas another protein might only be known as a “membrane-bound protein” with no other information available.\nThe GO ontologies were developed to describe and query biological knowledge with differing levels of information available. To do this, GO ontologies are loosely hierarchical, ranging from general ‘parent’ terms to more specific ‘child’ terms. The GO ontologies are “loosely” hierarchical since ‘child’ terms can have multiple ‘parent’ terms.\nSome genes with less information may only be associated with general ‘parent’ terms or no terms at all, while other genes with a lot of information be associated with many terms.\n\n\n\nNature Reviews Cancer 7, 23-34 (January 2007)\n\n\nTips for working with GO terms",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#clusterprofiler",
    "href": "lessons/01a_RNAseq_processing_workflow.html#clusterprofiler",
    "title": "Genomic annotations",
    "section": "clusterProfiler",
    "text": "clusterProfiler\nWe will be using clusterProfiler to perform over-representation analysis on GO terms associated with our list of significant genes. The tool takes as input a significant gene list and a background gene list and performs statistical enrichment analysis using hypergeometric testing. The basic arguments allow the user to select the appropriate organism and GO ontology (BP, CC, MF) to test.\n\nRunning clusterProfiler\nTo run clusterProfiler GO over-representation analysis, we will change our gene names into Ensembl IDs, since the tool works a bit easier with the Ensembl IDs.\nFirst load the following libraries:\n# Load libraries\nlibrary(DOSE)\nlibrary(pathview)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nFor the different steps in the functional analysis, we require Ensembl and Entrez IDs. We will use the gene annotations that we generated previously to merge with our differential expression results. Before we do that, let’s subset our results tibble to only have the genes that were tested, i.e., genes whose adjusted p-values are not equal to NA.\n# Untested genes have padj = NA, so let's keep genes with padj != NA\nres_tableOE_tb_noNAs &lt;- filter(res_tableOE_tb, padj != \"NA\" )\n\n# Merge the AnnotationHub dataframe with the results \nres_ids &lt;- left_join(res_tableOE_tb_noNAs, annotations_ahb, by=c(\"gene\"=\"gene_id\")) \n\n\n\n\n\n\nNote\n\n\n\nIf you were unable to generate the annotations_ahb object, you can download the annotations to your data folder by right-clicking here and selecting “Save link as…”\nTo read in the object, you can run the following code: annotations_ahb &lt;- read.csv(\"annotations_ahb.csv\")\n\n\nTo perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n# Create background dataset for hypergeometric testing using all tested genes for significance in the results\nallOE_genes &lt;- as.character(res_ids$gene)\n\n# Extract significant results\nsigOE &lt;- dplyr::filter(res_ids, padj &lt; 0.05)\nsigOE_genes &lt;- as.character(sigOE$gene)\nNow we can perform the GO enrichment analysis and save the results:\n\n\n\n\n\n\nNotes for running clusterProfiler\n\n\n\nThe different organisms with annotation databases available to use with for the OrgDb argument can be found here.\nAlso, the keyType argument may be coded as keytype in different versions of clusterProfiler.\nFinally, the ont argument can accept either “BP” (Biological Process), “MF” (Molecular Function), and “CC” (Cellular Component) subontologies, or “ALL” for all three.\n\n\n# Run GO enrichment analysis \nego &lt;- enrichGO(gene = sigOE_genes, \n                universe = allOE_genes,\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Hs.eg.db, \n                ont = \"BP\", \n                pAdjustMethod = \"BH\", \n                qvalueCutoff = 0.05, \n                readable = TRUE)\n\n# Output results from GO analysis to a table\ncluster_summary &lt;- data.frame(ego)\n\n# View results\ncluster_summary %&gt;% head()\n#| eval: false\n\n# Save results\nwrite.csv(cluster_summary, \"../results/clusterProfiler_Mov10oe.csv\")\n\n\n\n\n\n\nNote\n\n\n\nInstead of saving just the results summary from the ego object, it might also be beneficial to save the object itself. The save() function enables you to save it as a .rda file, e.g. save(ego, file=\"results/ego.rda\").\nThe complementary function to save() is the function load(), e.g. ego &lt;- load(file=\"results/ego.rda\").\nThis is a useful set of functions to know, since it enables one to preserve analyses at specific stages and reload them when needed. More information about these functions can be found here & here.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou can also perform GO enrichment analysis with only the up or down regulated genes in addition to performing it for the full list of significant genes. This can be useful to identify GO terms impacted in one direction and not the other. If very few genes are in any of these lists (&lt; 50, roughly) it may not be possible to get any significant GO terms.\n# Extract upregulated genes\nsigOE_up &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &gt; 0)\nsigOE_up_genes &lt;- as.character(sigOE_up$gene)\n\n## Extract downregulated genes\nsigOE_down &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &lt; 0)\nsigOE_down_genes &lt;- as.character(sigOE_down$gene)\nYou can then create ego_up & ego_down objects by running the enrichGO() function for gene = sigOE_up_genes or gene = sigOE_down_genes.\n\n\n\n\nVisualizing clusterProfiler results\nclusterProfiler has a variety of options for viewing the over-represented GO terms. We will explore the dotplot, enrichment plot, and the category netplot.\nThe dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 30 GO terms by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value.\n#| fig.height: 15\n\n# Dotplot for the top 30 GO terms\ndotplot(ego, showCategory=30)\n#| eval: false\n\n# Save the figure: it has to be very large for the text labels to all fit!\nggsave(filename = \"results/plots_OE_ORA_dotplot.pdf\", width = 8, height = 20)\nThe next plot is the enrichment GO plot, which shows the relationship between the top 30 most significantly enriched GO terms (by padj), by grouping similar terms together. Before creating the plot, we will need to obtain the similarity between terms using the pairwise_termsim() function (instructions for emapplot). In the enrichment plot, the color represents the p-values relative to the other displayed terms (brighter red is more significant), and the size of the terms represents the number of genes that are significant from our list.\n#| fig.height: 10\n#| fig.width: 10\n\n# Add similarity matrix to the termsim slot of enrichment result\nego &lt;- enrichplot::pairwise_termsim(ego)\n\n# Enrichmap clusters the 30 most significant (by padj) GO terms to visualize relationships between terms\nemapplot(ego, showCategory = 30)\n#| eval: false\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_enrich.pdf\", width = 10, height = 10)\nFinally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the number of genes in the terms, with terms with more genes being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes.\n\n\n\n\n\n\nNote\n\n\n\nYou may need to install the ggnewscale package using install.packages(\"ggnewscale\") for the cnetplot() function to work.\n\n\n#| fig.height: 10\n#| fig.width: 10\n\n# To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector\nOE_foldchanges &lt;- sigOE$log2FoldChange\nnames(OE_foldchanges) &lt;- sigOE$gene\n\n# Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj)\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n         \n# If some of the high fold changes are getting drowned out due to a large range, you could set a maximum fold change value\nOE_foldchanges &lt;- ifelse(OE_foldchanges &gt;  2,  2, OE_foldchanges)\nOE_foldchanges &lt;- ifelse(OE_foldchanges &lt; -2, -2, OE_foldchanges)\n\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n#| eval: false\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_net.pdf\", width = 10, height = 10)\nIf you are interested in significant processes that are not among the top five, you can subset your ego dataset to only display these processes:\n#| fig.height: 10\n#| fig.width: 10\n\n# Subsetting the ego results without overwriting original `ego` variable\nego2 &lt;- ego\nego2@result &lt;- ego@result[c(1,3,4,8,9),]\n\n# Plotting terms of interest\ncnetplot(ego2, \n         categorySize = \"pvalue\", \n         foldChange = OE_foldchanges, \n         showCategory = 5, \n         vertex.label.font = 6)\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(res_ids, \"../data/intermediate_res_ids.RDS\")\nApproximate time: 40 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\nlibrary(clusterProfiler)\nlibrary(pathview)\n\n# load objects needed to render this lesson\nres_ids &lt;- readRDS(\"../data/intermediate_res_ids.RDS\")\nLearning Objectives:\n\nDiscuss functional class scoring, and pathway topology methods\nConstruct a GSEA analysis using GO and KEGG gene sets\nExamine results of a GSEA using pathview package\nList other tools and resources for identifying genes of novel pathways or networks",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#functional-analysis-using-functional-class-scoring",
    "href": "lessons/01a_RNAseq_processing_workflow.html#functional-analysis-using-functional-class-scoring",
    "title": "Genomic annotations",
    "section": "Functional analysis using functional class scoring",
    "text": "Functional analysis using functional class scoring\nIn addition to over-representation analysis, there are other types of analyses that can be equally important or informative for obtaining some biological insight from your results. The hypothesis behind functional class scoring (FCS) methods is that although large changes in individual genes can have significant effects on pathways (and will be detected via ORA methods), weaker but coordinated changes in sets of functionally related genes (i.e., pathways) can also have significant effects. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. This type of analysis can be particularly helpful if the differential expression analysis only outputs a small list of significant DE genes.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "href": "lessons/01a_RNAseq_processing_workflow.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "title": "Genomic annotations",
    "section": "Gene set enrichment analysis using clusterProfiler and Pathview",
    "text": "Gene set enrichment analysis using clusterProfiler and Pathview\nOne commonly used tool that is classified under Functional class scoring (FCS) is Gene Set Enrichment Analysis (GSEA). Gene set enrichment analysis utilizes the gene-level statistics or log2 fold changes for all genes to look to see whether gene sets for particular biological pathways are enriched among the large positive or negative fold changes.\n\n\n\nGene sets are pre-defined groups of genes that are functionally related. Commonly used gene sets include those derived from KEGG pathways, Gene Ontology terms, MSigDB, Reactome, or gene groups that share some other functional annotations, etc. [1].\n\nPreparation for GSEA\nThe clusterProfiler package offers several functions to perform GSEA using different genes sets, including but not limited to GO, KEGG, and MSigDb. We will use the KEGG gene sets in our examples below. The KEGG gene sets are defined using the Entrez identifiers, thus to perform the analysis we will need to acquire the corresponding Entrez IDs for our genes. We will also need to remove any genes that do not have an Entrez ID (NA values) and any duplicates (due to gene ID conversion) that may exist:\n# Remove any NA values (reduces the data by quite a bit)\nres_entrez &lt;- dplyr::filter(res_ids, entrezid != \"NA\")\n\n# Remove any Entrez duplicates\nres_entrez &lt;- res_entrez[which(duplicated(res_entrez$entrezid) == F), ]\nGSEA will use the log2 fold changes obtained from the differential expression analysis for every gene to perform the analysis. We will obtain a vector of fold changes for input to clusterProfiler, in addition to the associated Entrez IDs:\n# Extract the foldchanges\nfoldchanges &lt;- res_entrez$log2FoldChange\n\n# Name each fold change with the corresponding Entrez ID\nnames(foldchanges) &lt;- res_entrez$entrezid\nNext we need to order the fold changes in decreasing order. To do this we’ll use the sort() function, which takes a vector as input. This is in contrast to Tidyverse’s arrange(), which requires a data frame.\n# Sort fold changes in decreasing order\nfoldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\n# Confirm that foldchanges is sorted correctly\nhead(foldchanges)\n\n\nTheory of GSEA\nNow we are ready to perform GSEA. The details regarding GSEA can be found in the PNAS paper by Subramanian et al. We will describe briefly the steps outlined in the paper below:\n\n\n\nImage credit: Subramanian et al. Proceedings of the National Academy of Sciences Oct 2005, 102 (43) 15545-15550; DOI: 10.1073/pnas.0506580102\nThis image describes the theory of GSEA, with the ‘gene set S’ showing the metric used (in our case, ranked log2 fold changes) to determine enrichment of genes in the gene set. The left-most image is representing this metric used for the GSEA analysis. The log2 fold changes for each gene in the ‘gene set S’ is shown as a line in the middle image. The large positive log2 fold changes are at the top of the gene set image, while the largest negative log2 fold changes are at the bottom of the gene set image. In the right-most image, the gene set is turned horizontally, underneath which is an image depicting the calculations involved in determining enrichment, as described below.\nStep 1: Calculation of enrichment score:\nAn enrichment score for a particular gene set is calculated by walking down the list of log2 fold changes and increasing the running-sum statistic every time a gene in the gene set is encountered and decreasing it when genes are not part of the gene set. The size of the increase/decrease is determined by magnitude of the log2 fold change. Larger (positive or negative) log2 fold changes will result in larger increases or decreases. The final enrichment score is where the running-sum statistic is the largest deviation from zero.\nStep 2: Estimation of significance:\nThe significance of the enrichment score is determined using permutation testing, which performs rearrangements of the data points to determine the likelihood of generating an enrichment score as large as the enrichment score calculated from the observed data. Essentially, for this step, the first permutation would reorder the log2 fold changes and randomly assign them to different genes, reorder the gene ranks based on these new log2 fold changes, and recalculate the enrichment score. The second permutation would reorder the log2 fold changes again and recalculate the enrichment score again, and this would continue for the total number of permutations run. Therefore, the number of permutations run will increase the confidence in the significance estimates.\nStep 3: Adjust for multiple test correction\nAfter all gene sets are tested, the enrichment scores are normalized for the size of the gene set, then the p-values are corrected for multiple testing.\nThe GSEA output will yield the core genes in the gene sets that most highly contribute to the enrichment score. The genes output are generally the genes at or before the running sum reaches its maximum value (i.e., the most influential genes driving the differences between conditions for that gene set).\n\n\nPerforming GSEA\nFirst, we will set the seed so that we all obtain the same result:\nset.seed(123456)\n\n\n\n\n\n\nNote\n\n\n\nThe permutations are performed using random reordering, so every time we run the function we will get slightly different results. If we would like to use the same permutations every time we run a function, then we use the set.seed(123456) function prior to running. The input to set.seed() can be any number, but if you would want the same results, then you would need to use the same number as the lesson.\n\n\nTo perform the GSEA using KEGG gene sets with clusterProfiler, we can use the gseKEGG() function. The organisms with available KEGG pathway information are listed here.\n# Run GSEA using gene sets from KEGG pathways\ngseaKEGG &lt;- gseKEGG(\n  geneList = foldchanges, # ordered named vector of fold changes (Entrez IDs are the associated names)\n  organism = \"hsa\", # supported organisms listed below\n  minGSSize = 20, # minimum gene set size (# genes in set) - change to test more sets or recover sets with fewer # genes\n  pvalueCutoff = 0.05, # padj cutoff value\n  verbose = FALSE)\n\n# Extract the GSEA results\ngseaKEGG_results &lt;- gseaKEGG@result\n#| eval: false\n\n# Write results to file\nwrite.csv(gseaKEGG_results, \"results/gseaOE_kegg.csv\", quote = FALSE)\nHow many pathways are enriched? NOTE: The results may look slightly different for you.\n# Look at GSEA results\nhead(gseaKEGG_results)\n\nThe first few columns of the results table identify the pathway information\nThe following columns include the associated statistics\nThe last column will report which genes are part of the ‘core enrichment’. These are the genes associated with the pathway which contributed to the observed enrichment score (i.e., in the extremes of the ranking). The genes are listed by EntrezID.\n\n\n\n\n\n\n\nNote\n\n\n\nThe DOSE package has a handy function which allows us to easily convert the list of Entrez identifiers into gene symbols. This is possible if and only if there is an OrgDb available for your organism. The function takes the gseaKEGG object as input and returns the same object with the gene symbols in the ‘core enrichment’ column.\n#| eval: false\n\n# Example code\ngseaKEGG_geneSymbol &lt;- setReadable(gseaKEGG, OrgDb = org.Hs.eg.db, keyType = \"ENTREZID\")\n\n\nLet’s explore the GSEA plot of enrichment of one of the pathways in the ranked list:\n# Plot the GSEA plot for a single enriched pathway, `hsa03008`\ngseaplot(gseaKEGG, geneSetID = 'hsa03008')\nIn this plot, the lines in plot represent the genes in the gene set ‘hsa03008’, and where they occur among the log2 fold changes. The largest positive log2 fold changes are on the left-hand side of the plot, while the largest negative log2 fold changes are on the right. The top plot shows the magnitude of the log2 fold changes for each gene, while the bottom plot shows the running sum, with the enrichment score peaking at the red dotted line (which is among the negative log2 fold changes). This suggests the down-regulation of this pathway.\nUse the Pathview R package to integrate the KEGG pathway data from clusterProfiler into pathway images:\n#| eval: false\n\n# First unload dplyr to avoid conflicts\ndetach(\"package:dplyr\", unload=TRUE)\n\n# Output images for a single significant KEGG pathway\npathview(gene.data = foldchanges,\n         pathway.id = \"hsa03008\",\n         species = \"hsa\",\n         limit = list(gene = 2, # value gives the max/min limit for foldchanges\n                      cpd = 1))\n\n\n\n\n\n\nWarning\n\n\n\nIf the below error message occurs: Error in detach(\"package:dplyr\", unload = T) : invalid 'name' argument, that means the dplyr package is not currently loaded. Ignore the message and continue to run pathview command.\n\n\n\n\n\n\n\n\nNote\n\n\n\nPathview may not display in your R Plots window. Instead, you may see a message such as Info: Working in directory /Users/yourname/Desktop/DEanalysis and Info: Writing image file hsa03008.pathview.png. This indicates that the image has instead been saved to that directory. You can open the pathview file to view it.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPrinting out Pathview images for all significant pathways can be easily performed as follows:\n#| eval: false\n\n# Output images for all significant KEGG pathways\n\n# Make a function to plot a single pathway\nget_kegg_plots &lt;- function(x) {\n  pathview(gene.data = foldchanges, \n           pathway.id = gseaKEGG_results$ID[x], \n           species = \"hsa\",\n           limit = list(gene = 2, cpd = 1))\n}\n\n# Run through that function for all pathways\npurrr::map(1:length(gseaKEGG_results$ID), \n           get_kegg_plots)\n\n\n\n\nIncorpororating other gene sets for GSEA\nThere are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, and use that as input.\nThe Molecular Signatures Database (also known as MSigDB) is a collection of annotated gene sets. It contains 8 major collections:\n\nH: hallmark gene sets\nC1: positional gene sets\nC2: curated gene sets\nC3: motif gene sets\nC4: computational gene sets\nC5: GO gene sets\nC6: oncogenic signatures\nC7: immunologic signatures\n\nUsers can download GMT files from Broad Institute and use the read.gmt() function to parse the files. Alternatively, there is an R package that already packed the MSigDB gene sets in tidy data format that can be used directly with clusterProfiler. The msigdbr package supports several species and some example code is provided below:\n#| eval: false\n\n# DO NOT RUN THIS CODE\n\n# Load library\nlibrary(msigdbr)\n\n# See what species are available\nmsigdbr_show_species()\n##  [1] \"Anolis carolinensis\"             \"Bos taurus\"                     \n##  [3] \"Caenorhabditis elegans\"          \"Canis lupus familiaris\"         \n##  [5] \"Danio rerio\"                     \"Drosophila melanogaster\"        \n##  [7] \"Equus caballus\"                  \"Felis catus\"                    \n##  [9] \"Gallus gallus\"                   \"Homo sapiens\"                   \n## [11] \"Macaca mulatta\"                  \"Monodelphis domestica\"          \n## [13] \"Mus musculus\"                    \"Ornithorhynchus anatinus\"       \n## [15] \"Pan troglodytes\"                 \"Rattus norvegicus\"              \n## [17] \"Saccharomyces cerevisiae\"        \"Schizosaccharomyces pombe 972h-\"\n## [19] \"Sus scrofa\"                      \"Xenopus tropicalis\"\n\n# Use a specific collection; example C6 oncogenic signatures\nm_t2g &lt;- msigdbr(species = \"Homo sapiens\", category = \"C6\") %&gt;% \n  dplyr::select(gs_name, entrez_gene)\n\n# Run GSEA\nmsig_GSEA &lt;- GSEA(foldchanges, TERM2GENE = m_t2g, verbose = FALSE)",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#functional-analysis-pathway-topology-tools",
    "href": "lessons/01a_RNAseq_processing_workflow.html#functional-analysis-pathway-topology-tools",
    "title": "Genomic annotations",
    "section": "Functional analysis: Pathway topology tools",
    "text": "Functional analysis: Pathway topology tools\n\n\n\nThe last main type of functional analysis technique is pathway topology analysis. Pathway topology analysis often takes into account gene interaction information along with the fold changes and adjusted p-values from differential expression analysis to identify dysregulated pathways. Depending on the tool, pathway topology tools explore how genes interact with each other (e.g., activation, inhibition, phosphorylation, ubiquitination, etc.) to determine the pathway-level statistics. Pathway topology-based methods utilize the number and type of interactions between gene product (our DE genes) and other gene products to infer gene function or pathway association.\nFor instance, the SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. We have step-by-step materials for using SPIA available.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#other-tools-for-functional-analysis",
    "href": "lessons/01a_RNAseq_processing_workflow.html#other-tools-for-functional-analysis",
    "title": "Genomic annotations",
    "section": "Other Tools for Functional Analysis",
    "text": "Other Tools for Functional Analysis\n\nCo-expression clustering\nCo-expression clustering is often used to identify genes of novel pathways or networks by grouping genes together based on similar trends in expression. These tools are useful in identifying genes in a pathway, when their participation in a pathway and/or the pathway itself is unknown. These tools cluster genes with similar expression patterns to create ‘modules’ of co-expressed genes that often reflect functionally similar groups of genes. These ‘modules’ can then be compared across conditions or in a time-course experiment to identify any biologically relevant pathway or network information.\nYou can visualize co-expression clustering using heatmaps, which should be viewed as suggestive only; serious classification of genes needs better methods.\nThe way the tools perform clustering is by taking the entire expression matrix and computing pair-wise co-expression values. A network is then generated from which we explore the topology to make inferences on gene co-regulation. The WGCNA package (in R) is one example of a more sophisticated method for co-expression clustering (please note however that it is no longer maintained).",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#resources-for-functional-analysis",
    "href": "lessons/01a_RNAseq_processing_workflow.html#resources-for-functional-analysis",
    "title": "Genomic annotations",
    "section": "Resources for functional analysis",
    "text": "Resources for functional analysis\n\ng:Profiler - http://biit.cs.ut.ee/gprofiler/index.cgi\nDAVID - https://david.ncifcrf.gov\nclusterProfiler - http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html\nGeneMANIA - http://www.genemania.org/\nGenePattern - http://www.broadinstitute.org/cancer/software/genepattern/ (need to register)\nWebGestalt - http://www.webgestalt.org (need to register)\nAmiGO - http://amigo.geneontology.org/amigo\nReviGO (visualizing GO analysis, input is GO terms) - http://revigo.irb.hr/\nWGCNA - https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/ (no longer maintained)\nGSEA - http://software.broadinstitute.org/gsea/index.jsp\nSPIA - https://www.bioconductor.org/packages/release/bioc/html/SPIA.html\nGAGE/Pathview - http://www.bioconductor.org/packages/release/bioc/html/gage.html\n\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(res_entrez, \"../data/intermediate_res_entrez.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#annotationdbi",
    "href": "lessons/01a_RNAseq_processing_workflow.html#annotationdbi",
    "title": "Genomic annotations",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\n\n# load objects needed to render this lesson\nres_tableOE_tb &lt;- readRDS(\"../data/intermediate_res_tableOE_tb.RDS\")\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\n\norg.Hs.eg.db\nThere are a plethora of organism-specific orgDb packages, such as org.Hs.eg.db for human and org.Mm.eg.db for mouse, and a list of organism databases can be found here. These databases are best for converting gene IDs or obtaining GO information for current genome builds, but not for older genome builds. These packages provide the current builds corresponding to the release date of the package, and update every 6 months. If a package is not available for your organism of interest, you can create your own using AnnotationHub.\n# Load libraries\nlibrary(org.Hs.eg.db)\nlibrary(AnnotationDbi)\n\n# Check object metadata\norg.Hs.eg.db\nWe can see the metadata for the database by just typing the name of the database, including the species, last updates for the different source information, and the source urls. Note the KEGG data from this database was last updated in 2011, so may not be the best site for KEGG pathway information.\nWe can easily extract information from this database using AnnotationDbi with the methods: columns, keys, keytypes, and select. For example, we will use our org.Hs.eg.db database to acquire information, but know that the same methods work for the TxDb, Go.db, EnsDb, and BioMart annotations.\n# Return the Ensembl IDs for a set of genes\nannotations_orgDb &lt;- AnnotationDbi::select(\n  org.Hs.eg.db, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENENAME\"), # information to retrieve for given data\n  keytype = \"ENSEMBL\") # type of data given in 'keys' argument\nWe started from at about 57K genes in our results table, and the dimensions of our resulting annotation data frame also look quite similar. Let’s take a peek to see if we actually returned annotations for each individual Ensembl gene ID that went in to the query:\n# How many Ensembl IDs have NOT been linked to gene names (symbols)?\nlength(which(is.na(annotations_orgDb$SYMBOL)))\nLooks like about half of the input genes did not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The difference is due to the fact that each database implements different computational approaches for generating the gene builds. Let’s get rid of those NA entries:\n# Determine the indices for the non-NA genes\nnon_na_idx &lt;- which(is.na(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the genes with annotations using indices\nannotations_orgDb &lt;- annotations_orgDb[non_na_idx, ]\nYou may have also noted the warning returned: ‘select()’ returned 1:many mapping between keys and columns. This is always going to happen with converting between different gene IDs (i.e., one geneID can map to more than one identifier in another databse) . Unless we would like to keep multiple mappings for a single gene, then we probably want to de-duplicate our data before using it.\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_orgDb &lt;- annotations_orgDb[non_duplicates_idx, ]\n\n\nEnsDb.Hsapiens.v86\nTo generate the Ensembl annotations, the EnsDb database can also be easily queried using AnnotationDbi. You will need to decide the release of Ensembl you would like to query. We know that our data is for GRCh38, and the most current EnsDb release for GRCh38 in Bioconductor is release 86, so we can install this database. All Ensembl releases are listed here. NOTE: this is not the most current release of GRCh38 in the Ensembl database, but it’s as current as we can obtain through AnnotationDbi.\nSince we are using AnnotationDbi to query the database, we can use the same functions that we used previously:\n# Install the library\n# BiocManager::install(\"EnsDb.Hsapiens.v86\")\n\n# Load the library\nlibrary(EnsDb.Hsapiens.v86)\n\n# Check object metadata\nEnsDb.Hsapiens.v86\n\n# Explore the fields that can be used as keys\nkeytypes(EnsDb.Hsapiens.v86)\nNow we can return all gene IDs for our gene list:\n# Return the Ensembl IDs for a set of genes\nannotations_edb &lt;- AnnotationDbi::select(\n  EnsDb.Hsapiens.v86, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENEBIOTYPE\"), # information to retrieve for given data\n  keytype = \"GENEID\") # type of data given in 'keys' argument\nWe can check for NA entries, and find that there are none:\nlength(which(is.na(annotations_edb$SYMBOL)))\nThen we can again deduplicate, to remove the gene symbols which appear more than once:\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_edb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_edb &lt;- annotations_edb[non_duplicates_idx, ]\n\n\n\n\n\n\nNote\n\n\n\nIn this case we used the same build but a slightly older release, and we found little discrepancy. If your analysis was conducted using an older genome build (e.g., hg19), but used a newer build for annotation, some genes may be found to be not annotated (NA). Some of the genes have changed names in between versions (due to updates and patches), so may not be present in the newer version of the database.\n\n\nApproximate time: 45 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-14",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-14",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the various data types and data structures (including tibbles) used by R\nUse functions in R and describe how to get help with arguments\nDescribe how to install and use packages in R\nUse the pipe (%&gt;%) from the dplyr package\nDescribe the syntax used by ggplot2 for making plots",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#setting-up-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#setting-up-1",
    "title": "Genomic annotations",
    "section": "Setting up",
    "text": "Setting up\n\nLet’s create a new project directory for this review:\n\n\nCreate a new project called R_refresher.\nCreate a new R script called reviewing_R.R.\nCreate the following folders in the project directory - data, figures.\nDownload a counts file to the data folder by right-clicking here.\n\n\nNow that we have our directory structure setup, let’s load our libraries and read in our data:\n\n\nLoad the tidyverse library.\nUse read.csv() to read in the downloaded file and save it in the object/variable counts.\n\nWhat is the syntax for a function?\nHow do we get help for using a function?\n\nWhat is the data structure of counts?\n\nWhat main data structures are available in R?\n\nWhat are the data types of the columns?\n\nWhat data types are available in R?",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#creating-vectorsfactors-and-dataframes",
    "href": "lessons/01a_RNAseq_processing_workflow.html#creating-vectorsfactors-and-dataframes",
    "title": "Genomic annotations",
    "section": "Creating vectors/factors and dataframes",
    "text": "Creating vectors/factors and dataframes\n\nWe are performing RNA-seq on cancer samples with genotypes of p53 wildtype (WT) and knock-down (KO). You have 8 samples total, with 4 replicates per genotype. Write the R code you would use to construct your metadata table as described below.\n\n\nCreate the vectors/factors for each column. (Hint: you can type out each vector/factor, or if you want the process go faster try exploring the rep() function.)\nPut them together into a dataframe called meta.\nUse the rownames() function to assign row names to the dataframe. (Hint: you can type out the row names as a vector, or if you want the process go faster try exploring the paste0() function.)\n\nYour finished metadata table should have information for the variables sex, stage, genotype, and myc levels:\n\n\n\n\nsex\nstage\ngenotype\nmyc\n\n\n\n\nKO1\nM\n1\nKO\n23\n\n\nKO2\nF\n2\nKO\n4\n\n\nKO3\nM\n2\nKO\n45\n\n\nKO4\nF\n1\nKO\n90\n\n\nWT1\nM\n2\nWT\n34\n\n\nWT2\nF\n1\nWT\n35\n\n\nWT3\nM\n1\nWT\n9\n\n\nWT4\nF\n2\nWT\n10",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#exploring-data",
    "href": "lessons/01a_RNAseq_processing_workflow.html#exploring-data",
    "title": "Genomic annotations",
    "section": "Exploring data",
    "text": "Exploring data\nNow that we have created our metadata dataframe, it’s often a good idea to get some descriptive statistics about the data before performing any analyses.\n\nSummarize the contents of the meta object. How many data types are represented?\nCheck that the row names in the meta dataframe are identical to the column names in counts (content and order).\nConvert the existing stage column into a factor data type.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#extracting-data",
    "href": "lessons/01a_RNAseq_processing_workflow.html#extracting-data",
    "title": "Genomic annotations",
    "section": "Extracting data",
    "text": "Extracting data\n\nUsing the meta dataframe created in the previous question, perform the following exercises (questions DO NOT build upon each other):\n\n\nReturn only the genotype and sex columns using [].\nReturn the genotype values for samples 1, 7, and 8 using [].\nUse filter() to return all data for those samples with genotype WT.\nUse filter()/select()to return only the stage and genotype columns for those samples with myc &gt; 50.\nAdd a column called pre_treatment to the beginning of the dataframe with the values T, F, T, F, T, F, T, F.\n\nWhy might this design be problematic?\n\nUsing %&gt;%, create a tibble of the meta object and call it meta_tb (make sure you don’t lose the rownames!)\nChange the names of the columns to: “A”, “B”, “C”, “D”, “E”.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#visualizing-data",
    "href": "lessons/01a_RNAseq_processing_workflow.html#visualizing-data",
    "title": "Genomic annotations",
    "section": "Visualizing data",
    "text": "Visualizing data\n\nOften it is easier to see the patterns or nature of our data when we explore it visually with a variety of graphics. Let’s use ggplot2 to explore differences in the expression of the Myc gene based on genotype.\n\n\nPlot a boxplot of the expression of Myc for the KO and WT samples using theme_minimal() and give the plot new axes names and a centered title.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#preparing-for-downstream-analysis-tools",
    "href": "lessons/01a_RNAseq_processing_workflow.html#preparing-for-downstream-analysis-tools",
    "title": "Genomic annotations",
    "section": "Preparing for downstream analysis tools",
    "text": "Preparing for downstream analysis tools\n\nMany different statistical tools or analytical packages expect all data needed as input to be in the structure of a list. Let’s create a list of our count and metadata in preparation for a downstream analysis.\n\n\nCreate a list called project1 with the meta and counts objects, as well as a new vector with all the sample names extracted from one of the 2 data frames.\n\nRscript with answers\nApproximate time: 50 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-15",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-15",
    "title": "Genomic annotations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the importance of replicates for RNA-seq differential expression experiments\nExplain the relationship between the number of biological replicates, sequencing depth, and the differentially expressed genes identified\nDemonstrate how to design an RNA-seq experiment that avoids confounding and batch effects",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#replicates",
    "href": "lessons/01a_RNAseq_processing_workflow.html#replicates",
    "title": "Genomic annotations",
    "section": "Replicates",
    "text": "Replicates\nExperimental replicates can be performed as technical replicates or biological replicates.\n\nImage credit: Klaus B, 2015\n\nTechnical replicates: use the same biological sample to repeat the technical or experimental steps in order to accurately measure technical variation and remove it during analysis.\nBiological replicates use different biological samples of the same condition to measure the biological variation between samples.\n\nIn the days of microarrays, technical replicates were considered a necessity; however, with the current RNA-seq technologies, technical variation is much lower than biological variation and technical replicates are unneccessary.\nIn contrast, biological replicates are absolutely essential for differential expression analysis. For mice or rats, this might be easy to determine what constitutes a different biological sample, but it’s a bit more difficult to determine for cell lines. This article gives some great recommendations for cell line replicates.\nFor differential expression analysis, the more biological replicates, the better the estimates of biological variation and the more precise our estimates of the mean expression levels. This leads to more accurate modeling of our data and identification of more differentially expressed genes.\n\nImage credit: Liu Y et al., 2014\nAs the figure above illustrates, biological replicates are of greater importance than sequencing depth, which is the total number of reads sequenced per sample. The figure shows the relationship between sequencing depth and number of replicates on the number of differentially expressed genes identified [1]. Note that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.\n\n\n\n\n\n\nSample pooling\n\n\n\nTry to avoid pooling of individuals/experiments, if possible; however, if absolutely necessary, then each pooled set of samples would count as a single replicate. To ensure similar amounts of variation between replicates, you would want to pool the same number of individuals for each pooled set of samples.\nFor example, if you need at least 3 individuals to get enough material for your control replicate and at least 5 individuals to get enough material for your treatment replicate, you would pool 5 individuals for the control and 5 individuals for the treatment condition. You would also make sure that the individuals that are pooled in both conditions are similar in sex, age, etc.\n\n\nReplicates are almost always preferred to greater sequencing depth for bulk RNA-seq. However, guidelines depend on the experiment performed and the desired analysis. Below we list some general guidelines for replicates and sequencing depth to help with experimental planning:\n\nGeneral gene-level differential expression:\n\nENCODE guidelines suggest 30 million SE reads per sample (stranded).\n15 million reads per sample is often sufficient, if there are a good number of replicates (&gt;3).\nSpend money on more biological replicates, if possible.\nGenerally recommended to have read length &gt;= 50 bp.\n\nGene-level differential expression with detection of lowly-expressed genes:\n\nSimilarly benefits from replicates more than sequencing depth.\nSequence deeper with at least 30-60 million reads depending on level of expression (start with 30 million with a good number of replicates).\nGenerally recommended to have read length &gt;= 50 bp.\n\nIsoform-level differential expression:\n\nFor known isoforms, suggested to have a depth of at least 30 million reads per sample and paired-end reads.\nFor novel isoforms, should have more depth (&gt; 60 million reads per sample).\nChoose biological replicates over paired/deeper sequencing.\nGenerally recommended to have read length &gt;= 50 bp, but longer is better as the reads will be more likely to cross exon junctions.\nPerform careful QC of RNA quality. Be careful to use high quality preparation methods and restrict analysis to high quality RIN # samples.\n\nOther types of RNA analyses (intron retention, small RNA-Seq, etc.):\n\nDifferent recommendations depending on the analysis.\nAlmost always more biological replicates are better!\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe factor used to estimate the depth of sequencing for genomes is “coverage” - how many times do the number of nucleotides sequenced “cover” the genome. This metric is not exact for genomes (whole genome sequencing), but it is good enough and is used extensively. However, the metric does not work for transcriptomes because even though you may know what % of the genome has transcriptional activity, the expression of the genes is highly variable.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#confounding",
    "href": "lessons/01a_RNAseq_processing_workflow.html#confounding",
    "title": "Genomic annotations",
    "section": "Confounding",
    "text": "Confounding\nA confounded RNA-seq experiment is one where you cannot distinguish the separate effects of two different sources of variation in the data.\nFor example, we know that sex has large effects on gene expression, and if all of our control mice were female and all of the treatment mice were male, then our treatment effect would be confounded by sex. We could not differentiate the effect of treatment from the effect of sex.\n\nTo AVOID confounding:\n\nEnsure animals in each condition are all the same sex, age, litter, and batch, if possible.\nIf not possible, then ensure to split the animals equally between conditions",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#batch-effects",
    "href": "lessons/01a_RNAseq_processing_workflow.html#batch-effects",
    "title": "Genomic annotations",
    "section": "Batch effects",
    "text": "Batch effects\nBatch effects are a significant issue for RNA-seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC et al., 2015\nThe issues generated by poor batch study design are highlighted nicely in Gilad Y & Mizrahi-Man O, 2015.\n\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\n\n\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC et al., 2015\nDO split replicates of the different sample groups across batches. The more replicates, the better (definitely more than 2).\n\nImage credit: Hicks SC et al., 2015\nDO include batch information in your experimental metadata. During the analysis, we can regress out the variation due to batch if not confounded so it doesn’t affect our results – if we have that information.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe sample preparation of cell line “biological” replicates “should be performed as independently as possible” (as batches), “meaning that cell culture media should be prepared freshly for each experiment, different frozen cell stocks and growth factor batches, etc. should be used [2].” However, preparation across all conditions should be performed at the same time.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nYour experiment has three different treatment groups, A, B, and C. Due to the lengthy process of tissue extraction, you can only isolate the RNA from two samples at the same time. You plan to have 4 replicates per group. Your metadata table is as follows:\n\n\n\nsample\ntreatment\nsex\nreplicate\nRNA isolation\n\n\n\n\nsample1\nA\nF\n1\n\n\n\nsample2\nA\nF\n2\n\n\n\nsample3\nA\nM\n3\n\n\n\nsample4\nA\nM\n4\n\n\n\nsample5\nB\nF\n1\n\n\n\nsample6\nB\nF\n2\n\n\n\nsample7\nB\nM\n3\n\n\n\nsample8\nB\nM\n4\n\n\n\nsample9\nC\nF\n1\n\n\n\nsample10\nC\nF\n2\n\n\n\nsample11\nC\nM\n3\n\n\n\nsample12\nC\nM\n4\n\n\n\n\nClick here to download the above table as an Excel file.\n\nFill in the RNA isolation column of the metadata table. Since we can only prepare 2 samples at a time and we have 12 samples total, you will need to isolate RNA in 6 batches. In the RNA isolation column, enter one of the following values for each sample: group1, group2, group3, group4, group5, group6. Make sure to fill in the table so as to avoid confounding by batch of RNA isolation.\nBONUS: To perform the RNA isolations more quickly, you devote two researchers to perform the RNA isolations. Create a researcher column and fill in the researchers’ initials for the samples they will prepare: use initials AB or CD.\n\nAnswer Key\n\n\nApproximate time: 30 minutes\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\n\n# load objects needed to render this lesson\nres_tableOE_tb &lt;- readRDS(\"../data/intermediate_res_tableOE_tb.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-16",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-16",
    "title": "Genomic annotations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDiscuss the available genomic annotation databases and the different types if information stored\nCompare and contrast the tools available for accessing genomic annotation databases\nApply various R packages for retrieval of genomic annotations",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#databases",
    "href": "lessons/01a_RNAseq_processing_workflow.html#databases",
    "title": "Genomic annotations",
    "section": "Databases",
    "text": "Databases\nWe retrieve information on the processes, pathways, etc. (for which a gene is involved in) from the necessary database where the information is stored. The database you choose will be dependent on what type of information you are trying to obtain. Examples of databases that are often queried include:\nGeneral databases\nOffer comprehensive information on genome features, feature coordinates, homology, variant information, phenotypes, protein domain/family information, associated biological processes/pathways, associated microRNAs, etc.:\n\nEnsembl (use Ensembl gene IDs)\nNCBI (use Entrez gene IDs)\nUCSC\nEMBL-EBI\n\nAnnotation-specific databases\nProvide annotations related to a specific topic:\n\nGene Ontology (GO): database of gene ontology biological processes, cellular components and molecular functions - based on Ensembl or Entrez gene IDs or official gene symbols\nKEGG: database of biological pathways - based on Entrez gene IDs\nMSigDB: database of gene sets\nReactome: database of biological pathways\nHuman Phenotype Ontology: database of genes associated with human disease\nCORUM: database of protein complexes for human, mouse, rat\n…\n\nThis is by no means an exhaustive list, there are many other databases available that are not listed here.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#genome-builds",
    "href": "lessons/01a_RNAseq_processing_workflow.html#genome-builds",
    "title": "Genomic annotations",
    "section": "Genome builds",
    "text": "Genome builds\nBefore you begin your search through any of these databases, you should know which build of the genome was used to generate your gene list and make sure you use the same build for the annotations during functional analysis. When a new genome build is acquired, the names and/or coordinate location of genomic features (gene, transcript, exon, etc.) may change. Therefore, the annotations regarding genome features (gene, transcript, exon, etc.) is genome build-specific and we need to make sure that our annotations are obtained from the appropriate resource.\nFor example, if we used the GRCh38 build of the human genome to quantify gene expression used for differential expression analysis, then we should use the same GRCh38 build of the genome to convert between gene IDs and to identify annotations for each of the genes.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#tools-for-accessing-databases",
    "href": "lessons/01a_RNAseq_processing_workflow.html#tools-for-accessing-databases",
    "title": "Genomic annotations",
    "section": "Tools for accessing databases",
    "text": "Tools for accessing databases\nWithin R, there are many popular packages used for gene/transcript-level annotation. These packages provide tools that take the list of genes you provide and retrieve information for each gene using one or more of the databases listed above.\n\nAnnotation tools: for accessing/querying annotations from a specific databases\n\n\n\nTool\nDescription\nPros\nCons\n\n\n\n\norg.Xx.eg.db\nQuery gene feature information for the organism of interest\ngene ID conversion, biotype and coordinate information\nonly latest genome build available\n\n\nEnsDb.Xx.vxx\nTranscript and gene-level information directly fetched from Ensembl API (similar to TxDb, but with filtering ability and versioned by Ensembl release)\neasy functions to extract features, direct filtering\nNot the most up-to-date annotations, more difficult to use than some packages\n\n\nTxDb.Xx.UCSC.hgxx.knownGene\nUCSC database for transcript and gene-level information or can create own TxDb from an SQLite database file using the GenomicFeatures package\nfeature information, easy functions to extract features\nonly available current and recent genome builds - can create your own, less up-to-date with annotations than Ensembl\n\n\nannotables\nGene-level feature information immediately available for the human and model organisms\nsuper quick and easy gene ID conversion, biotype and coordinate information\nstatic resource, not updated regularly\n\n\nbiomaRt\nAn R package version of the Ensembl BioMart online tool\nall Ensembl database information available, all organisms on Ensembl, wealth of information\n\n\n\n\n\n\nInterface tools: for accessing/querying annotations from multiple different annotation sources\n\nAnnotationDbi: queries the OrgDb, TxDb, Go.db, EnsDb, and BioMart annotations.\n\nAnnotationHub: queries large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nThese are both packages that can be used to create the tx2gene files we had you download at the beginning of this workshop.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#annotationdbi-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#annotationdbi-1",
    "title": "Genomic annotations",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\nWhile AnnotationDbi is a popular tool, we will not be walking through code to use this package. However, if you are interested in more detail, we have materials linked here with examples using our current dataset.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#annotationhub",
    "href": "lessons/01a_RNAseq_processing_workflow.html#annotationhub",
    "title": "Genomic annotations",
    "section": "AnnotationHub",
    "text": "AnnotationHub\nAnnotationHub is a wonderful resource for accessing genomic data or querying large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc. All of this information is stored and easily accessible by directly connecting to the database.\nTo get started with AnnotationHub, we first load the library and connect to the database:\n# Load libraries\nlibrary(AnnotationHub)\nlibrary(ensembldb)\n\n# Connect to AnnotationHub\nah &lt;- AnnotationHub()\n\n\n\n\n\n\nWhat is a cache?\n\n\n\nA cache is used in R to store data or a copy of the data so that future requests can be served faster without having to re-run a lengthy computation.\nThe AnnotationHub() command creates a client that manages a local cache of the database, helping with quick and reproducible access. When encountering question AnnotationHub does not exist, create directory?, you can answer either yes (create a permanent location to store cache) or no (create a temporary location to store cache). hubCache(ah) gets the file system location of the local AnnotationHub cache. hubUrl(ah) gets the URL for the online hub.\n\n\nTo see the types of information stored inside our database, we can just type the name of the object. Using the output, you can get an idea of the information that you can query within the AnnotationHub object:\n# Explore the AnnotationHub object\nah\nNotice the note on retrieving records with object[[ID]] - this will be how we can extract a single record from the AnnotationHub object.\nIf you would like to see more information about any of the classes of data, you can extract that information as well. For example, if you wanted to determine all species information available, you could explore that within the AnnotationHub object:\n# Explore all species information available\nunique(ah$species) %&gt;% head()\nIn addition to species information, there is also additional information about the type of Data Objects and the Data Providers:\n# Explore the types of Data Objects available\nunique(ah$rdataclass) %&gt;% head()\n\n# Explore the Data Providers\nunique(ah$dataprovider) %&gt;% head()\nNow that we know the types of information available from AnnotationHub, we can query it for the information we want using the query() function. Let’s say we would like to return the Ensembl EnsDb information for Human. To return the records available, we need to use the terms as they are output from the ah object to extract the desired data.\n# Query AnnotationHub for Human references\nhuman_ens &lt;- query(ah, c(\"Homo sapiens\", \"EnsDb\"))\n\n# See what annotations are available\nhuman_ens\nThe query retrieves all hits for the EnsDb objects, and you will see that they are listed by the release number. The most current release for GRCh38 is Ensembl 113 and AnnotationHub offers that as an option to use. However, if you look at options for older releases, for Homo sapiens it only go back as far as Ensembl 87. This is fine if you are using GRCh38; however, if you were using an older genome build like hg19/GRCh37, you would need to load the EnsDb package if available for that release or you might need to build your own with ensembldb.\nIn our case, we are looking for the latest Ensembl release so that the annotations are the most up-to-date. To extract this information from AnnotationHub, we can use the AnnotationHub ID to subset the object:\n# Extract annotations of interest\nhuman_ens &lt;- human_ens[[\"AH119325\"]]\nNow we can use ensembldb functions to extract the information at the gene, transcript, or exon levels. We are interested in the gene-level annotations, so we can extract that information as follows:\n# Extract gene-level information\ngenes(human_ens, return.type = \"data.frame\") %&gt;% head()\nBut note that it is just as easy to get the transcript- or exon-level information:\n# Extract transcript-level information\ntranscripts(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n# Extract exon-level information\nexons(human_ens, return.type = \"data.frame\") %&gt;% head()\nTo obtain an annotation data frame using AnnotationHub, we’ll use the genes() function, but only keep selected columns and filter out rows to keep those corresponding to our gene identifiers in our results file:\n# Create a gene-level dataframe \nannotations_ahb &lt;- genes(human_ens, return.type = \"data.frame\") %&gt;%\n  # Choose which columns to keep\n  dplyr::select(gene_id, gene_name, entrezid, gene_biotype) %&gt;%\n  # Choose which rows to keep (only genes that are in our overexpression results)\n  dplyr::filter(gene_id %in% res_tableOE_tb$gene)\nThis dataframe looks like it should be fine as it is, but we look a little closer we will notice that the column containing Entrez identifiers is a list, and in fact there are many Ensembl identifiers that map to more than one Entrez identifier!\n# Wait a second, we don't have one-to-one mappings!\nclass(annotations_ahb$entrezid)\nwhich(map(annotations_ahb$entrezid, length) &gt; 1) %&gt;% head()\nSo what do we do here? And why do we have this problem? An answer from the Ensembl Help Desk is that this occurs when we cannot choose a perfect match; i.e., when we have two good matches, but one does not appear to match with a better percentage than the other. In that case, we assign both matches. What we will do is choose to keep the first identifier for these multiple mapping cases.\n# Only keep the first identifier in each list\nannotations_ahb$entrezid &lt;- map(annotations_ahb$entrezid, 1) %&gt;% unlist()\n\n\n\n\n\n\nNote\n\n\n\nNot all databases handle multiple mappings in the same way. For example, if we used the OrgDb instead of the EnsDb:\n#| eval: false\n\n# Pull annotations from OrgDb\nhuman_orgdb &lt;- query(ah, c(\"org.Hs.eg.db.sqlite\"))\nhuman_orgdb &lt;- human_orgdb[[\"AH116710\"]]\nannotations_orgdb &lt;- AnnotationDbi::select(human_orgdb, res_tableOE_tb$gene, c(\"SYMBOL\", \"GENENAME\", \"ENTREZID\"), \"ENSEMBL\")\nWe would find that multiple mapping entries would be automatically reduced to one-to-one. We would also find that more than half of the input genes do not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. Since our data is based on Ensembl mappings, using the OrgDb would result in a loss of information.\n\n\nLet’s take a look and see how many of our Ensembl identifiers have an associated gene symbol, and how many of them are unique:\n# Total Ensembl IDs with associated gene symbols\nwhich(!is.na(annotations_ahb$gene_name)) %&gt;% length()\n\n# Duplicated gene symbols\nwhich(duplicated(annotations_ahb$gene_name)) %&gt;% length()\nLet’s identify the non-duplicated genes and only keep the ones that are not duplicated:\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_ahb$gene_name) == FALSE)\n\n# How many rows does annotations_ahb have?\nannotations_ahb %&gt;% nrow()\n\n# Return only the non-duplicated genes using indices\nannotations_ahb &lt;- annotations_ahb[non_duplicates_idx, ]\n\n# How many rows are we left with after removing?\nannotations_ahb %&gt;% nrow()\nFinally, it would be good to know what proportion of the Ensembl identifiers map to an Entrez identifier:\n# Determine how many of the Entrez column entries are NA\nwhich(is.na(annotations_ahb$entrezid)) %&gt;% length()\nThat’s almost half of our genes! If we plan on using Entrez ID results for downstream analysis, we should definitely keep this in mind. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The discrepancy (which we can expect to observe) between databases is due to the fact that each implements its own different computational approaches for generating the gene builds.\n\nUsing AnnotationHub to create our tx2gene file\nTo create our tx2gene file, we would need to use a combination of the methods above and merge two dataframes together. For example:\n#| eval: false\n\n## DO NOT RUN THIS CODE\n\n# Create a transcript dataframe\ntxdb &lt;- transcripts(human_ens, return.type = \"data.frame\") %&gt;%\n  dplyr::select(tx_id, gene_id)\ntxdb &lt;- txdb[grep(\"ENST\", txdb$tx_id),]\n\n# Create a gene-level dataframe\ngenedb &lt;- genes(human_ens, return.type = \"data.frame\")  %&gt;%\n  dplyr::select(gene_id, gene_name)\n\n# Merge the two dataframes together\nannotations &lt;- inner_join(txdb, genedb)\nIn this lesson our focus has been using annotation packages to extract information mainly just for gene ID conversion for the different tools that we use downstream. Many of the annotation packages we have presented have much more information than what we need for functional analysis, and we have only just scratched the surface here. It’s good to know the capabilities of the tools we use, so we encourage you to spend some time exploring these packages to become more familiar with them.\n\n\n\n\n\n\nNote\n\n\n\nThe annotables package is a super easy annotation package to use. It is not updated frequently, so it’s not great for getting the most up-to-date information for the current builds and does not have information for other organisms than human and mouse, but is a quick way to get annotation information.\n#| eval: false\n\n# Install package\nBiocManager::install(\"annotables\")\n\n# Load library\nlibrary(annotables)\n\n# Access previous build of annotations\ngrch38\n\n\n#| echo: false\n\n# save objects needed to render future lessons\nsaveRDS(annotations_ahb, \"../data/intermediate_annotations_ahb.RDS\")",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-17",
    "href": "lessons/01a_RNAseq_processing_workflow.html#learning-objectives-17",
    "title": "Genomic annotations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain and interpret QC on count data using Principal Component Analysis (PCA) and hierarchical clustering\nImplement DESeq2 to obtain a list of significantly different genes\nPerform functional analysis on gene lists with R-based tools",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#installations",
    "href": "lessons/01a_RNAseq_processing_workflow.html#installations",
    "title": "Genomic annotations",
    "section": "Installations",
    "text": "Installations\nFollow the instructions linked here to download R and RStudio + Install Packages from CRAN and Bioconductor",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#lessons",
    "href": "lessons/01a_RNAseq_processing_workflow.html#lessons",
    "title": "Genomic annotations",
    "section": "Lessons",
    "text": "Lessons\n\nPart 1 (Getting Started)\n\nWorkflow (raw data to counts)\nExperimental design considerations\nIntro to DGE / setting up DGE analysis\n\n\n\n\nPart II (QC and setting up for DESeq2)\n\nRNA-seq counts distribution\nCount normalization\nSample-level QC (PCA and hierarchical clustering)\nDesign formulas\nHypothesis testing and multiple test correction\n\n\n\n\nPart III (DESeq2)\n\nDescription of steps for DESeq2\nWald test results\nSummarizing results and extracting significant gene lists\nVisualization\nLikelihood Ratio Test results\nTime course analysis\n\n\n\n\nPart IV (Functional Analysis)\n\nGene annotation\nFunctional analysis - over-representation analysis\nFunctional analysis - functional class scoring / GSEA\n\n\nWorkflow Summary",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#building-on-this-workshop",
    "href": "lessons/01a_RNAseq_processing_workflow.html#building-on-this-workshop",
    "title": "Genomic annotations",
    "section": "Building on this workshop",
    "text": "Building on this workshop\n\nSingle-cell RNA-seq workshop\nRMarkdown\nGgplot2 for functional analysis",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#resources",
    "href": "lessons/01a_RNAseq_processing_workflow.html#resources",
    "title": "Genomic annotations",
    "section": "Resources",
    "text": "Resources\n\nDESeq2 vignette\nGitHub book on RNA-seq gene level analysis\nBioconductor support site (posts tagged with deseq2)\nFunctional analysis visualization\n\n\nSPIA\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\n\n# load objects needed to render this lesson\nres_entrez &lt;- readRDS(\"../data/intermediate_res_entrez.RDS\")\nThe SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. The blog post from Getting Genetics Done provides a step-by-step procedure for using and understanding SPIA.\n# Install package (if needed)\n# BiocManager::install(\"SPIA\")\n\n# Load package\nlibrary(SPIA)\nTo perform SPIA, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n# The background set is a vector of all the genes represented on the platform\nbackground_entrez &lt;- res_entrez$entrezid\n\n# Significant genes is a vector of fold changes where the names are ENTREZ gene IDs\nsig_res_entrez &lt;- res_entrez[which(res_entrez$padj &lt; 0.05), ]\nsig_entrez &lt;- sig_res_entrez$log2FoldChange\nnames(sig_entrez) &lt;- sig_res_entrez$entrezid\n\n# Look at the significant gene list input\nhead(sig_entrez)\nNow that we have our background and significant genes in the appropriate format, we can run SPIA (this will take a few minutes as it runs through all the pathways):\n# Run SPIA\nspia_result &lt;- spia(de=sig_entrez, all=background_entrez, organism=\"hsa\")\n\n# Look at the results\nhead(spia_result, n=20)\nSPIA outputs a table showing significantly dysregulated pathways based on over-representation and signaling perturbations accumulation. The table shows the following information:\n\npSize: the number of genes on the pathway\nNDE: the number of DE genes per pathway\ntA: the observed total perturbation accumulation in the pathway\npNDE: the probability to observe at least NDE genes on the pathway using a hypergeometric model (similar to ORA)\npPERT: the probability to observe a total accumulation more extreme than tA only by chance\npG: the p-value obtained by combining pNDE and pPERT\npGFdr and pGFWER are the False Discovery Rate and Bonferroni adjusted global p-values, respectively\nStatus: gives the direction in which the pathway is perturbed (activated or inhibited)\nKEGGLINK gives a web link to the KEGG website that displays the pathway image with the differentially expressed genes highlighted in red\n\nWe can view the significantly dysregulated pathways by viewing the over-representation and perturbations for each pathway.\n# To avoid an error, remove any rows where `pPERT` is NA\nspia_result &lt;- spia_result %&gt;% filter(!is.na(pPERT))\n\n# Plot significant pathways\nplotP(spia_result, threshold=0.05)\nIn this plot, each pathway is a point and the coordinates are the log of pNDE (using a hypergeometric model) and the p-value from perturbations, pPERT. The oblique lines in the plot show the significance regions based on the combined evidence.\nIf we choose to explore the significant genes from our dataset occurring in these pathways, we can subset our SPIA results:\n# Look at pathway 05203 and view kegglink\nsubset(spia_result, ID == \"05203\")\nThen, if we click on the KEGGLINK, we can view the genes within our dataset from these perturbed pathways:\n\n\n\nKEGG pathway with significant genes highlighted\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). Details regarding PCA are given below (based on materials from StatQuest, and if you would like a more thorough description, we encourage you to explore StatQuest’s video.\nIf you had two samples and wanted to plot the counts of one sample versus another, you could plot the counts of one sample on the x-axis and the other sample on the y-axis as shown below:\n\nYou could draw a line through the data in the direction representing the most variation, which is on the diagonal in this example. The maximum variation in the data is between the two endpoints of this line.\nWe also see the genes vary somewhat above and below the line. We could draw another line through the data representing the second most amount of variation in the data.\n\nThe genes near the ends of the line, which would include those genes with the highest variation between samples (high expression in one sample and low expression in the other), have the greatest influence on the direction of the line.\n\nFor example, a small change in the value of Gene C would greatly change the direction of the line, whereas a small change in Gene A or Gene D would have little affect.\n\nWe could just rotate the entire plot and view the lines representing the variation as left-to-right and up-and-down. We see most of the variation in the data is left-to-right; this is and the second most variation in the data is up-and-down. These axes that represent the variation are “Principal Components”, with PC1 representing the most variation in the data and PC2 representing the second most variation in the data.\nIf we had three samples, then we would have an extra direction in which we could have variation. Therefore, if we have N samples we would have N-directions of variation or principal components.\n\nWe could give quantitative scores to genes based on how much they influence PC1 and PC2. Genes with little influence would get scores near zero, while genes with more influence would receive larger scores. Genes on opposite ends of the lines have a large influence, so they would receive large scores, but with opposite signs.\n\nTo generate a score per sample, we combine the read counts for all genes. To calculate the scores, we do the following:\nSample1 PC1 score = (read count * influence) + ... for all genes\nUsing the counts in the table for each gene (assuming we had only 4 genes total) we could calculate PC1 and PC2 values for each sample as follows:\nSample1 PC1 score = (4 * -2) + (1 * -10) + (8 * 8) + (5 * 1) = 51\nSample1 PC2 score = (4 * 0.5) + (1 * 1) + (8 * -5) + (5 * 6) = -7\n\nSample2 PC1 score = (5 * -2) + (4 * -10) + (8 * 8) + (7 * 1) = 21\nSample2 PC2 score = (5 * 0.5) + (4 * 1) + (8 * -5) + (7 * 6) = 8.5\nThe scores would then be plotted to examine whether the samples exhibit similar variation across all genes:\n\nSince genes with the greatest variation between samples will have the greatest influence on the principal components, we hope our condition of interest explains this variation (e.g. high counts in one condition and low counts in the other). With PC1 representing the most variation in the data and PC2 representing the second most variation in the data, we can visualize how similar the variation of genes is between samples.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#pre-reading",
    "href": "lessons/01a_RNAseq_processing_workflow.html#pre-reading",
    "title": "Genomic annotations",
    "section": "Pre-reading",
    "text": "Pre-reading\n\nWorkflow (raw data to counts)\nExperimental design considerations",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#day-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#day-1",
    "title": "Genomic annotations",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 10:30\nWorkshop Introduction\nWill\n\n\n10:30 - 11:00\nRNA-seq pre-reading discussion\nAll\n\n\n11:00 - 11:45\nIntro to DGE / setting up DGE analysis\nMeeta\n\n\n11:45 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nRNA-seq counts distribution\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nStarting with the count matrix, we want to explore some characteristics of the RNA-seq data and evaluate the appropriate model to use.\nThis lesson will cover:\n\nDescribing characteristics of the RNA-seq count data\nUnderstanding different statistical methods to model the count data\nExplaining the benefits of biological replicates\n\n\n\n\n\nCount normalization\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nCount normalization is an important data pre-processing step before the differential expression analysis.\nThis lesson will cover:\n\nDescribing “uninteresting factors” to consider during normalization\nUnderstanding different normalization methods and their corresponding use cases\nGenerating a matrix of normalized counts using DESeq2’s median of ratios method\n\n\n\n\n\nSample-level QC (PCA and hierarchical clustering)\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nNext, we want to check the quality of count data, to make sure that the samples are good.\nThis lesson will cover:\n\nUnderstanding the importance of similarity analysis between samples\nDescribing Principal Component Analysis (PCA) and interpreting PCA plots from RNA-seq data\nPerforming hierarchical clustering and plotting correlation metrics\n\n\n\n\n\nComplete the exercises:\n\nEach lesson above contains exercises; please go through each of them.\nCopy over your solutions into the Google Form the day before the next class.\n\n\n\n\nQuestions?\n\nIf you get stuck due to an error while runnning code in the lesson, email us",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#day-2",
    "href": "lessons/01a_RNAseq_processing_workflow.html#day-2",
    "title": "Genomic annotations",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:00\nSelf-learning lessons discussion\nAll\n\n\n11:00 - 11:30\nDesign formulas\nWill\n\n\n11:30 - 12:00\nHypothesis testing and multiple test correction\nMeeta\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nDescription of steps for DESeq2\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nThe R code required to perform differential gene expression analysis is actually quite simple. Running the DESeq() function will carry out the various steps involved. It is important that you have some knowledge of what is happening under the hood, to be able to fully understand and interpret the results.\nIn this lesson you will:\n\nExamine size factors and learn about sources that cause observed variation in values\nExplore the gene-wise dispersion estimates as they relate back the mean-variance relationship\nCritically evaluate a dispersion plot\n\n\n\n\n\nWald test results\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nWe have run the analysis, and now it’s time to explore the results!\nIn this lesson you will:\n\nLearn how to extract results for specific group comparisons\nExplore the information presented in the results table (different statistics and their importance)\nUnderstand the different levels of filtering that are applied in DESeq2 by default (and why they are important)\n\n\n\n\n\nSummarizing results and extracting significant gene lists\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nOnce you have your results, it is useful to summarize the information. Here, we get a snapshot of the number of differentially expressed genes that are identified from the different comparisons.\n\n\n\n\nVisualization\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nA picture is worth a thousand words. In our case, a figure is worth a thousand (or 30 thousand) data points. When working with large scale data, it can be helpful to visualize results and get a big picture perspective of your findings.\nIn this lesson you will:\n\nExplore different plots for data visualization\nCreate a volcano plot to evaluate the relationship between different statistics from the results table\nCreate a heatmap for visualization of differentially expressed genes\n\n\n\n\n\nComplete the exercises:\n\nEach lesson above contains exercises; please go through each of them.\nCopy over your solutions into the Google Form the day before the next class.\n\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#day-3",
    "href": "lessons/01a_RNAseq_processing_workflow.html#day-3",
    "title": "Genomic annotations",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:15\nSelf-learning lessons discussion\nAll\n\n\n11:15 - 12:00\nLikelihood Ratio Test results\nMeeta\n\n\n\n\nBefore the next class:\n\nPlease study the contents and work through all the code within the following lessons:\n\n\nTime course analysis\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nSometimes we are interested in how a gene changes over time. The Likelihood Ratio Test (LRT) is paricularly well-suited for this task.\nThis lesson will cover:\n\nDesigning a LRT for a time-course analysis in DESeq2\nIdentifying patterns in our list of differentially expressed genes\n\n\n\n\n\nGene annotation\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nNext-generation analyses rely on annotations to provide a description for defining genes, transcripts and/or proteins. These annotations are often stored in publicly available databases.\nThis lesson will cover:\n\nDescribing the various annotation databases\nAccessing annotations from one of these databases using R\n\n\n\n\n\nFunctional analysis - over-representation analysis\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nOftentimes after completing an RNA-seq experiment, you will be left with a list of differentially expressed transcripts. You may be interested in knowing if these transcripts are enriched in certain biologically-relevant contexts.\nThis lesson will cover:\n\nDescribing how functional enrichment tools yield statistically enriched functional categories or interactions\nIdentifying enriched Gene Ontology terms using the R package, clusterProfiler\n\n\n\n\n\nFunctional analysis - functional class scoring / GSEA\n\n\n\n\n\n\n\nClick here for a preview of this lesson\n\n\n\n\n\nWhile some functional analyses focus on large changes focused on a select few genes, functional class scoring (FCS) focuses on weaker but coordinated changes in sets of functionally related genes (i.e., pathways) that can also have significant effects.\nThis lesson will cover:\n\nDesigning a GSEA analysis using GO and/or KEGG gene sets\nEvaluating the results of a GSEA analysis\nDiscussing other tools and resources for identifying genes of novel pathways or networks\n\n\n\n\n\nThere is no assignment submission, but please use this Google form to ask us questions!\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#day-4",
    "href": "lessons/01a_RNAseq_processing_workflow.html#day-4",
    "title": "Genomic annotations",
    "section": "Day 4",
    "text": "Day 4\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n10:00 - 11:00\nQuestions about self-learning lessons\nAll\n\n\n11:00 - 11:15\nSummarizing workflow\nWill\n\n\n11:15 - 11:45\nDiscussion, Q & A\nAll\n\n\n11:45 - 12:00\nWrap Up\nWill",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#answer-keys",
    "href": "lessons/01a_RNAseq_processing_workflow.html#answer-keys",
    "title": "Genomic annotations",
    "section": "Answer keys",
    "text": "Answer keys\n\nDay 1 Answer Key\nDay 2 Answer Key",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#resources-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#resources-1",
    "title": "Genomic annotations",
    "section": "Resources",
    "text": "Resources\nWe have covered the inner workings of DESeq2 in a fair amount of detail such that when using this package you have a good understanding of what is going on under the hood. For more information on topics covered, we encourage you to take a look at the following resources:\n\nDESeq2 vignette\nGitHub book on RNA-seq gene level analysis\nBioconductor support site (posts tagged with deseq2)\nEnrichment analysis book\n\nVisualization: Functional (Enrichment) analysis",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#building-on-this-workshop-1",
    "href": "lessons/01a_RNAseq_processing_workflow.html#building-on-this-workshop-1",
    "title": "Genomic annotations",
    "section": "Building on this workshop",
    "text": "Building on this workshop\n\nSingle-cell RNA-seq workshop\nRMarkdown\nggplot2 for functional analysis",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01a_RNAseq_processing_workflow.html#other-helpful-links",
    "href": "lessons/01a_RNAseq_processing_workflow.html#other-helpful-links",
    "title": "Genomic annotations",
    "section": "Other helpful links",
    "text": "Other helpful links\n\nOnline hbctraining learning materials\nhbctraining webpage\n\n\nUsing ggplot2 to plot multiple genes (e.g. top 20)\n#| echo: false\n\n# load libraries needed to render this lesson\nlibrary(tidyverse)\n\n# load objects needed to render this lesson\nres_tableOE_tb    &lt;- readRDS(\"../data/intermediate_res_tableOE_tb.RDS\")\nnormalized_counts &lt;- readRDS(\"../data/intermediate_normalized_counts_with_gene_names.RDS\")\nmeta              &lt;- readRDS(\"../data/metadata.RDS\")\nmov10_meta &lt;- meta %&gt;% rownames_to_column(var=\"samplename\") %&gt;% as_tibble()\nOften it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling.\nWe are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values):\n# Order results by padj values\ntop20_sigOE_genes &lt;- res_tableOE_tb %&gt;% \n  arrange(padj) %&gt;% # Arrange rows by padj values\n  pull(gene) %&gt;%        # Extract character vector of ordered genes\n  head(n=20)            # Extract the first 20 genes\nThen, we can extract the normalized count values for these top 20 genes:\n# Get normalized counts for top 20 significant genes\ntop20_sigOE_norm &lt;- normalized_counts %&gt;%\n  filter(gene %in% top20_sigOE_genes)\nNow that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.\nThe gather() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth.\n\n# Gathering the columns to have normalized counts to a single column\ngathered_top20_sigOE &lt;- top20_sigOE_norm %&gt;%\n  gather(colnames(top20_sigOE_norm)[2:9], key = \"samplename\", value = \"normalized_counts\")\n\n# Check the column header in the \"gathered\" data frame\nhead(gathered_top20_sigOE)\nNow, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot():\n# Add metadata\ngathered_top20_sigOE &lt;- inner_join(mov10_meta, gathered_top20_sigOE)\nThe inner_join() will merge 2 data frames with respect to any column with the same column name in both data frames: in this case, the “samplename” column.\nNow that we have a data frame in a format that can be utilized by ggplot easily, let’s plot!\n# Plot using ggplot2\nggplot(gathered_top20_sigOE) +\n  geom_point(aes(x = symbol, y = normalized_counts, color = sampletype)) +\n  scale_y_log10() +\n  # Add title and plot tweaks\n  xlab(\"Genes\") +\n  ylab(\"log10 Normalized Counts\") +\n  ggtitle(\"Top 20 Significant DE Genes\") +\n  theme_bw() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  theme(plot.title = element_text(hjust = 0.5))",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/09_DGE_DESeq2_analysis.html",
    "href": "lessons/09_DGE_DESeq2_analysis.html",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/09_DGE_DESeq2_analysis.html#learning-objectives",
    "href": "lessons/09_DGE_DESeq2_analysis.html#learning-objectives",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain the different steps involved in running DESeq()\nExamine size factors and understand the source of differences\nInspect gene-level dispersion estimates\nRecognize the importance of dispersion during differential expression analysis",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/09_DGE_DESeq2_analysis.html#deseq2-differential-gene-expression-analysis-workflow",
    "href": "lessons/09_DGE_DESeq2_analysis.html#deseq2-differential-gene-expression-analysis-workflow",
    "title": "Gene-level differential expression analysis with DESeq2",
    "section": "DESeq2 differential gene expression analysis workflow",
    "text": "DESeq2 differential gene expression analysis workflow\nPreviously, we created the DESeq2 object using the appropriate design formula and running DESeq2 using the two lines of code:\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\nWe completed the entire workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below:\n\n\n\nWe will be taking a detailed look at each of these steps to better understand how DESeq2 is performing the statistical analysis and what metrics we should examine to explore the quality of our analysis.\n\nStep 1: Estimate size factors\nThe first step in the differential expression analysis is to estimate the size factors, which is exactly what we already did to normalize the raw counts.\n\n\n\nDESeq2 will automatically estimate the size factors when performing the differential expression analysis. However, if you have already generated the size factors using estimateSizeFactors(), as we did earlier, then DESeq2 will use these values.\nTo normalize the count data, DESeq2 calculates size factors for each sample using the median of ratios method discussed previously in the ‘Count normalization’ lesson.\n\nMOV10 DE analysis: examining the size factors\nLet’s take a quick look at size factor values we have for each sample:\n\n# Check the size factors\nsizeFactors(dds)\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n 1.1150371  0.9606366  0.7493552  1.5634128  0.9359082  1.2257749  1.1406863 \nMov10_oe_3 \n 0.6541689 \n\n\nThese numbers should be identical to those we generated initially when we had run the function estimateSizeFactors(dds). Take a look at the total number of reads for each sample:\n\n# Total number of raw counts per sample\ncolSums(counts(dds))\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n  31160785   26504972   20498243   45300696   26745860   32062221   30025690 \nMov10_oe_3 \n  17285401 \n\n\nHow do the numbers correlate with the size factor?\nWe see that the larger size factors correspond to the samples with higher sequencing depth, which makes sense, because to generate our normalized counts we need to divide the counts by the size factors. This accounts for the differences in sequencing depth between samples.\nNow take a look at the total depth after normalization using:\n\n# Total number of normalized counts per sample\ncolSums(counts(dds, normalized=T))\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n  27945962   27591050   27354509   28975519   28577441   26156696   26322477 \nMov10_oe_3 \n  26423452 \n\n\nHow do the values across samples compare with the total counts taken for each sample?\nYou might have expected the counts to be the exact same across the samples after normalization. However, DESeq2 also accounts for RNA composition during the normalization procedure. By using the median ratio value for the size factor, DESeq2 should not be biased to a large number of counts sucked up by a few DE genes; however, this may lead to the size factors being quite different than what would be anticipated just based on sequencing depth.\n\n\n\nStep 2: Estimate gene-wise dispersion\nThe next step in the differential expression analysis is the estimation of gene-wise dispersions. Before we get into the details, we should have a good idea about what dispersion is referring to in DESeq2.\n\n\n\nIn RNA-seq count data, we know:\n\nTo determine differentially expressed genes, we evaluate the variation of expression between groups (of interest) and compare that to the variation within the groups (between replicates).\nFor each individual gene, the mean is not equal to the variance.\n\n\nGenes that are highly expressed will have a more consistent level of variations, but it will be higher than the mean.\nLowly expressed genes will exhibit variation that hovers around the mean (but with a higher amount of variability).\n\nThis complicated relationship means that we cannot just use the observed variance to account for within-group variation. Instead DESeq2 uses dispersion.\n\n\n\nWhat is dispersion?\nThe dispersion parameter models the within-group variability by describing how much the variance deviates from the mean. A dispersion of 1 would indicate that there is no deviance from the mean (i.e., mean == variance). A typical RNA-seq dataset will exhibit some amount of biological variability present across replicates and so we will always have dispersion values less than one.\n\n\n\n\nEffect on dispersion\n\n\n\n\nVariance increases\nDispersion increases\n\n\nMean expression increases\nDispersion decreases\n\n\n\nDispersion values in DESeq2\nDESeq2 estimates the dispersion for each gene based on the gene’s expression level (mean counts of within-group replicates) and observed variance across replicates, as we demonstrated with the formula above. In this way, the dispersion estimates for genes with the same mean will differ only based on their variance. Therefore, the dispersion estimates reflect the variance in gene expression for a given mean value.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this plot we have dispersion on the y-axis and mean normalized counts on the x-axis. Each black dot represents a gene and its intial maximum likelihood dispersion estimate (MLE) given the observed data. Simply looking at the trend of black dots, we observe an inverse relationship between mean and dispersion. More detail on the fitted red line and blue dots will be described later in this lesson.\n\n\nSince we have only a few (3-6) replicates per group, the dispersion estimates for each gene are often unreliable. As we walk through the next few steps, we will discuss how this issue is resolved.\n\n\nStep 3: Fit curve to gene-wise dispersion estimates\nThe next step in the workflow is to fit a curve to the gene-wise dispersion estimates. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability but, across all genes, there will be a distribution of reasonable estimates of dispersion.\n\n\n\nThis curve is displayed as a red line in the figure presented below. This fitted line allows DESeq2 to utilize information across all genes to generate more accurate estimates using a method called ‘shrinkage’ (described in Step 4).\n\n\n\n\n\nStep 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve\nThe next step in the workflow is to shrink the gene-wise dispersion estimates toward the expected dispersion values.\n\n\n\nDESeq2 assumes that genes with similar expression levels should have similar dispersion. As such, the fitted curve provides a range of expected dispersion values a range of mean expression level.\nIf the initial estimate (black dot) is much lower than the fitted curve, then values are shrunken (blue dots) towards the red line. Dispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation; however, genes with extremely high dispersion values are not (see right side figure below; these genes are shown surrounded by blue circle). This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons [1].\n\n\n\nMAP, maximum a posteriori; MLE, maximum-likelihood estimate. For more detailed information please see Love MI, Huber W, Anders S, Genome Biology 2014\nThe strength of the shrinkage for each gene depends on:\n\nhow close gene dispersions are from the curve\nsample size (more samples = less shrinkage)\n\nThis dispersion shrinkage method is particularly important to reduce false positives in the differential expression analysis. This step allows for more accurate identification of differentially expressed genes when sample sizes are small.\n\n\nInterpretation of the dispersion plot\nTo create this plot with your data, you use the function:\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\n\n\n\n\n\n\nThis is a good plot to examine to ensure your data is a good fit for the DESeq2 model. Evaluate the plot to see:\n\nWhether the data points generally scatter around the curve, with the dispersion decreasing with increasing mean expression levels.\nHow much shrinkage you get across the whole range of means in your data. For any experiment with low degrees of freedom, you will expect to see more shrinkage.\nIf the data scatter in a cloud or different shapes, then you might want to explore your data more to see if you have contamination (mitochondrial, etc.) or outlier samples.\n\nExamples of worrisome dispersion plots are shown below:\nThe plot below shows a cloud of dispersion values, which do not generally follow the curve. This would be worrisome and suggests a bad fit of the data to the model.\n\n\n\nThe next plot shows the dispersion values initially decreasing, then increasing with larger expression values. The larger mean expression values should not have larger dispersions based on our expectations - we expect decreasing dispersions with increasing mean. This indicates that there is less variation for more highly expressed genes than expected. This also indicates that there could be an outlier sample or contamination present in our analysis.\n\n\n\n\nMOV10 DE analysis: exploring the dispersion estimates and assessing model fit\nLet’s take a look at the dispersion estimates for our MOV10 data:\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\n\n\n\n\n\n\nSince we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model?\nWe see a nice decrease in dispersion with increasing mean expression, which is good. We also see the dispersion estimates generally surround the curve, which is also expected. Overall, this plot looks good. We do see strong shrinkage, which is likely due to the fact that we have only two replicates for one of our sample groups. The more replicates we have, the less shrinkage is applied to the dispersion estimates, and the more DE genes are able to be identified. We would generally recommend having at least 4 biological replicates per condition for better estimation of variation.\n\n\n\n\n\n\nExercise 1\n\n\n\nGiven the dispersion plot below, would you have any concerns regarding the fit of your data to the model?\n\nIf not, what aspects of the plot makes you feel confident about your data?\nIf so, what are your concerns? What would you do to address them?\n\n\n\n\n\n\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Gene-level differential expression analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/08_hypothesis_testing_Answers.html",
    "href": "lessons/08_hypothesis_testing_Answers.html",
    "title": "Hypothesis testing and multiple testing - Answer key",
    "section": "",
    "text": "Exercise 1\nYou are studying brain maturation and growth patterns in mouse cortex and have obtained RNA-seq data for a total of 24 mice. These samples were acquired at 2 developmental stages (3 dpf and 10 dpf) and with or without treatment using a growth inhibitor (Monoamine oxidase (MAO) inhibitors). For each developmental stage and treatment combination you have 6 replicates. You also have sex information for these mice (12 males and 12 females).\nWhat steps are necessary to take to decide what your model should be?\nLook at QC analyses such as PCA to determine which metadata factors are associated with large amounts of variation in the data.\nWhat is an appropriate hypothesis test if you are testing for expression differences across the developmental stages?\nWe only have 2 developmental stages, so we can use the Wald test for comparison.\nProvide the line of code used to create the dds object.\nHere we assume that the metadata includes the following columns: developmental_stage, treatment, and sex. We want to include treatment and sex as covariates in our model, but make sure that developmental_stage is the last factor in the model so that the default result that is returned when using the results() function will be for our main effect.\n\n# create the dds object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ treatment + sex + developmental_stage)\n\nProvide the line of code used to run DESeq2.\n\n# run DESeq\ndds &lt;- DESeq(dds)\n\nWould you use a different hypothesis test if you had 3 developmental timepoints?\nIn that case we would use a likelihood ratio test, because there are more than two groups for comparison. Since the full model is ~ treatment + sex + developmental_stage, the reduced model is then ~ treatment + sex. (We don’t use ~1 here, because our reduced model does still include factors.)\n\n# create the dds object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ treatment + sex + developmental_stage)\n\n# run DESeq LRT\ndds_lrt &lt;- DESeq(dds, test = \"LRT\", reduced = ~ sex)"
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution_Answers.html",
    "href": "lessons/04_RNAseq_count_distribution_Answers.html",
    "title": "RNA-seq count data distribution - Answer key",
    "section": "",
    "text": "Exercise 1\nEvaluate the relationship between mean and variance for the control replicates (Irrel_kd samples). Note the differences or similarities in the plot compared to the one using the overexpression replicates.\n\nmean_counts_ctrl     &lt;- apply(data[,1:3], 1, mean) # select column 1 to 3, which correspond to Irrel_kd samples\nvariance_counts_ctrl &lt;- apply(data[,1:3], 1, var)\ndf_ctrl &lt;- data.frame(mean_counts_ctrl, variance_counts_ctrl)\nggplot(df_ctrl) +\n  geom_point(aes(x = mean_counts_ctrl, y = variance_counts_ctrl)) +  # plot mean vs variance\n  scale_y_log10(limits = c(1,1e9)) +\n  scale_x_log10(limits = c(1,1e9)) +\n  geom_abline(intercept = 0, slope = 1, color = \"red\") # add a line for x = y (slope = 1)\n\n\n\n\n\n\n\n\nThe plot of mean and variance for the control replicates is similar to that of overexpression replicates shown in the lesson.\n\n\nExercise 2\nAn RNA-seq experiment was conducted on mice forebrain to evaluate the effect of increasing concentrations of a treatment. For each of the five different concentrations we have n = 5 mice for a total of 25 samples. If we observed little to no variability between replicates, what might this suggest about our samples?\nThe lack of variability between replicates suggests that we are possibly dealing with technical replicates. With true biological replicates we expect some amount of variability. If you have technical replicates, you do not want to be using DESeq2 because we will be using the NB to account for overdispersion, which doesn’t exist.\nWhat type of mean-variance relationship would you expect to see for this dataset?\nmean == variance. A Poisson would be more appropriate."
  },
  {
    "objectID": "lessons/06_DGE_QC_analysis_Answers.html",
    "href": "lessons/06_DGE_QC_analysis_Answers.html",
    "title": "QC methods for DE analysis using DESeq2 - Answer key",
    "section": "",
    "text": "Exercise 1\n\n\n\n\n\n\n\n\n\nWhat does the above plot tell you about the similarity of samples?\nSamples from different experimental groups are different, while replicates within the same group are similar.\nDoes it fit the expectation from the experimental design?\nYes, it does.\nWhat do you think the %variance information (in the axes titles) tell you about the data in the context of the PCA?\nPC1 is associated with 37% of the variance in the data, and PC2 is associated with 16%.\n\n\n\n\n\n\nNote\n\n\n\nYou won’t see the %variance information when you make PCA plots without the plotPCA() function. But there are tools that let you explore this."
  },
  {
    "objectID": "lessons/02_experimental_planning_considerations.html",
    "href": "lessons/02_experimental_planning_considerations.html",
    "title": "Experimental design considerations",
    "section": "",
    "text": "Approximate time: 50 minutes",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/02_experimental_planning_considerations.html#learning-objectives",
    "href": "lessons/02_experimental_planning_considerations.html#learning-objectives",
    "title": "Experimental design considerations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the importance of replicates for RNA-seq differential expression experiments\nExplain the relationship between the number of biological replicates, sequencing depth, and the differentially expressed genes identified\nDemonstrate how to design an RNA-seq experiment that avoids confounding and batch effects",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/02_experimental_planning_considerations.html#replicates",
    "href": "lessons/02_experimental_planning_considerations.html#replicates",
    "title": "Experimental design considerations",
    "section": "Replicates",
    "text": "Replicates\nExperimental replicates can be performed as technical replicates or biological replicates.\n\nImage credit: Klaus B, 2015\n\nTechnical replicates: use the same biological sample to repeat the technical or experimental steps in order to accurately measure technical variation and remove it during analysis.\nBiological replicates use different biological samples of the same condition to measure the biological variation between samples.\n\nIn the days of microarrays, technical replicates were considered a necessity; however, with the current RNA-seq technologies, technical variation is much lower than biological variation and technical replicates are unneccessary.\nIn contrast, biological replicates are absolutely essential for differential expression analysis. For mice or rats, this might be easy to determine what constitutes a different biological sample, but it’s a bit more difficult to determine for cell lines. This article gives some great recommendations for cell line replicates.\nFor differential expression analysis, the more biological replicates, the better the estimates of biological variation and the more precise our estimates of the mean expression levels. This leads to more accurate modeling of our data and identification of more differentially expressed genes.\n\nImage credit: Liu Y et al., 2014\nAs the figure above illustrates, biological replicates are of greater importance than sequencing depth, which is the total number of reads sequenced per sample. The figure shows the relationship between sequencing depth and number of replicates on the number of differentially expressed genes identified [1]. Note that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.\n\n\n\n\n\n\nSample pooling\n\n\n\nTry to avoid pooling of individuals/experiments, if possible; however, if absolutely necessary, then each pooled set of samples would count as a single replicate. To ensure similar amounts of variation between replicates, you would want to pool the same number of individuals for each pooled set of samples.\nFor example, if you need at least 3 individuals to get enough material for your control replicate and at least 5 individuals to get enough material for your treatment replicate, you would pool 5 individuals for the control and 5 individuals for the treatment condition. You would also make sure that the individuals that are pooled in both conditions are similar in sex, age, etc.\n\n\nReplicates are almost always preferred to greater sequencing depth for bulk RNA-seq. However, guidelines depend on the experiment performed and the desired analysis. Below we list some general guidelines for replicates and sequencing depth to help with experimental planning:\n\nGeneral gene-level differential expression:\n\nENCODE guidelines suggest 30 million SE reads per sample (stranded).\n15 million reads per sample is often sufficient, if there are a good number of replicates (&gt;3).\nSpend money on more biological replicates, if possible.\nGenerally recommended to have read length &gt;= 50 bp.\n\nGene-level differential expression with detection of lowly-expressed genes:\n\nSimilarly benefits from replicates more than sequencing depth.\nSequence deeper with at least 30-60 million reads depending on level of expression (start with 30 million with a good number of replicates).\nGenerally recommended to have read length &gt;= 50 bp.\n\nIsoform-level differential expression:\n\nFor known isoforms, suggested to have a depth of at least 30 million reads per sample and paired-end reads.\nFor novel isoforms, should have more depth (&gt; 60 million reads per sample).\nChoose biological replicates over paired/deeper sequencing.\nGenerally recommended to have read length &gt;= 50 bp, but longer is better as the reads will be more likely to cross exon junctions.\nPerform careful QC of RNA quality. Be careful to use high quality preparation methods and restrict analysis to high quality RIN # samples.\n\nOther types of RNA analyses (intron retention, small RNA-Seq, etc.):\n\nDifferent recommendations depending on the analysis.\nAlmost always more biological replicates are better!\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe factor used to estimate the depth of sequencing for genomes is “coverage” - how many times do the number of nucleotides sequenced “cover” the genome. This metric is not exact for genomes (whole genome sequencing), but it is good enough and is used extensively. However, the metric does not work for transcriptomes because even though you may know what % of the genome has transcriptional activity, the expression of the genes is highly variable.",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/02_experimental_planning_considerations.html#confounding",
    "href": "lessons/02_experimental_planning_considerations.html#confounding",
    "title": "Experimental design considerations",
    "section": "Confounding",
    "text": "Confounding\nA confounded RNA-seq experiment is one where you cannot distinguish the separate effects of two different sources of variation in the data.\nFor example, we know that sex has large effects on gene expression, and if all of our control mice were female and all of the treatment mice were male, then our treatment effect would be confounded by sex. We could not differentiate the effect of treatment from the effect of sex.\n\nTo AVOID confounding:\n\nEnsure animals in each condition are all the same sex, age, litter, and batch, if possible.\nIf not possible, then ensure to split the animals equally between conditions",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/02_experimental_planning_considerations.html#batch-effects",
    "href": "lessons/02_experimental_planning_considerations.html#batch-effects",
    "title": "Experimental design considerations",
    "section": "Batch effects",
    "text": "Batch effects\nBatch effects are a significant issue for RNA-seq analyses, since you can see significant differences in expression due solely to the batch effect.\n\nImage credit: Hicks SC et al., 2015\nThe issues generated by poor batch study design are highlighted nicely in Gilad Y & Mizrahi-Man O, 2015.\n\nHow to know whether you have batches?\n\nWere all RNA isolations performed on the same day?\nWere all library preparations performed on the same day?\nDid the same person perform the RNA isolation/library preparation for all samples?\nDid you use the same reagents for all samples?\nDid you perform the RNA isolation/library preparation in the same location?\n\nIf any of the answers is ‘No’, then you have batches.\n\n\nBest practices regarding batches:\n\nDesign the experiment in a way to avoid batches, if possible.\nIf unable to avoid batches:\n\nDo NOT confound your experiment by batch:\n\nImage credit: Hicks SC et al., 2015\nDO split replicates of the different sample groups across batches. The more replicates, the better (definitely more than 2).\n\nImage credit: Hicks SC et al., 2015\nDO include batch information in your experimental metadata. During the analysis, we can regress out the variation due to batch if not confounded so it doesn’t affect our results – if we have that information.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe sample preparation of cell line “biological” replicates “should be performed as independently as possible” (as batches), “meaning that cell culture media should be prepared freshly for each experiment, different frozen cell stocks and growth factor batches, etc. should be used [2].” However, preparation across all conditions should be performed at the same time.\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nYour experiment has three different treatment groups, A, B, and C. Due to the lengthy process of tissue extraction, you can only isolate the RNA from two samples at the same time. You plan to have 4 replicates per group. Your metadata table is as follows:\n\n\n\nsample\ntreatment\nsex\nreplicate\nRNA isolation\n\n\n\n\nsample1\nA\nF\n1\n\n\n\nsample2\nA\nF\n2\n\n\n\nsample3\nA\nM\n3\n\n\n\nsample4\nA\nM\n4\n\n\n\nsample5\nB\nF\n1\n\n\n\nsample6\nB\nF\n2\n\n\n\nsample7\nB\nM\n3\n\n\n\nsample8\nB\nM\n4\n\n\n\nsample9\nC\nF\n1\n\n\n\nsample10\nC\nF\n2\n\n\n\nsample11\nC\nM\n3\n\n\n\nsample12\nC\nM\n4\n\n\n\n\nClick here to download the above table as an Excel file.\n\nFill in the RNA isolation column of the metadata table. Since we can only prepare 2 samples at a time and we have 12 samples total, you will need to isolate RNA in 6 batches. In the RNA isolation column, enter one of the following values for each sample: group1, group2, group3, group4, group5, group6. Make sure to fill in the table so as to avoid confounding by batch of RNA isolation.\nBONUS: To perform the RNA isolations more quickly, you devote two researchers to perform the RNA isolations. Create a researcher column and fill in the researchers’ initials for the samples they will prepare: use initials AB or CD.\n\nAnswer Key",
    "crumbs": [
      "Pre-reading:",
      "Experimental design considerations"
    ]
  },
  {
    "objectID": "lessons/09_DGE_DESeq2_analysis_Answers.html",
    "href": "lessons/09_DGE_DESeq2_analysis_Answers.html",
    "title": "Gene-level differential expression analysis with DESeq2 - Answer key",
    "section": "",
    "text": "Exercise 1\nGiven the dispersion plot below, would you have any concerns regarding the fit of your data to the model? If not, what aspects of the plot makes you feel confident about your data? If so, what are your concerns? What would you do to address them?\n\n\n\nYes, there are some concerns. The data does not scatter around the fitted curve, and the distribution of normalized counts are restricted in a small range. I would double check QC of my samples to make sure that there are no contamination or outliers."
  },
  {
    "objectID": "lessons/06_DGE_QC_analysis.html",
    "href": "lessons/06_DGE_QC_analysis.html",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "",
    "text": "Approximate time: 80 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/06_DGE_QC_analysis.html#learning-objectives",
    "href": "lessons/06_DGE_QC_analysis.html#learning-objectives",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nRecognize the importance of methods for count data transformation\nDescribe the PCA (principal component analysis) technique\nInterpret different examples of PCA plots\nEvaluate sample quality using PCA and hierachical clustering",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/06_DGE_QC_analysis.html#sample-level-qc",
    "href": "lessons/06_DGE_QC_analysis.html#sample-level-qc",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Sample-level QC",
    "text": "Sample-level QC\nA useful initial step in an RNA-seq analysis is often to assess overall similarity between samples:\n\nWhich samples are similar to each other, which are different?\nDoes this fit to the expectation from the experiment’s design?\nWhat are the major sources of variation in the dataset?\n\nTo explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. These methods/tools allow us to check how well similar the replicates are to each other (clustering) and to make sure that the experimental condition is the major source of variation in the data. Sample-level QC can also help identify any samples behaving like outliers; we can further explore any potential outliers to determine whether they need to be removed prior to DE analysis.\n\n\n\nThese unsupervised clustering methods are run using log2 transformed normalized counts. The log2 transformation improves the distances/clustering for visualization. Instead of using an ordinary log2 transform, we will be using regularized log transform (rlog), to avoid any bias from the abundance of low-count genes; Note 1 below explains this in more detail.\n\n\n\nImage adapted from “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014\n\n\n\n\n\n\nNote 1\n\n\n\n“Many common statistical methods for exploratory analysis of multidimensional data, especially methods for clustering and ordination (e.g., principal-component analysis and the like), work best for (at least approximately) homoskedastic data; this means that the variance of an observable quantity (i.e., here, the expression strength of a gene) does not depend on the mean. In RNA-seq data, however, variance grows with the mean. For example, if one performs PCA directly on a matrix of normalized read counts, the result typically depends only on the few most strongly expressed genes because they show the largest absolute differences between samples. A simple and often used strategy to avoid this is to take the logarithm of the normalized count values plus a small pseudocount; however, now the genes with low counts tend to dominate the results because, due to the strong Poisson noise inherent to small count values, they show the strongest relative differences between samples.\nAs a solution, DESeq2 offers the regularized-logarithm transformation, or rlog for short. For genes with high counts, the rlog transformation differs not much from an ordinary log2 transformation. For genes with lower counts, however, the values are shrunken towards the genes’ averages across all samples. Using an empirical Bayesian prior in the form of a ridge penality, this is done such that the rlog-transformed data are approximately homoskedastic.” - From the “Beginner’s guide to using the DESeq2 package” by Love, Anders, and Huber, 2014 (the DESeq2 vignette is the updated version of this doc).\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe DESeq2 vignette suggests large datasets (100s of samples) to use the variance-stabilizing transformation (vst) instead of rlog for transformation of the counts, since the rlog function might take too long to run and the vst() function is faster with similar properties to rlog.\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). This is a very important technique used in the QC and analysis of both bulk and single-cell RNAseq data.\nTo better understand how it works, please go through this YouTube video from StatQuest that explains PCA. Alternatively, we have prepared a PCA lesson. After you have gone through the material, please proceed with the interpretation section below.\n\n\nInterpreting PCA plots\nEssentially, if two samples have similar levels of expression for the genes that contribute significantly to the variation represented by a given PC (Principal Component), they will be plotted close together on the axis that represents that PC. Therefore, we would expect that biological replicates to have similar scores (because our expectation is that the same genes are changing) and cluster together. This is easiest to understand by visualizing some example PCA plots.\nWe have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment.\n\n\n\nWhen visualizing on PC1 and PC2, we don’t see the samples separate by treatment, so we decide to explore other sources of variation present in the data. We hope that we have included all possible known sources of variation in our metadata table, and we can use these factors to color the PCA plot.\n\n\n\nWe start with the factor cage, but the cage factor does not seem to explain the variation on PC1 or PC2.\n\n\n\nThen, we color by the sex factor, which appears to separate samples on PC2. This is good information to take note of, as we can use it downstream to account for the variation due to sex in the model and regress it out.\n\n\n\nNext we explore the strain factor and find that it explains the variation on PC1.\n\n\n\nIt’s great that we have been able to identify the sources of variation for both PC1 and PC2. By accounting for it in our model, we should be able to detect more genes differentially expressed due to treatment.\nWorrisome about this plot is that we see two samples that do not cluster with the correct strain. This would indicate a likely sample swap and should be investigated to determine whether these samples are indeed the labeled strains. If we found there was a switch, we could swap the samples in the metadata. However, if we think they are labeled correctly or are unsure, we could just remove the samples from the dataset.\nStill we haven’t found if treatment is a major source of variation after strain and sex. So, we explore PC3 and PC4 to see if treatment is driving the variation represented by either of these PCs.\n\n\n\nWe find that the samples separate by treatment on PC3, and are optimistic about our DE analysis since our condition of interest, treatment, is separating on PC3 and we can regress out the variation driving PC1 and PC2.\nDepending on how much variation is explained by the first few principal components, you may want to explore more (i.e., consider more components and plot pairwise combinations). Even if your samples do not separate clearly by the experimental variable, you may still get biologically relevant results from the DE analysis. If you are expecting very small effect sizes, then it’s possible the signal is drowned out by extraneous sources of variation. In situations where you can identify those sources, it is important to account for these in your model, as it provides more power to the tool for detecting DE genes.\n\n\n\nHierarchical Clustering Heatmap\nSimilar to PCA, hierarchical clustering is another, complementary, method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.\nThe hierarchical tree along the axes indicates which samples are more similar to each other, i.e., cluster together. The color blocks at the top indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Our expectation would be that the samples cluster together similar to the groupings we’ve observed in the PCA plot.\nIn the plot below, we would be quite concerned about ‘Wt_3’ and ‘KD_3’ samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples.",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/06_DGE_QC_analysis.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "href": "lessons/06_DGE_QC_analysis.html#mov10-quality-assessment-and-exploratory-analysis-using-deseq2",
    "title": "QC methods for DE analysis using DESeq2",
    "section": "Mov10 quality assessment and exploratory analysis using DESeq2",
    "text": "Mov10 quality assessment and exploratory analysis using DESeq2\nNow that we have a good understanding of the QC steps normally employed for RNA-seq, let’s implement them for the Mov10 dataset we are going to be working with.\n\nTransform normalized counts for the MOV10 dataset\nTo improve the distances/clustering for the PCA and hierarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these transformed counts for determining differential expression.\n\n\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind = TRUE)\n\nThe blind=TRUE argument is to make sure that the rlog() function does not take our sample groups into account - i.e., does the transformation in an unbiased manner. When performing quality assessment, it is important to include this option. The DESeq2 vignette has more details about this.\nThe rlog() function returns a DESeqTransform object, another type of DESeq-specific object. The reason you don’t just get a matrix of transformed values is because all of the parameters (e.g., size factors) that went into computing the rlog transform are stored in that object. We use this object to plot the PCA and hierarchical clustering figures for quality assessment.\n\n\n\n\n\n\nNote\n\n\n\nThe rlog() funtion can be a bit slow when you have &gt; ~20 samples. In these situations the vst() function is much faster and performs a similar transformation appropriate for use with plotPCA(). It’s typically just a few seconds with vst() due to optimizations and the nature of the transformation.\n\n\n\n\nPrincipal component analysis (PCA) for the MOV10 dataset\nWe are now ready for the QC steps, let’s start with PCA!\nDESeq2 has a built-in function for generating PCA plots using ggplot2 under the hood. This is great because it saves us having to type out lines of code and having to fiddle with the different ggplot2 layers. In addition, it takes the rlog object as an input directly, hence saving us the trouble of extracting the relevant information from it.\nThe function plotPCA() requires two arguments as input: a DESeqTransform object and the “intgroup” (interesting group), i.e., the name of the column in our metadata that has information about the experimental sample groups.\n\n# Plot PCA \nplotPCA(rld, intgroup=\"sampletype\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\n\nWhat does the above plot tell you about the similarity of samples?\nDoes it fit the expectation from the experimental design?\nWhat do you think the %variance information (in the axes titles) tell you about the data in the context of the PCA?\n\n\n\nBy default plotPCA() uses the top 500 most variable genes. You can change this by adding the ntop= argument and specifying how many of the genes you want the function to consider.\n\n\n\n\n\n\nNote\n\n\n\nThe plotPCA() function will only return the values for PC1 and PC2. If you would like to explore the additional PCs in your data or if you would like to identify genes that contribute most to the PCs, you can use the prcomp() function. For example, to plot any of the PCs we could run the following code:\n\n# Input is a matrix of log transformed values\nrld &lt;- rlog(dds, blind = TRUE)\nrld_mat &lt;- assay(rld)\npca &lt;- prcomp(t(rld_mat))\n\n# Create data frame with metadata and PC3 and PC4 values for input to ggplot\ndf &lt;- cbind(meta, pca$x)\nggplot(df) + geom_point(aes(x = PC3, y = PC4, color = sampletype))\n\n\n\n\n\n\n\n\nResources are available to learn how to do more complex inquiries using the PCs.\n\n\n\n\nHierarchical Clustering for the MOV10 dataset\nThere is no built-in function in DESeq2 for plotting the heatmap for displaying the pairwise correlation between all the samples and the hierarchical clustering information; we will use the pheatmap() function from the pheatmap package. This function cannot use the DESeqTransform object as input, but requires a matrix or dataframe. So, the first thing to do is retrieve that information from the rld object using a function called assay() (from the SummarizedExperiment package) that converts the data in a DESeqTransform object to a simple 2-dimensional data structure (a matrix in this case).\n\n# Extract the rlog matrix from the object\n# \"assay()\" is part of the \"SummarizedExperiment\" package, which is a DESeq2 dependency and is loaded with the DESeq2 library\nrld_mat &lt;- assay(rld)\n\nNext, we need to compute the pairwise correlation values for all the samples. We can do this using the cor() function:\n\n# Compute pairwise correlation values\n# cor() is a base R function\nrld_cor &lt;- cor(rld_mat)\n\nLet’s take a look at the column and row names of the correlation matrix.\n\n# Check the output of cor(), make note of the row names and column names\nhead(rld_cor)\n\n           Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1\nIrrel_kd_1  1.0000000  0.9997740  0.9997525  0.9996005  0.9996334  0.9995372\nIrrel_kd_2  0.9997740  1.0000000  0.9997564  0.9995701  0.9996137  0.9995441\nIrrel_kd_3  0.9997525  0.9997564  1.0000000  0.9995460  0.9996014  0.9995541\nMov10_kd_2  0.9996005  0.9995701  0.9995460  1.0000000  0.9997927  0.9993895\nMov10_kd_3  0.9996334  0.9996137  0.9996014  0.9997927  1.0000000  0.9994757\nMov10_oe_1  0.9995372  0.9995441  0.9995541  0.9993895  0.9994757  1.0000000\n           Mov10_oe_2 Mov10_oe_3\nIrrel_kd_1  0.9995326  0.9994112\nIrrel_kd_2  0.9995407  0.9994279\nIrrel_kd_3  0.9995620  0.9994254\nMov10_kd_2  0.9993608  0.9992364\nMov10_kd_3  0.9994457  0.9993479\nMov10_oe_1  0.9997794  0.9996902\n\nhead(meta)\n\n                     sampletype\nIrrel_kd_1              control\nIrrel_kd_2              control\nIrrel_kd_3              control\nMov10_kd_2      MOV10_knockdown\nMov10_kd_3      MOV10_knockdown\nMov10_oe_1 MOV10_overexpression\n\n\nYou will notice that they match the names we have given our samples in the metadata data frame we started with. It is important that these match, so we can use the annotation argument below to plot a color block across the top. This block enables easy visualization of the hierarchical clustering.\nLet’s plot the heatmap!\nWhen you plot using pheatmap(), the hierarchical clustering information is used to place similar samples together and this information is represented by the tree structure along the axes. The annotation argument accepts a dataframe as input; in our case it is the meta dataframe.\n\n# Load pheatmap package\nlibrary(pheatmap)\n\n# Plot heatmap using the correlation matrix and the metadata object\npheatmap(rld_cor, annotation = meta)\n\n\n\n\n\n\n\n\nOverall, we observe pretty high correlations across the board (&gt; 0.999) suggesting no outlying sample(s). Also, similar to the PCA plot, you see the samples clustering together by sample group. Together, these plots suggest to us that the data are of good quality and we have the green light to proceed to differential expression analysis.\n\n\n\n\n\n\nNote\n\n\n\nThe pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot.\n\nheat.colors &lt;- RColorBrewer::brewer.pal(6, \"Blues\")\npheatmap(rld_cor, annotation = meta, color = heat.colors,\n         border_color = NA, fontsize = 10, fontsize_row = 10, height = 20)\n\n\n\n\n\n\n\n\nCurious about all of the available color palettes offered by the RColorBrewer package? Try typing in your console display.brewer.all() and see what happens!\n\n\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "QC methods for DE analysis using DESeq2"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results_Answers.html",
    "href": "lessons/10_wald_test_results_Answers.html",
    "title": "Exploring DESeq2 results from the Wald test - Answer key",
    "section": "",
    "text": "Exercise 1\nMOV10 Differential Expression Analysis: Control versus Knockdown\nNow that we have results for the overexpression results, do the same for the Control vs. Knockdown samples.\nCreate a contrast vector called contrast_kd.\n\n# Define contrasts for MOV10 knockdown\ncontrast_kd &lt;- c(\"sampletype\", \"MOV10_knockdown\", \"control\")\n\nUse contrast vector in the results() to extract a results table and store that to a variable called res_tableKD.\n\n# Extract results for MOV10 knockdown vs control\nres_tableKD &lt;- results(dds, contrast=contrast_kd, alpha = 0.05)\n\nShrink the LFC estimates using lfcShrink() and assign it back to res_tableKD.\n\n# Apply fold change shrinkage\nres_tableKD &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_knockdown_vs_control\", type=\"apeglm\")"
  },
  {
    "objectID": "lessons/18_DGE_summarizing_workflow.html",
    "href": "lessons/18_DGE_summarizing_workflow.html",
    "title": "Summary of DGE workflow",
    "section": "",
    "text": "Approximate time: 15 minutes",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/18_DGE_summarizing_workflow.html#learning-objectives",
    "href": "lessons/18_DGE_summarizing_workflow.html#learning-objectives",
    "title": "Summary of DGE workflow",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIdentify the R commands needed to run a complete differential expression analysis using DESeq2",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/18_DGE_summarizing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "href": "lessons/18_DGE_summarizing_workflow.html#summary-of-differential-expression-analysis-workflow",
    "title": "Summary of DGE workflow",
    "section": "Summary of differential expression analysis workflow",
    "text": "Summary of differential expression analysis workflow\nWe have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below:\n\nObtaining gene-level counts from Salmon using tximport\n\n\n# Run tximport\ntxi &lt;- tximport(files, \n                type = \"salmon\", \n                tx2gene = t2g, \n                countsFromAbundance = \"lengthScaledTPM\")\n\n# \"files\" is a vector wherein each element is the path to the salmon quant.sf file, and each element is named with the name of the sample.\n# \"t2g\" is a 2 column data frame which contains transcript IDs mapped to geneIDs (in that order)\n\n\nCreating the dds object:\n\n\n# Check that the row names of the metadata equal the column names of the **raw counts** data\nall(colnames(txi$counts) == rownames(metadata))\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, \n                                colData = metadata, \n                                design = ~ condition)\n\n\nExploratory data analysis (PCA & hierarchical clustering) - identifying outliers and sources of variation in the data:\n\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, \n            blind = TRUE)\n\n# Plot PCA \nplotPCA(rld, \n        intgroup = \"condition\")\n\n# Extract the rlog matrix from the object and compute pairwise correlation values\nrld_mat &lt;- assay(rld)\nrld_cor &lt;- cor(rld_mat)\n\n# Plot heatmap\npheatmap(rld_cor, \n         annotation = metadata)\n\n\nRun DESeq2:\n\n\n# **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = metadata, design = ~ covariate + condition)\n\n# Run DESeq2 differential expression analysis\ndds &lt;- DESeq(dds)\n\n# **Optional step** - Output normalized counts to save as a file to access outside RStudio\n# normalized_counts &lt;- counts(dds, normalized = TRUE)\n\n\nCheck the fit of the dispersion estimates:\n\n\n# Plot dispersion estimates\nplotDispEsts(dds)\n\n\nCreate contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions:\n\n\n# Specify contrast for comparison of interest\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Output results of Wald test for contrast\nres &lt;- results(dds, \n               contrast = contrast, \n               alpha = 0.05)\n\n# Shrink the log2 fold changes to be more accurate\nres &lt;- lfcShrink(dds, \n                 coef = \"sampletype_group1_vs_group2\", \n                 type = \"apeglm\")    \n# The coef will be dependent on what your contrast was. and should be identical to what is stored in resultsNames()\n\n\nOutput significant results:\n\n\n# Set thresholds\npadj.cutoff &lt; - 0.05\n\n# Turn the results object into a tibble for use with tidyverse functions\nres_tbl &lt;- res %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset the significant results\nsig_res &lt;- dplyr::filter(res_tbl, \n                         padj &lt; padj.cutoff)\n\n\nVisualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc.\nPerform analysis to extract functional significance of results: GO or KEGG enrichment, GSEA, etc.\nMake sure to output the versions of all tools used in the DE analysis:\n\n\nsessionInfo()\n\nFor better reproducibility, it can help to create RMarkdown reports, which save all code, results, and visualizations as nicely formatted html reports. We have a very basic example of a report linked here. To create these reports we have additional materials available.",
    "crumbs": [
      "Day 4:",
      "Summary of DGE workflow"
    ]
  },
  {
    "objectID": "lessons/12_DGE_visualizing_results.html",
    "href": "lessons/12_DGE_visualizing_results.html",
    "title": "Advanced DGE visualizations",
    "section": "",
    "text": "Approximate time: 75 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced DGE visualizations"
    ]
  },
  {
    "objectID": "lessons/12_DGE_visualizing_results.html#learning-objectives",
    "href": "lessons/12_DGE_visualizing_results.html#learning-objectives",
    "title": "Advanced DGE visualizations",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nSetup results data for application of visualization techniques\nDescribe different data visualization useful for exploring results from a DGE analysis\nCreate a volcano plot to evaluate relationship amongst DGE statistics\nCreate a heatmap to illustrate expression changes of differentially expressed genes",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced DGE visualizations"
    ]
  },
  {
    "objectID": "lessons/12_DGE_visualizing_results.html#visualizing-the-results",
    "href": "lessons/12_DGE_visualizing_results.html#visualizing-the-results",
    "title": "Advanced DGE visualizations",
    "section": "Visualizing the results",
    "text": "Visualizing the results\nWhen we are working with large amounts of data, it can be useful to display that information graphically to gain more insight. During this lesson, we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data. Many of these plots can be helpful in visualizing other types of data as well.\nWe will be working with three different data objects we have already created in earlier lessons:\n\nMetadata for our samples (a dataframe): meta\nNormalized expression data for every gene in each of our samples (a matrix): normalized_counts\nTibble versions of the DESeq2 results we generated in the last lesson: res_tableOE_tb and res_tableKD_tb\n\nFirst, let’s create a metadata tibble from the data frame (don’t lose the row names!)\n\n# Make metadata tibble\nmov10_meta &lt;- meta %&gt;% \n  rownames_to_column(var = \"samplename\") %&gt;% \n  as_tibble()\n\nNext, let’s bring in a column with gene symbols to the normalized_counts object, so we can use them to label our plots. Ensembl IDs are great for many things, but the gene symbols are much more recognizable to us, as biologists.\n\n# DESeq2 creates a matrix when you use the counts() function\n# First convert normalized_counts to a data frame and transfer the row names to a new column called \"gene\"\nnormalized_counts &lt;- counts(dds, normalized = TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var = \"gene\") \n  \n# Next, merge together (ensembl IDs) the normalized counts data frame\n# with a subset of the annotations in the tx2gene data frame (only the columns for ensembl gene IDs and gene symbols)\ngrch38annot &lt;- tx2gene %&gt;% \n  dplyr::select(ensgene, symbol) %&gt;% \n  dplyr::distinct()\n\n# This will bring in a column of gene symbols\nnormalized_counts &lt;- merge(normalized_counts, grch38annot, by.x = \"gene\", by.y = \"ensgene\")\n\n# Now create a tibble for the normalized counts\nnormalized_counts &lt;- normalized_counts %&gt;%\n  as_tibble()\n\n# View at the tibble to make sure it looks correct\nnormalized_counts %&gt;% head()\n\n# A tibble: 6 × 10\n  gene         Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1\n  &lt;chr&gt;             &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 ENSG0000000…   3925.       3794.       3961.     3952.       3941.      2727. \n2 ENSG0000000…     24.2        30.2        30.7      23.7        13.9       20.4\n3 ENSG0000000…   1326.       1341.       1180.     1515.       1432.      1542. \n4 ENSG0000000…    456.        422.        476.      597.        610.       527. \n5 ENSG0000000…   1250.       1212.       1134.     1389.       1300.       965. \n6 ENSG0000000…      0.897       1.04        0         1.28        0          0  \n# ℹ 3 more variables: Mov10_oe_2 &lt;dbl&gt;, Mov10_oe_3 &lt;dbl&gt;, symbol &lt;chr&gt;\n\n\n\n\n\n\n\n\nA possible alternative to the above:\n\n\n\n\nnormalized_counts &lt;- counts(dds, normalized = TRUE) %&gt;% \n  data.frame() %&gt;%\n  rownames_to_column(var = \"gene\") %&gt;%\n  as_tibble() %&gt;%\n  left_join(grch38annot, by = c(\"gene\" = \"ensgene\"))\n\n\n\n\nPlotting signicant DE genes\nOne way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes.\n\nUsing DESeq2 plotCounts() to plot expression of a single gene\nTo pick out a specific gene of interest to plot, for example MOV10, we can use the plotCounts() from DESeq2. plotCounts() requires that the gene specified matches the original input to DESeq2, which in our case was Ensembl IDs.\n\n# Find the Ensembl ID of MOV10\ngrch38annot[grch38annot$symbol == \"MOV10\", \"ensgene\"]\n\n[1] \"ENSG00000155363\"\n\n# Plot expression for single gene\nplotCounts(dds, gene = \"ENSG00000155363\", intgroup = \"sampletype\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis DESeq2 function only allows for plotting the counts of a single gene at a time, and is not flexible regarding the appearance.\n\n\n\n\nUsing ggplot2 to plot expression of a single gene\nIf you wish to change the appearance of this plot, we can save the output of plotCounts() to a variable specifying the returnData=TRUE argument, then use ggplot():\n\n# Save plotcounts to a data frame object\nd &lt;- plotCounts(dds, gene = \"ENSG00000155363\", intgroup = \"sampletype\", returnData = TRUE)\n\n# What is the data output of plotCounts()?\nd %&gt;% head()\n\n                count           sampletype\nIrrel_kd_1   1911.647              control\nIrrel_kd_2   1974.191              control\nIrrel_kd_3   2072.948              control\nMov10_kd_2   1419.191      MOV10_knockdown\nMov10_kd_3   1486.757      MOV10_knockdown\nMov10_oe_1 274747.523 MOV10_overexpression\n\n# Plot the MOV10 normalized counts, using the samplenames (rownames(d)) as labels\nggplot(d, aes(x = sampletype, y = count, color = sampletype)) + \n  # Scatterplot but allow points to \"jitter\" so they are not on top of each other\n  geom_point(position=position_jitter(w = 0.1, h = 0)) +\n  # Label points\n  geom_text_repel(aes(label = rownames(d))) +\n  # Add title and plot tweaks\n  ggtitle(\"MOV10\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLabel points\n\n\n\nNote that in the plot above, we are using geom_text_repel() from the ggrepel package to label our individual points on the plot.\n\n\n\n\n\n\n\n\nPlot more than one gene\n\n\n\nIf you are interested in plotting the expression of multiple genes all together, please refer to the short lesson linked here where we demo this for the top 20 most significantly expressed genes.\n\n\n\n\n\nHeatmap\nIn addition to plotting subsets, we could also extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap().\n\n# Extract normalized expression for significant genes from the OE and control samples (2:4 and 7:9)\nnorm_OEsig &lt;- normalized_counts[, c(1:4,7:9)] %&gt;% \n  dplyr::filter(gene %in% sigOE$gene)  \n\nNow let’s draw the heatmap using pheatmap:\n\n# Set a color palette\nheat_colors &lt;- RColorBrewer::brewer.pal(6, \"YlOrRd\")\n\n# Run pheatmap using the metadata dataframe for the annotation\npheatmap(norm_OEsig[2:7], \n         color = heat_colors, \n         cluster_rows = TRUE, \n         show_rownames = FALSE,\n         annotation = meta, \n         border_color = NA, \n         fontsize = 10, \n         scale = \"row\", \n         fontsize_row = 10, \n         height = 20)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThere are several additional arguments we have included in the function for aesthetics. One important one is scale=\"row\", in which Z-scores are plotted, rather than the actual normalized count value.\nZ-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed after the clustering, so that it only affects the graphical aesthetics, and the color visualization is improved.\n\n\n\n\nVolcano plot\nThe above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log-transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.\nTo generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values and, for the purposes of this visualization, a log2fold change cutoff.\n\n# Obtain logical vector where TRUE values denote padj values &lt; 0.05 and fold change &gt; 1.5 in either direction\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% \n  dplyr::mutate(threshold_OE = padj &lt; 0.05 & abs(log2FoldChange) &gt;= log2(1.5))\n\nNow we can start plotting. The geom_point object is most applicable, as this is essentially a scatter plot:\n\n# Volcano plot\nggplot(res_tableOE_tb) +\n  geom_point(aes(x = log2FoldChange, y = -log10(padj),\n                 # Color by whether or not gene is DE by padj and log2FC\n                 colour = threshold_OE)) +\n  # You could choose to limit the y-axis to look at the shape of the data without outliers\n  # scale_y_continuous(limits = c(0,50)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))  \n\n\n\n\n\n\n\n\nThis is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the volcano plot using geom_text_repel().\nFirst, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot.\n\n# Add all the gene symbols as a column from the grch38 table using bind_cols()\nres_tableOE_tb &lt;- bind_cols(res_tableOE_tb,\n                            symbol = grch38annot$symbol[match(res_tableOE_tb$gene, grch38annot$ensgene)])\n\n# Create an empty column to indicate which genes to label\nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::mutate(genelabels = \"\")\n\n# Sort by padj values \nres_tableOE_tb &lt;- res_tableOE_tb %&gt;% dplyr::arrange(padj)\n\n# Populate the genelabels column with contents of the gene symbols column for the first 10 rows, i.e., the top 10 most significantly expressed genes\nres_tableOE_tb$genelabels[1:10] &lt;- as.character(res_tableOE_tb$symbol[1:10])\n\n# Look at the new table\nhead(res_tableOE_tb)\n\n# A tibble: 6 × 9\n  gene    baseMean log2FoldChange  lfcSE    pvalue      padj threshold_OE symbol\n  &lt;chr&gt;      &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;lgl&gt;        &lt;chr&gt; \n1 ENSG00…   95772.           6.99 0.122  0         0         TRUE         MOV10 \n2 ENSG00…    8090.           1.51 0.0666 3.72e-115 3.41e-111 TRUE         H1F0  \n3 ENSG00…     239.           6.50 0.363  9.45e- 72 5.76e- 68 TRUE         HSPA6 \n4 ENSG00…    5285.           1.37 0.0788 1.64e- 68 7.48e- 65 TRUE         TXNIP \n5 ENSG00…    1747.           1.48 0.0890 1.75e- 63 6.41e- 60 TRUE         HIST1…\n6 ENSG00…    2595.           1.47 0.0956 1.49e- 54 4.54e- 51 TRUE         HIST2…\n# ℹ 1 more variable: genelabels &lt;chr&gt;\n\n\nNext, we plot it as before with an additional layer for geom_text_repel() wherein we can specify the column of gene labels we just created.\n\n# Volcano plot with labels on some points\nggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) +\n  # Color by whether or not gene is DE by padj and log2FC\n  geom_point(aes(colour = threshold_OE)) +\n  # Only label the top 10 DEG we identified above\n  geom_text_repel(aes(label = genelabels)) +\n  # Add title and plot tweaks\n  ggtitle(\"Mov10 overexpression\") +\n  xlab(\"log2 fold change\") + \n  ylab(\"-log10 adjusted p-value\") +\n  theme(legend.position = \"none\",\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25))) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn R package for visualization of DGE results\n\n\n\nThe Bioconductor package DEGreport can use the DESeq2 results output to make the top 20 genes and the volcano plots generated above by writing much fewer lines of code. The caveat of these functions is you lose the ability to customize plots as we have demonstrated above.\nIf you are interested, the example code below shows how you can use DEGreport to create similar plots. Note that this is example code, do not run.\n\n## DO NOT RUN THIS CODE\n\n# Plot normalized expression of top n (20) genes\nDEGreport::degPlot(dds = dds, # dds object is output from DESeq2\n                   res = res, n = 20, xs = \"type\", group = \"condition\")\n\n# Plot labeled volcano plot\nDEGreport::degVolcano(\n  data.frame(res[, c(\"log2FoldChange\",\"padj\")]), # table - 2 columns\n  plot_text = data.frame(res[1:10, c(\"log2FoldChange\",\"padj\",\"id\")])) # table to add names\n\n# Available in the newer version for R 3.4\nDEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group = \"condition\")\n\n\n\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Advanced DGE visualizations"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html",
    "href": "lessons/04_RNAseq_count_distribution.html",
    "title": "RNA-seq count data distribution",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#learning-objectives",
    "href": "lessons/04_RNAseq_count_distribution.html#learning-objectives",
    "title": "RNA-seq count data distribution",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the characteristics of RNA-seq count data\nCompare different mathematical models for count data\nIdentify the most appropriate model for RNA-seq count data\nExplain the benefits of biological replicates for identifying true differences between sample groups",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#count-matrix",
    "href": "lessons/04_RNAseq_count_distribution.html#count-matrix",
    "title": "RNA-seq count data distribution",
    "section": "Count matrix",
    "text": "Count matrix\nWhen we start our differential gene expression analysis we begin with a matrix summarizing the gene-level expression in each sample of your dataset. The rows in the matrix correspond to genes, and the columns correspond to samples. In each position of the matrix you will have an integer value representing the total number of sequence reads that originated from a particular gene in a sample.\n\n\n\nThe higher the number of counts indicates more reads are associated with that gene and suggests a higher level of expression of that gene. However, this is not necessarily true and we will delve deeper into this later in this lesson and in the course.",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#characteristics-of-rna-seq-count-data",
    "href": "lessons/04_RNAseq_count_distribution.html#characteristics-of-rna-seq-count-data",
    "title": "RNA-seq count data distribution",
    "section": "Characteristics of RNA-seq count data",
    "text": "Characteristics of RNA-seq count data\nTo get an idea about how RNA-seq counts are distributed, let’s plot a histogram of the counts for a single sample, ‘Mov10_oe_1’:\n\n# Plot the distribution of counts for Mov10_oe_1\nggplot(data) +\n  geom_histogram(aes(x = Mov10_oe_1), stat = \"bin\", bins = 200) +\n  xlab(\"Raw expression counts\") +\n  ylab(\"Number of genes\")\n\n\n\n\n\n\n\n\nThis plot illustrates some common features of RNA-seq count data:\n\na low number of counts associated with a large proportion of genes\na long right tail due to the lack of any upper limit for expression\nlarge dynamic range\n\nLooking at the shape of the histogram, we see that it is not normally distributed. For RNA-seq data this will always be the case. Moreover, the underlying data, as we observed earlier, is integer counts instead rather than continuous measurements. We need to take these characteristics into account when deciding on what statistical model to use.",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#modeling-count-data",
    "href": "lessons/04_RNAseq_count_distribution.html#modeling-count-data",
    "title": "RNA-seq count data distribution",
    "section": "Modeling count data",
    "text": "Modeling count data\nCount data in general can be modeled with various distributions:\n\nBinomial distribution: Gives you the probability of getting a number of heads upon tossing a coin a number of times. Based on discrete events and used in situations when you have a certain number of cases. Thus, it gives the probability of getting r events out of n trials.\nPoisson distribution: For use when the number of cases is very large (i.e., people who buy lottery tickets), but the probability of an event is very small (probability of winning). The Poisson is similar to the binomial as it is also based on discrete events, but used with data from an infinite sample. Thus it gives the probability of getting r events in a population. It is appropriate for data where mean == variance.\n\n\n\n\n\n\n\nNote\n\n\n\nDetails provided by Rafael Irizarry in the EdX class.\n\n\nSo what do we use for RNA-seq count data?\nWith RNA-Seq data, a very large number of RNAs are represented and the probability of pulling out a particular transcript is very small. This scenario is most similar to the lottery described above, suggesting that perhaps the Poisson distribution is most appropriate. However, this will depend on the relationship between mean and variance in our data.\n\nMean versus variance\nTo assess the properties of the data we are working with, we can use the three samples corresponding to the ‘Mov10 overexpression’ replicates. First compute a vector of mean values, then compute a vector of variance values. Finally, plot these values against each other to evaluate the relationship between them.\n\n# Calculate the mean and variance for each gene for the Mov10 overexpression replicates\n# The second argument '1' of 'apply' function indicates the function being applied to rows\n#     Use '2' if applied to columns\nmean_counts &lt;- apply(data[,6:8], 1, mean) \nvariance_counts &lt;- apply(data[,6:8], 1, var)\ndf &lt;- data.frame(mean_counts, variance_counts)\n\nYour plot should look like the scatterplot below. Each data point represents a gene and the red line represents x = y.\n\n# Plot the mean vs variance\nggplot(df) +\n  geom_point(aes(x = mean_counts, y = variance_counts)) + \n  scale_y_log10(limits = c(1,1e9)) +\n  scale_x_log10(limits = c(1,1e9)) +\n  # Add a line for x = y (slope = 1)\n  geom_abline(intercept = 0, slope = 1, color = \"red\")\n\n\n\n\n\n\n\n\n\nThe mean is not equal to the variance (the scatter of data points does not fall on the diagonal).\nFor the genes with high mean expression, the variance across replicates tends to be greater than the mean (scatter is above the red line).\nFor the genes with low mean expression we see quite a bit of scatter. We usually refer to this as “heteroscedasticity”. That is, for a given expression level in the low range we observe a lot of variability in the variance values.\n\n\n\n\n\n\n\nExercise 1\n\n\n\nEvaluate the relationship between mean and variance for the control replicates (Irrel_kd samples). Note the differences or similarities in the plot compared to the one using the overexpression replicates.",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#an-alternative-the-negative-binomial-distribution",
    "href": "lessons/04_RNAseq_count_distribution.html#an-alternative-the-negative-binomial-distribution",
    "title": "RNA-seq count data distribution",
    "section": "An alternative: The Negative Binomial distribution",
    "text": "An alternative: The Negative Binomial distribution\nOur data fail to satisfy the criteria for a the Poisson distribution, and typical RNA-seq data will do the same. If the proportions of mRNA stayed exactly constant between the biological replicates for a sample group, we could expect a Poisson distribution (where mean == variance). However, we always expect some amount of variability between replicates (we’ll discuss this in more detail later in the lesson). Alternatively, if we continued to add more replicates (i.e., &gt; 20) we should eventually see the scatter start to reduce and the high expression data points move closer to the red line. So, in theory, if we had enough replicates we could use the Poisson.\nIn practice, a large number of replicates can be either hard to obtain (depending on how samples are obtained) and/or can be unaffordable. It is more common to see datasets with only a handful of replicates (~3-5) and reasonable amount of variation between them. The distribution that fits RNA-seq data best, given this type of variability between replicates, is the Negative Binomial. Essentially, the Negative Binomial is a good approximation for data where the mean &lt; variance, as is the case with RNA-Seq count data.\n\n\n\n\n\n\nNote\n\n\n\nIf we use the Poisson, this will underestimate variability, leading to an increase in false positive DE genes.\n\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\nAn RNA-seq experiment was conducted on mice forebrain to evaluate the effect of increasing concentrations of a treatment. For each of the five different concentrations we have n = 5 mice, for a total of 25 samples. If we observed little to no variability between replicates, what might this suggest about our samples?\nWhat type of mean-variance relationship would you expect to see for this dataset?",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#replicates-and-variability",
    "href": "lessons/04_RNAseq_count_distribution.html#replicates-and-variability",
    "title": "RNA-seq count data distribution",
    "section": "Replicates and variability",
    "text": "Replicates and variability\nBiological replicates represent multiple samples (e.g., RNA from different mice) that correspond to the same sample class or group. Intuitively, we would expect samples from the same sample group (i.e., that are under similar conditions/perturbations) to exhibit a similar transcriptional profile. In most cases, there will be a high degree of similarity of samples within a group but there will also inevitably be many differences. The source of this variability on a gene’s expression can be attributed to many factors, some of which are identifiable and others that remain unknown.\n\n\n\nWith differential expression analysis, we are looking for genes that change in expression between two or more groups. For example,\n\ncase vs. control\ncorrelation of expression with some variable or clinical outcome\n\nHowever, there is much more going on with your data than what you are anticipating. Genes that vary in expression level is a consequence of not only the experimental variable(s) of interest but also due to extraneous sources. The goal of differential expression analysis is to identify and correct for sources of variation such that we can separate the “interesting” from the “uninteresting”.\nLet’s take a closer look at the figure below as an example. Expression (counts) is plotted here for ‘GeneA’ in the ‘untreated’ and ‘treated’ groups. Each dot corresponds to expression for a single sample, and the dots are colored based on which group they belong to.\n\n\n\nThe mean expression level of GeneA for the ‘treated’ group is twice as large as the mean expression level for the ‘untreated’ group. But is the difference in expression between groups significant given the amount of variation observed within groups (across replicates)?\nIt is possible that the difference is not actually significant. We need to take into account the variation in the data (and where it might be coming from) when determining whether genes are differentially expressed. Modeling our data with the negative binomial distribution allows us to do this.\n\nHow many replicates are enough?\nMore is always better! At minimum we recommend three replicates for each sample group, but if you can increase that by any number it is in your best interest. The value of additional replicates is that as you add more data, you get increasingly precise estimates of group means, and ultimately greater confidence in the ability to reliably distinguish differences between sample classes.\nHaving many replicates allow us to:\n\nestimate variation for each gene\nrandomize out unknown covariates\nspot outliers\nimprove precision of expression and fold-change estimates\n\nThe figure below is taken from a study directly evaluating the relationship between sequencing depth and number of replicates on the number of differentially expressed genes [1].\n\n\n\nNote that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression.",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/04_RNAseq_count_distribution.html#differential-expression-with-deseq2",
    "href": "lessons/04_RNAseq_count_distribution.html#differential-expression-with-deseq2",
    "title": "RNA-seq count data distribution",
    "section": "Differential expression with DESeq2",
    "text": "Differential expression with DESeq2\nDESeq2 is a popular tool for gene-level differential expression analysis. It uses the negative binomial distribution, employing a slightly more stringent approach compared to some methods yet having a good balance between sensitivity and specificity (reducing both false positives and false negatives).\n\n\n\n\n\n\nOther tools for Differential Expression Analysis\n\n\n\nThere are a number of software packages that have been developed for differential expression analysis of RNA-seq data. Most adopt the negative binomial approach; however, there are other tools based on non-parametric methods suitable for larger sample sizes. An extensive comparison of these methods can be found in Soneson and Dleorenzi, 2013.\n\n\nWe will be using DESeq2 for the analysis in this workshop. The analysis steps with DESeq2 are shown in the flowchart below in green and blue.\n\n\n\nWe will go in-depth into each of these steps in the following lessons, but additional details and helpful suggestions regarding DESeq2 can be found in the DESeq2 vignette.\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "RNA-seq count data distribution"
    ]
  },
  {
    "objectID": "lessons/16_FA_over-representation_analysis.html",
    "href": "lessons/16_FA_over-representation_analysis.html",
    "title": "Functional Analysis for RNA-seq: Over-representation analysis",
    "section": "",
    "text": "Approximate time: 120 minutes\nLearning Objectives:",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Over-representation analysis"
    ]
  },
  {
    "objectID": "lessons/16_FA_over-representation_analysis.html#over-representation-analysis",
    "href": "lessons/16_FA_over-representation_analysis.html#over-representation-analysis",
    "title": "Functional Analysis for RNA-seq: Over-representation analysis",
    "section": "Over-representation analysis",
    "text": "Over-representation analysis\nThere are a plethora of functional enrichment tools that perform some type of “over-representation” analysis by querying databases containing information about gene function and interactions.\nThese databases typically categorize genes into groups (gene sets) based on shared function, involvement in a pathway, presence in a specific cellular location, or other categorizations, e.g. functional pathways, etc. Essentially, known genes are binned into categories that have been consistently named (controlled vocabulary) based on how the gene has been annotated functionally. These categories are independent of any organism; however, each organism has distinct categorizations available.\nTo determine whether any categories are over-represented, you can determine the probability of having the observed proportion of genes associated with a specific category in your gene list based on the proportion of genes associated with the same category in the background set (gene categorizations for the appropriate organism).\n\n\n\n\n\n\nThe statistical test that will determine whether something is actually over-represented is the Hypergeometric test.\n\nHypergeometric testing\nUsing the example of the first functional category above, hypergeometric distribution is a probability distribution that describes the probability of 25 genes (k) being associated with “Functional category 1”, for all genes in our gene list (n=1000), from a population of all of the genes in entire genome (N=13,000) which contains 35 genes (K) associated with “Functional category 1” [2].\nThe calculation of probability of k successes follows the formula:\n\n\n\nThis test will result in an adjusted p-value (after multiple test correction) for each category tested.\n\n\nGene Ontology project\nOne of the most widely-used categorizations is the Gene Ontology (GO) established by the Gene Ontology project.\n“The Gene Ontology project is a collaborative effort to address the need for consistent descriptions of gene products across databases” [3]. The Gene Ontology Consortium maintains the GO terms, and these GO terms are incorporated into gene annotations in many of the popular repositories for animal, plant, and microbial genomes.\nTools that investigate enrichment of biological functions or interactions often use the Gene Ontology (GO) categorizations – i.e., the GO terms – to determine whether any have significantly modified representation in a given list of genes. Therefore, to best use and interpret the results from these functional analysis tools, it is helpful to have a good understanding of the GO terms themselves and their organization.\n\nGO Ontologies\nTo describe the roles of genes and gene products, GO terms are organized into three independent controlled vocabularies (ontologies) in a species-independent manner:\n\nBiological process: refers to the biological role involving the gene or gene product, and could include “transcription”, “signal transduction”, and “apoptosis”. A biological process generally involves a chemical or physical change of the starting material or input.\nMolecular function: represents the biochemical activity of the gene product. Such activities could include “ligand”, “GTPase”, and “transporter”.\nCellular component: refers to the location in the cell of the gene product. Cellular components could include “nucleus”, “lysosome”, and “plasma membrane”.\n\nEach GO term has a term name (e.g., DNA repair) and a unique term accession number (GO:0005125), and a single gene product can be associated with many GO terms, since a single gene product “may function in several processes, contain domains that carry out diverse molecular functions, and participate in multiple alternative interactions with other proteins, organelles or locations in the cell” [4].\n\n\nGO term hierarchy\nSome gene products are well-researched, with vast quantities of data available regarding their biological processes and functions. However, other gene products have very little data available about their roles in the cell.\nFor example, the protein “p53” would contain a wealth of information on its roles in the cell, whereas another protein might only be known as a “membrane-bound protein” with no other information available.\nThe GO ontologies were developed to describe and query biological knowledge with differing levels of information available. To do this, GO ontologies are loosely hierarchical, ranging from general ‘parent’ terms to more specific ‘child’ terms. The GO ontologies are “loosely” hierarchical since ‘child’ terms can have multiple ‘parent’ terms.\nSome genes with less information may only be associated with general ‘parent’ terms or no terms at all, while other genes with a lot of information be associated with many terms.\n\n\n\nNature Reviews Cancer 7, 23-34 (January 2007)\n\n\nTips for working with GO terms",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Over-representation analysis"
    ]
  },
  {
    "objectID": "lessons/16_FA_over-representation_analysis.html#clusterprofiler",
    "href": "lessons/16_FA_over-representation_analysis.html#clusterprofiler",
    "title": "Functional Analysis for RNA-seq: Over-representation analysis",
    "section": "clusterProfiler",
    "text": "clusterProfiler\nWe will be using clusterProfiler to perform over-representation analysis on GO terms associated with our list of significant genes. The tool takes as input a significant gene list and a background gene list and performs statistical enrichment analysis using hypergeometric testing. The basic arguments allow the user to select the appropriate organism and GO ontology (BP, CC, MF) to test.\n\nRunning clusterProfiler\nTo run clusterProfiler GO over-representation analysis, we will change our gene names into Ensembl IDs, since the tool works a bit easier with the Ensembl IDs.\nFirst load the following libraries:\n\n# Load libraries\nlibrary(DOSE)\nlibrary(pathview)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\n\nFor the different steps in the functional analysis, we require Ensembl and Entrez IDs. We will use the gene annotations that we generated previously to merge with our differential expression results. Before we do that, let’s subset our results tibble to only have the genes that were tested, i.e., genes whose adjusted p-values are not equal to NA.\n\n# Untested genes have padj = NA, so let's keep genes with padj != NA\nres_tableOE_tb_noNAs &lt;- filter(res_tableOE_tb, padj != \"NA\" )\n\n# Merge the AnnotationHub dataframe with the results \nres_ids &lt;- left_join(res_tableOE_tb_noNAs, annotations_ahb, by=c(\"gene\"=\"gene_id\")) \n\n\n\n\n\n\n\nNote\n\n\n\nIf you were unable to generate the annotations_ahb object, you can download the annotations to your data folder by right-clicking here and selecting “Save link as…”\nTo read in the object, you can run the following code:\n\nannotations_ahb &lt;- read.csv(\"./data/annotations_ahb.csv\")\n\n\n\nTo perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n\n# Create background dataset for hypergeometric testing using all tested genes for significance in the results\nallOE_genes &lt;- as.character(res_ids$gene)\n\n# Extract significant results\nsigOE &lt;- dplyr::filter(res_ids, padj &lt; 0.05)\nsigOE_genes &lt;- as.character(sigOE$gene)\n\nNow we can perform the GO enrichment analysis and save the results:\n\n\n\n\n\n\nNotes for running clusterProfiler\n\n\n\nThe different organisms with annotation databases available to use with for the OrgDb argument can be found here.\nAlso, the keyType argument may be coded as keytype in different versions of clusterProfiler.\nFinally, the ont argument can accept either “BP” (Biological Process), “MF” (Molecular Function), and “CC” (Cellular Component) subontologies, or “ALL” for all three.\n\n\n\n# Run GO enrichment analysis \nego &lt;- enrichGO(gene = sigOE_genes, \n                universe = allOE_genes,\n                keyType = \"ENSEMBL\",\n                OrgDb = org.Hs.eg.db, \n                ont = \"BP\", \n                pAdjustMethod = \"BH\", \n                qvalueCutoff = 0.05, \n                readable = TRUE)\n\n# Output results from GO analysis to a table\ncluster_summary &lt;- data.frame(ego)\n\n# View results\ncluster_summary %&gt;% head()\n\n                   ID                               Description GeneRatio\nGO:0080135 GO:0080135 regulation of cellular response to stress  205/3925\nGO:0098813 GO:0098813            nuclear chromosome segregation  126/3925\nGO:0006401 GO:0006401                     RNA catabolic process  121/3925\nGO:0006417 GO:0006417                 regulation of translation  145/3925\nGO:0000819 GO:0000819              sister chromatid segregation  101/3925\nGO:0043484 GO:0043484                regulation of RNA splicing   81/3925\n             BgRatio RichFactor FoldEnrichment   zScore       pvalue\nGO:0080135 492/13021  0.4166667       1.382272 5.678017 2.149930e-08\nGO:0098813 289/13021  0.4359862       1.446363 5.040680 6.968059e-07\nGO:0006401 280/13021  0.4321429       1.433613 4.818146 1.986663e-06\nGO:0006417 347/13021  0.4178674       1.386255 4.790517 2.064600e-06\nGO:0000819 227/13021  0.4449339       1.476047 4.752911 2.915791e-06\nGO:0043484 174/13021  0.4655172       1.544331 4.748288 3.351963e-06\n               p.adjust       qvalue\nGO:0080135 0.0001210626 0.0001137879\nGO:0098813 0.0019618569 0.0018439684\nGO:0006401 0.0029064405 0.0027317916\nGO:0006417 0.0029064405 0.0027317916\nGO:0000819 0.0030963784 0.0029103161\nGO:0043484 0.0030963784 0.0029103161\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 geneID\nGO:0080135 RAD52/BAD/CREBBP/MAPK8IP2/ERCC1/UFL1/SNAI2/FAS/CD44/BAK1/GRN/PARP3/AIFM2/HSPA5/ARID1B/HERPUD1/PIK3CB/FAM168A/PUM2/USP13/TMEM161A/SMARCD1/ATXN3/SMARCE1/ACTB/SIRT6/ZCWPW1/ZMPSTE24/TMED2/PPP1R15A/BAX/ATXN7L3/FUS/SIRT1/BCL7C/SMARCB1/MAPK1/TFIP11/XBP1/TELO2/YY1/CSNK2A1/ACTR5/USP14/PSMD10/MID1/SLC25A14/STUB1/RIPK2/EYA1/NBN/SGTA/PIAS4/YJU2/DNAJC2/CAV1/DNAJB6/NOD1/ZNHIT1/BCL7B/CREB3/CXCL12/C1QBP/DDX5/KAT2A/TMEM33/FBXW7/NSD2/CHORDC1/BCL7A/FOXM1/SPRING1/TIMELESS/LPCAT3/EYA4/OGG1/EIF4G1/INO80D/EFHD1/PRRX1/PARK7/ARHGEF2/PRDX1/RPA2/MAPKAP1/FKBP1B/SLF2/CLU/SHLD2/TWIST1/CYREN/MORF4L2/USP22/SOX4/EEF1E1/PRMT1/AUNIP/SMARCA4/INO80/TAF4/TRIM28/DNAJB1/SERINC3/DPF2/RNFT2/MDM2/TAF5L/ACTL6A/KLF4/MYC/KIAA0319/IER3/ACTR2/PDX1/TMBIM6/TMX1/IGF1R/MEAK7/PMAIP1/BRD4/APP/PTPRF/CERS2/DUSP10/PARP1/MANF/SKP2/EGFR/ATM/SLC7A11/PLA2R1/CEBPG/DDAH1/USP25/CREB3L1/PPP1R15B/CCAR2/CCDC117/UBQLN4/ZNF385A/RPL26/TAF6L/IER5/PPP4R2/MEAF6/PBRM1/CREBRF/BRD7/PLK1/OTUB1/NUDT16L1/DNAJC7/SEMA4C/USP47/NFRKB/NPAS2/TRIAP1/TADA3/BCL2L1/QARS1/EIF2AK3/KAT5/TADA2B/SMARCC1/KLHL15/RMI2/RUVBL1/NUPR1/ATAD5/SGF29/UBE2N/DMAP1/ERN1/GRINA/TAF7/SETD2/PTTG1IP/KMT5A/HSF1/MUC1/BRCC3/BCAP31/INSIG1/TAF9B/MCRS1/H2AX/NBR1/LRRK2/SF3B3/HMGB1/PPIA/TRRAP/PTPN1/SVIP/SPRED2/MTOR/OPA1/HSPA1A/BAG6/SPIRE2/DHFR/RTEL1/MARCHF6-DT/FIGNL2/PPP4R3B\nGO:0098813                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             POLDIP2/CDC27/BAZ1B/TACC3/NCAPH2/CENPQ/ARID1B/MSH4/NDC1/SMARCD1/RHOA/SIRT2/CDC42/TRIP13/SMC1A/SMARCE1/ACTB/MLH1/SPAG5/ZCWPW1/KIF22/NDC80/PIBF1/SEH1L/ZW10/TPX2/BIRC5/NUDC/KIF4A/CDC6/SIRT1/BCL7C/SMARCB1/CCNB1IP1/MYBL2/KIF3B/MAPRE1/CHMP4B/FAM83D/CEP192/CENPI/RAB11A/ARHGEF10/AKAP8/CCNE1/PPP2R1A/BCL7B/BCCIP/SMC3/KPNB1/RANGRF/BCL7A/CHMP3/CDC20/NSL1/STAG1/MLH3/TEX14/NCAPH/ZWINT/XRCC3/SMARCA4/INO80/CHMP1A/RAN/DPF2/CCNB1/PSRC1/CDCA8/ESPL1/USP44/ACTL6A/C9orf78/KIF23/ACTR2/KATNB1/KIF2C/CENPC/CDCA5/NCAPG2/ATM/INCENP/SPC25/SYCP2L/HNRNPU/SKA1/TTN/CCNB2/PMF1/SPC24/PBRM1/MAP9/DCAF13/GEM/BRD7/PLK1/GOLGA2/DDB1/KAT5/SMARCC1/ZWILCH/UBE2C/CCNE2/RMI2/CHMP6/AURKB/RRS1/RCC2/RCC1/MAPK15/SKA2/KMT5A/KNTC1/DRG1/KIF18B/SYCP2/ANAPC7/CHAMP1/EHMT2/HSPA1B/HSPA1A/MSH5/BAG6/KIFC1/LSM14A/UHRF1\nGO:0006401                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          CSDE1/RNH1/VIM/RNASET2/ZCCHC8/NSUN2/METTL1/EDC4/MRTO4/THRAP3/PUM2/YBX1/ELAVL1/ROCK1/SMG6/PABPC1/IGF2BP2/MLH1/TRAF5/TUT7/CNOT3/KHSRP/XRN2/FUS/ALKBH5/AGO1/CIRBP/DICER1/APEX1/E2F1/ELOB/POP1/RNASEH2A/PIAS4/DDX49/SMG9/LSM5/EXOSC3/LARP4B/CASC3/DDX5/ZPR1/RBM24/XRN1/SMG7/PPP1R8/SLIRP/NRDE2/TRIR/ZFP36/FXR2/LSM7/LSM4/ZC3H4/DKC1/GRSF1/RBM38/DHX34/CAPRIN1/TTC5/NCBP1/PNPT1/DNA2/SSB/LARP1B/SKIC8/TOB1/NT5C3B/AKT1/CNOT9/PNRC1/ATM/LSM14B/TIRAP/CARHSP1/HNRNPU/PRKCA/MOV10/LARP1/CNOT11/ZC3H18/IGF2BP1/BTG2/RBM47/ZC3H12A/WDR82/TENT2/FASTK/PATL1/DIS3L/POLR2G/FEN1/GDNF/EXOSC10/RNASEH1/PAIP1/RNASEH2C/ANGEL2/PDE12/HNRNPA0/ERN1/ZHX2/SAMD4B/RBM10/RBM33/ZFP36L1/SECISBP2/NANOS1/CNOT7/NBDY/DXO/HSPA1B/HSPA1A/LSM2/FASTKD5/XIST/NEAT1/OIP5-AS1/MALAT1/RBM8A/SYNCRIP\nGO:0006417                                                                                                                                                                                                                                                                                                                                                                                           CSDE1/PRKCH/SARS1/PUM2/EIF4B/YBX1/ELAVL1/PKM/ELP1/PABPC1/TCOF1/IGF2BP2/EIF4G3/MKNK1/DDX1/JMJD4/BZW1/PPP1R15A/CNOT3/MAPKAPK5/GCN1/AARS1/ALKBH5/AGO1/CIRBP/POLDIP3/EIF5/PCIF1/MTG2/CSNK2A1/CELF4/RBM3/EEF2K/AKT2/MTPN/HSPB1/EIF3B/EIF4H/LARP4B/CASC3/RPS6KB1/C1QBP/EIF4G2/DDX6/CAPRIN2/RBM24/XRN1/EIF1B/EIF4G1/NCL/IGFBP5/EIF2B2/PAIP2/SERP1/KHDRBS1/ACO1/TSFM/METTL8/PAIP2B/SOX4/STK35/PRMT1/ZFP36/FXR2/ILF3/SESN2/SHFL/UNK/EIF5A/ELP2/NAT10/CAPRIN1/BZW2/TACO1/DNAJC1/NCBP1/CPEB2/SSB/LARP1B/TARBP2/TOB1/APP/AKT1/CNOT9/PURB/OGT/EIF3H/INPP5E/EIF4EBP2/MTG1/LSM14B/GUF1/HNRNPU/MSI2/OTUD6B/LARP1/EIF4A2/RPUSD3/CNOT11/PPP1R15B/IGF2BP1/BTG2/ZNF385A/LARP4/RPL26/KBTBD8/ELP6/RPUSD4/NOLC1/TRUB2/ZNF598/POLR2G/ELP5/PA2G4/ENC1/EIF2AK3/PAIP1/PPP1CA/EIF1/PDIK1L/SLC35A4/SAMD4B/SHMT2/NGRN/KLHL25/COA3/EIF3C/RPS27L/ZFP36L1/SECISBP2/NANOS1/NHLRC3/DAPK1/CNOT7/MTOR/SELENOT/ATXN2/SARNP/IFRD2/DHFR/EIF5AL1/LSM14A/RBM8A/SYNCRIP/RCC1L\nGO:0000819                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 POLDIP2/CDC27/BAZ1B/TACC3/NCAPH2/ARID1B/SMARCD1/RHOA/TRIP13/SMC1A/SMARCE1/ACTB/SPAG5/KIF22/NDC80/PIBF1/SEH1L/ZW10/TPX2/BIRC5/NUDC/KIF4A/CDC6/SIRT1/BCL7C/SMARCB1/MYBL2/KIF3B/MAPRE1/CHMP4B/CEP192/CENPI/RAB11A/ARHGEF10/AKAP8/PPP2R1A/BCL7B/BCCIP/SMC3/KPNB1/RANGRF/BCL7A/CHMP3/CDC20/NSL1/STAG1/TEX14/NCAPH/ZWINT/XRCC3/SMARCA4/INO80/CHMP1A/RAN/DPF2/CCNB1/PSRC1/CDCA8/ESPL1/USP44/ACTL6A/KIF23/KATNB1/KIF2C/CENPC/CDCA5/NCAPG2/ATM/INCENP/SPC25/HNRNPU/SKA1/TTN/SPC24/PBRM1/MAP9/BRD7/PLK1/GOLGA2/KAT5/SMARCC1/ZWILCH/UBE2C/RMI2/CHMP6/AURKB/RRS1/RCC1/MAPK15/SKA2/KMT5A/KNTC1/DRG1/KIF18B/ANAPC7/CHAMP1/HSPA1B/HSPA1A/KIFC1/LSM14A/UHRF1\nGO:0043484                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     PTBP1/CLK1/CELF2/THRAP3/SFSWAP/U2AF2/DAZAP1/FAM50A/CLNS1A/MBNL3/RBM22/ATXN7L3/FUS/CIRBP/RBFOX2/RBM23/PRMT5/ACIN1/CELF4/PQBP1/RBM3/HNRNPL/SNRNP70/C1QBP/DDX5/KAT2A/ZPR1/HSPA8/PRPF19/NUP98/SRSF9/RBM24/NCL/WDR77/PRDX6/KHDRBS1/SMU1/SRSF6/USP22/AHNAK/RBM42/HNRNPH2/RBM39/GRSF1/RBM38/ARGLU1/HNRNPA1/TAF5L/NCBP1/TMBIM6/MBNL2/MBNL1/HNRNPU/RRP1B/TAF6L/ZNF326/RBM15/CCNL1/RBM47/FASTK/RBPMS2/SF1/HNRNPF/TADA3/EXOSC10/TADA2B/EIF1/SGF29/ERN1/ZBTB7A/PUF60/RBM10/RBM11/SF3B3/TRRAP/RPS26/AKAP17A/RBM20/HSPA1A/RBM15B/RBM8A\n           Count\nGO:0080135   205\nGO:0098813   126\nGO:0006401   121\nGO:0006417   145\nGO:0000819   101\nGO:0043484    81\n\n\n\n# Save results\nwrite.csv(cluster_summary, \"../results/clusterProfiler_Mov10oe.csv\")\n\n\n\n\n\n\n\nNote\n\n\n\nInstead of saving just the results summary from the ego object, it might also be beneficial to save the object itself. The save() function enables you to save it as a .rda file, e.g. save(ego, file=\"results/ego.rda\").\nThe complementary function to save() is the function load(), e.g. ego &lt;- load(file=\"results/ego.rda\").\nThis is a useful set of functions to know, since it enables one to preserve analyses at specific stages and reload them when needed. More information about these functions can be found here & here.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou can also perform GO enrichment analysis with only the up or down regulated genes in addition to performing it for the full list of significant genes. This can be useful to identify GO terms impacted in one direction and not the other. If very few genes are in any of these lists (&lt; 50, roughly) it may not be possible to get any significant GO terms.\n\n# Extract upregulated genes\nsigOE_up &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &gt; 0)\nsigOE_up_genes &lt;- as.character(sigOE_up$gene)\n\n## Extract downregulated genes\nsigOE_down &lt;- dplyr::filter(res_ids, padj &lt; 0.05 & log2FoldChange &lt; 0)\nsigOE_down_genes &lt;- as.character(sigOE_down$gene)\n\nYou can then create ego_up & ego_down objects by running the enrichGO() function for gene = sigOE_up_genes or gene = sigOE_down_genes.\n\n\n\n\nVisualizing clusterProfiler results\nclusterProfiler has a variety of options for viewing the over-represented GO terms. We will explore the dotplot, enrichment plot, and the category netplot.\nThe dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 30 GO terms by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value.\n\n# Dotplot for the top 30 GO terms\ndotplot(ego, showCategory=30)\n\n\n\n\n\n\n\n\n\n# Save the figure: it has to be very large for the text labels to all fit!\nggsave(filename = \"results/plots_OE_ORA_dotplot.pdf\", width = 8, height = 20)\n\nThe next plot is the enrichment GO plot, which shows the relationship between the top 30 most significantly enriched GO terms (by padj), by grouping similar terms together. Before creating the plot, we will need to obtain the similarity between terms using the pairwise_termsim() function (instructions for emapplot). In the enrichment plot, the color represents the p-values relative to the other displayed terms (brighter red is more significant), and the size of the terms represents the number of genes that are significant from our list.\n\n# Add similarity matrix to the termsim slot of enrichment result\nego &lt;- enrichplot::pairwise_termsim(ego)\n\n# Enrichmap clusters the 30 most significant (by padj) GO terms to visualize relationships between terms\nemapplot(ego, showCategory = 30)\n\n\n\n\n\n\n\n\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_enrich.pdf\", width = 10, height = 10)\n\nFinally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the number of genes in the terms, with terms with more genes being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes.\n\n\n\n\n\n\nNote\n\n\n\nYou may need to install the ggnewscale package using install.packages(\"ggnewscale\") for the cnetplot() function to work.\n\n\n\n# To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector\nOE_foldchanges &lt;- sigOE$log2FoldChange\nnames(OE_foldchanges) &lt;- sigOE$gene\n\n# Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj)\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n\n\n\n\n\n\n\n# If some of the high fold changes are getting drowned out due to a large range, you could set a maximum fold change value\nOE_foldchanges &lt;- ifelse(OE_foldchanges &gt;  2,  2, OE_foldchanges)\nOE_foldchanges &lt;- ifelse(OE_foldchanges &lt; -2, -2, OE_foldchanges)\n\ncnetplot(ego, \n         showCategory = 5, \n         foldChange = OE_foldchanges,\n         vertex.label.font = 6)\n\n\n\n\n\n\n\n\n\n# Save the figure\nggsave(filename = \"results/plots_OE_ORA_net.pdf\", width = 10, height = 10)\n\nIf you are interested in significant processes that are not among the top five, you can subset your ego dataset to only display these processes:\n\n# Subsetting the ego results without overwriting original `ego` variable\nego2 &lt;- ego\nego2@result &lt;- ego@result[c(1,3,4,8,9),]\n\n# Plotting terms of interest\ncnetplot(ego2, \n         categorySize = \"pvalue\", \n         foldChange = OE_foldchanges, \n         showCategory = 5, \n         vertex.label.font = 6)",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Over-representation analysis"
    ]
  },
  {
    "objectID": "lessons/14_time_course_analyses.html",
    "href": "lessons/14_time_course_analyses.html",
    "title": "Time course analysis with DESeq2",
    "section": "",
    "text": "Approximate time: 20 minutes",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/14_time_course_analyses.html#learning-objectives",
    "href": "lessons/14_time_course_analyses.html#learning-objectives",
    "title": "Time course analysis with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss time course analyses with DESeq2",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/14_time_course_analyses.html#time-course-analyses-with-lrt",
    "href": "lessons/14_time_course_analyses.html#time-course-analyses-with-lrt",
    "title": "Time course analysis with DESeq2",
    "section": "Time course analyses with LRT",
    "text": "Time course analyses with LRT\nDespite the popularity of static measurement of gene expression, time-course capturing of biological processes is essential to reflect their dynamic nature, particularly when patterns are complex and are not simply ascending or descending. When working with this type of data, the Likelihood Ratio Test (LRT) is especially helpful. We can use the LRT to explore whether there are any significant differences across a series of timepoints and further evaluate differences observed between sample classes.\nFor example, suppose we have an experiment looking at the effect of treatment over time on mice of two different genotypes. We could use a design formula for our ‘full model’ that would include the major sources of variation in our data: genotype, treatment, time, and our main condition of interest, which is the difference in the effect of treatment over time (treatment:time).\n\n\n\n\n\n\nWarning\n\n\n\nThis is just example code for our hypothetical experiment. You should not run this code.\n\n\n\n## DO NOT RUN THIS CODE\n\nfull_model &lt;- ~ genotype + treatment + time + treatment:time\n\nTo perform the LRT test, we also need to provide a reduced model, that is the full model without the treatment:time term:\n\n## DO NOT RUN THIS CODE\n\nreduced_model &lt;- ~ genotype + treatment + time\n\nThen, we could run the LRT by using the following code:\n\n## DO NOT RUN THIS CODE\n\ndds &lt;- DESeqDataSetFromMatrix(countData = raw_counts,\n                              colData = metadata,\n                              design = ~ genotype + treatment + time + treatment:time)\n\ndds_lrt_time &lt;- DESeq(dds, test=\"LRT\", reduced = ~ genotype + treatment + time)\n\nTo understand what kind of gene expression patterns will be identified as differentially expressed, we have a few examples below. In the plots below we have time on the x-axis and gene expression on the y-axis. In this dataset there are two samples for each time point, one having undergone some treatment (red) and the other without (blue).\nFor this figure, we are depicting the type of genes that will not be identified as differentially expressed. Here, we observe that GeneX is differentially expressed between the time points, however there is no difference in that expression pattern between the treatment groups.\n\n\n\nThe type of gene expression patterns we do expect the LRT to return are those that exhibit differences in the effect of treatment over time. In the example below, GeneX displays a different expression pattern over time for the two treatment groups.\n\n\n\nContinuing with our example dataset, after running the LRT we can determine the set of significant genes using a threshold of padj &lt; 0.05. The next step would be to sort those genes into groups based on shared expression patterns, and we could do this using degPatterns(). Here, you will notice that we make use of the col argument since we have two groups that we are comparing to one another.\n\n## DO NOT RUN THIS CODE\n\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"time\", col = \"treatment\")\n\nDepending on what type of shared expression profiles exist in your data, you can then extract the groups of genes associated with the patterns of interest and move on to functional analysis for each of the gene groups of interest.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 3 Self-learning",
      "Time course analysis with DESeq2"
    ]
  },
  {
    "objectID": "lessons/Aside_pathway_topology.html",
    "href": "lessons/Aside_pathway_topology.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nSPIA\nThe SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. The blog post from Getting Genetics Done provides a step-by-step procedure for using and understanding SPIA.\n\n# Install package (if needed)\n# BiocManager::install(\"SPIA\")\n\n# Load package\nlibrary(SPIA)\n\nTo perform SPIA, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes).\n\n# The background set is a vector of all the genes represented on the platform\nbackground_entrez &lt;- res_entrez$entrezid\n\n# Significant genes is a vector of fold changes where the names are ENTREZ gene IDs\nsig_res_entrez &lt;- res_entrez[which(res_entrez$padj &lt; 0.05), ]\nsig_entrez &lt;- sig_res_entrez$log2FoldChange\nnames(sig_entrez) &lt;- sig_res_entrez$entrezid\n\n# Look at the significant gene list input\nhead(sig_entrez)\n\n      7105       8813      55732       2729       4800       5893 \n-0.4197796  0.3410360 -0.2473067 -0.2696720 -0.2883368 -0.2728536 \n\n\nNow that we have our background and significant genes in the appropriate format, we can run SPIA (this will take a few minutes as it runs through all the pathways):\n\n# Run SPIA\nspia_result &lt;- spia(de=sig_entrez, all=background_entrez, organism=\"hsa\")\n\n\nDone pathway 1 : RNA transport..\nDone pathway 2 : RNA degradation..\nDone pathway 3 : PPAR signaling pathway..\nDone pathway 4 : Fanconi anemia pathway..\nDone pathway 5 : MAPK signaling pathway..\nDone pathway 6 : ErbB signaling pathway..\nDone pathway 7 : Calcium signaling pathway..\nDone pathway 8 : Cytokine-cytokine receptor int..\nDone pathway 9 : Chemokine signaling pathway..\nDone pathway 10 : NF-kappa B signaling pathway..\nDone pathway 11 : Phosphatidylinositol signaling..\nDone pathway 12 : Neuroactive ligand-receptor in..\nDone pathway 13 : Cell cycle..\nDone pathway 14 : Oocyte meiosis..\nDone pathway 15 : p53 signaling pathway..\nDone pathway 16 : Sulfur relay system..\nDone pathway 17 : SNARE interactions in vesicula..\nDone pathway 18 : Regulation of autophagy..\nDone pathway 19 : Protein processing in endoplas..\nDone pathway 20 : Lysosome..\nDone pathway 21 : mTOR signaling pathway..\nDone pathway 22 : Apoptosis..\nDone pathway 23 : Vascular smooth muscle contrac..\nDone pathway 24 : Wnt signaling pathway..\nDone pathway 25 : Dorso-ventral axis formation..\nDone pathway 26 : Notch signaling pathway..\nDone pathway 27 : Hedgehog signaling pathway..\nDone pathway 28 : TGF-beta signaling pathway..\nDone pathway 29 : Axon guidance..\nDone pathway 30 : VEGF signaling pathway..\nDone pathway 31 : Osteoclast differentiation..\nDone pathway 32 : Focal adhesion..\nDone pathway 33 : ECM-receptor interaction..\nDone pathway 34 : Cell adhesion molecules (CAMs)..\nDone pathway 35 : Adherens junction..\nDone pathway 36 : Tight junction..\nDone pathway 37 : Gap junction..\nDone pathway 38 : Complement and coagulation cas..\nDone pathway 39 : Antigen processing and present..\nDone pathway 40 : Toll-like receptor signaling p..\nDone pathway 41 : NOD-like receptor signaling pa..\nDone pathway 42 : RIG-I-like receptor signaling ..\nDone pathway 43 : Cytosolic DNA-sensing pathway..\nDone pathway 44 : Jak-STAT signaling pathway..\nDone pathway 45 : Natural killer cell mediated c..\nDone pathway 46 : T cell receptor signaling path..\nDone pathway 47 : B cell receptor signaling path..\nDone pathway 48 : Fc epsilon RI signaling pathwa..\nDone pathway 49 : Fc gamma R-mediated phagocytos..\nDone pathway 50 : Leukocyte transendothelial mig..\nDone pathway 51 : Intestinal immune network for ..\nDone pathway 52 : Circadian rhythm - mammal..\nDone pathway 53 : Long-term potentiation..\nDone pathway 54 : Neurotrophin signaling pathway..\nDone pathway 55 : Retrograde endocannabinoid sig..\nDone pathway 56 : Glutamatergic synapse..\nDone pathway 57 : Cholinergic synapse..\nDone pathway 58 : Serotonergic synapse..\nDone pathway 59 : GABAergic synapse..\nDone pathway 60 : Dopaminergic synapse..\nDone pathway 61 : Long-term depression..\nDone pathway 62 : Olfactory transduction..\nDone pathway 63 : Taste transduction..\nDone pathway 64 : Phototransduction..\nDone pathway 65 : Regulation of actin cytoskelet..\nDone pathway 66 : Insulin signaling pathway..\nDone pathway 67 : GnRH signaling pathway..\nDone pathway 68 : Progesterone-mediated oocyte m..\nDone pathway 69 : Melanogenesis..\nDone pathway 70 : Adipocytokine signaling pathwa..\nDone pathway 71 : Type II diabetes mellitus..\nDone pathway 72 : Type I diabetes mellitus..\nDone pathway 73 : Maturity onset diabetes of the..\nDone pathway 74 : Aldosterone-regulated sodium r..\nDone pathway 75 : Endocrine and other factor-reg..\nDone pathway 76 : Vasopressin-regulated water re..\nDone pathway 77 : Salivary secretion..\nDone pathway 78 : Gastric acid secretion..\nDone pathway 79 : Pancreatic secretion..\nDone pathway 80 : Carbohydrate digestion and abs..\nDone pathway 81 : Bile secretion..\nDone pathway 82 : Mineral absorption..\nDone pathway 83 : Alzheimer's disease..\nDone pathway 84 : Parkinson's disease..\nDone pathway 85 : Amyotrophic lateral sclerosis ..\nDone pathway 86 : Huntington's disease..\nDone pathway 87 : Prion diseases..\nDone pathway 88 : Cocaine addiction..\nDone pathway 89 : Amphetamine addiction..\nDone pathway 90 : Morphine addiction..\nDone pathway 91 : Alcoholism..\nDone pathway 92 : Bacterial invasion of epitheli..\nDone pathway 93 : Vibrio cholerae infection..\nDone pathway 94 : Epithelial cell signaling in H..\nDone pathway 95 : Pathogenic Escherichia coli in..\nDone pathway 96 : Shigellosis..\nDone pathway 97 : Salmonella infection..\nDone pathway 98 : Pertussis..\nDone pathway 99 : Legionellosis..\nDone pathway 100 : Leishmaniasis..\nDone pathway 101 : Chagas disease (American trypa..\nDone pathway 102 : African trypanosomiasis..\nDone pathway 103 : Malaria..\nDone pathway 104 : Toxoplasmosis..\nDone pathway 105 : Amoebiasis..\nDone pathway 106 : Staphylococcus aureus infectio..\nDone pathway 107 : Tuberculosis..\nDone pathway 108 : Hepatitis C..\nDone pathway 109 : Measles..\nDone pathway 110 : Influenza A..\nDone pathway 111 : HTLV-I infection..\nDone pathway 112 : Herpes simplex infection..\nDone pathway 113 : Epstein-Barr virus infection..\nDone pathway 114 : Pathways in cancer..\nDone pathway 115 : Transcriptional misregulation ..\nDone pathway 116 : Viral carcinogenesis..\nDone pathway 117 : Colorectal cancer..\nDone pathway 118 : Renal cell carcinoma..\nDone pathway 119 : Pancreatic cancer..\nDone pathway 120 : Endometrial cancer..\nDone pathway 121 : Glioma..\nDone pathway 122 : Prostate cancer..\nDone pathway 123 : Thyroid cancer..\nDone pathway 124 : Basal cell carcinoma..\nDone pathway 125 : Melanoma..\nDone pathway 126 : Bladder cancer..\nDone pathway 127 : Chronic myeloid leukemia..\nDone pathway 128 : Acute myeloid leukemia..\nDone pathway 129 : Small cell lung cancer..\nDone pathway 130 : Non-small cell lung cancer..\nDone pathway 131 : Asthma..\nDone pathway 132 : Autoimmune thyroid disease..\nDone pathway 133 : Systemic lupus erythematosus..\nDone pathway 134 : Rheumatoid arthritis..\nDone pathway 135 : Allograft rejection..\nDone pathway 136 : Graft-versus-host disease..\nDone pathway 137 : Arrhythmogenic right ventricul..\nDone pathway 138 : Dilated cardiomyopathy..\nDone pathway 139 : Viral myocarditis..\n\n# Look at the results\nhead(spia_result, n=20)\n\n                                     Name    ID pSize NDE         pNDE\n1                    Viral carcinogenesis 05203   179  85 1.105913e-07\n2   Pathogenic Escherichia coli infection 05130    47  26 1.384417e-04\n3                           RNA transport 03013   145  63 1.364787e-04\n4            Epstein-Barr virus infection 05169   182  73 7.872927e-04\n5            Systemic lupus erythematosus 05322    74  35 6.338994e-04\n6                     Parkinson's disease 05012   120  50 1.935891e-03\n7                          Focal adhesion 04510   182  65 2.836833e-02\n8                   p53 signaling pathway 04115    66  32 6.225200e-04\n9                          Bladder cancer 05219    40  20 4.025368e-03\n10                             Cell cycle 04110   121  51 1.299369e-03\n11               Chronic myeloid leukemia 05220    70  29 1.719907e-02\n12              Circadian rhythm - mammal 04710    21  10 5.446312e-02\n13                       HTLV-I infection 05166   226  87 1.219991e-03\n14               ECM-receptor interaction 04512    70  26 8.644146e-02\n15                             Alcoholism 05034   124  49 7.371891e-03\n16                 MAPK signaling pathway 04010   224  76 5.975551e-02\n17 Cytokine-cytokine receptor interaction 04060   122  38 3.298457e-01\n18                 Small cell lung cancer 05222    80  32 2.221126e-02\n19       Regulation of actin cytoskeleton 04810   180  60 1.136433e-01\n20              Vibrio cholerae infection 05110    48  21 2.055235e-02\n            tA pPERT           pG        pGFdr       pGFWER    Status\n1   1.06476367 0.106 2.257992e-07 0.0000309345 0.0000309345 Activated\n2  -2.68535900 0.508 7.428320e-04 0.0508839887 0.1017679775 Inhibited\n3   0.14039420 0.821 1.131312e-03 0.0516632252 0.1549896757 Activated\n4  -3.29767850 0.320 2.339543e-03 0.0801293411 0.3205173645 Inhibited\n5   0.63886550 0.552 3.134455e-03 0.0843101831 0.4294203963 Activated\n6  -3.38846958 0.223 3.776445e-03 0.0843101831 0.5173729580 Inhibited\n7  22.00835240 0.018 4.381136e-03 0.0843101831 0.6002156717 Activated\n8  -0.07045235 0.977 5.111940e-03 0.0843101831 0.7003358416 Inhibited\n9  -4.12392474 0.185 6.108373e-03 0.0843101831 0.8368471586 Inhibited\n10  2.88206442 0.578 6.154028e-03 0.0843101831 0.8431018308 Activated\n11 -7.14491710 0.051 7.051281e-03 0.0844021190 0.9660255137 Inhibited\n12 -5.85306921 0.017 7.392886e-03 0.0844021190 1.0000000000 Inhibited\n13 -0.28565758 0.945 8.952757e-03 0.0913882483 1.0000000000 Inhibited\n14  6.50476159 0.014 9.338945e-03 0.0913882483 1.0000000000 Activated\n15 -7.40641835 0.234 1.270050e-02 0.1124219731 1.0000000000 Inhibited\n16  8.95882802 0.030 1.312957e-02 0.1124219731 1.0000000000 Activated\n17  7.49673694 0.006 1.429906e-02 0.1129193776 1.0000000000 Activated\n18  9.11228085 0.093 1.483612e-02 0.1129193776 1.0000000000 Activated\n19 18.84748586 0.020 1.610715e-02 0.1161410145 1.0000000000 Activated\n20 -1.35210996 0.118 1.702923e-02 0.1166502561 1.0000000000 Inhibited\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               KEGGLINK\n1            http://www.genome.jp/dbget-bin/show_pathway?hsa05203+1739+5829+578+3661+5700+1108+3725+836+581+572+5366+7187+7188+1642+5594+10488+64764+90993+9586+6777+5291+5293+5966+1959+1019+55697+5902+2648+6850+3718+595+894+896+890+4193+28973+898+9134+1233+7419+3265+3845+4893+10971+7529+7531+7532+7534+6502+2965+1387+9114+1026+5315+3065+5922+998+387+81+88+2957+991+3665+3106+3107+3133+3134+5566+5567+2885+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370\n2                                                                                                                                                                                                                                                                                                          http://www.genome.jp/dbget-bin/show_pathway?hsa05130+10376+51807+7277+7846+84790+999+10971+7534+3875+1499+2017+6093+998+5578+9181+387+4691+10381+10383+203068+347733+10092+10093+10552+60+71\n3                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa03013+11260+5901+7514+4686+1207+79760+3837+10073+9939+22794+22985+10482+56000+5411+10189+29107+55916+10762+4928+79902+81929+8480+23225+94026+9883+55706+5905+6612+10419+1917+51068+10209+10289+1964+8661+8662+8663+8666+8667+8668+10556+10775+10799+10940+84321+79228+132430+26986+80336+1968+8894+10605+1973+1974+1981+1982+8672+1983+1975+10460+8892+26999+9513\n4                                                                   http://www.genome.jp/dbget-bin/show_pathway?hsa05169+3113+3106+3107+3133+3134+9612+10971+7529+7531+7532+7534+3303+3304+3305+3306+3310+3312+3315+4609+3065+1387+890+6502+8737+7187+7188+9020+3654+960+5602+3725+3718+5291+5293+207+208+6850+5336+5432+5433+5434+5435+5436+5438+5439+5441+11128+171568+51728+55718+661+84265+3661+9451+7431+7514+5901+5566+5567+1457+1460+1026+4193+3588+5700+5701+5702+5704+5705+5707+5708+5709+5717\n5                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa05322+720+717+3111+3113+3014+8329+8334+8336+92815+94239+9555+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+126961+3020+8357+554313+8360+8362+8367+8370+6628+6632+6634+81+88+6741\n6                                                                                                                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa05012+120892+7332+9246+2861+11315+7345+4535+4536+4537+4538+4539+4540+4541+4697+4702+4706+4708+4713+4714+4715+4717+4718+4720+4725+4726+4728+4729+54539+6391+27089+440567+4519+1340+1349+4513+4514+9377+4508+4509+506+515+518+10105+293+7416+7419+7326+7327+842+836\n7                                                                                                                         http://www.genome.jp/dbget-bin/show_pathway?hsa04510+3693+22801+3655+3672+3675+3676+3678+2318+998+85366+10627+1729+5499+6093+207+208+5170+55742+7408+5291+5293+81+88+824+5829+5578+387+5923+1280+1288+1289+1292+1302+284217+3908+3909+3911+3912+3915+7058+7059+857+331+572+2002+5594+595+894+896+3265+2885+1956+3480+5156+5159+5154+5228+25759+1398+2889+5602+3725+1499+60+71\n8                                                                                                                                                                                                                                                                                     http://www.genome.jp/dbget-bin/show_pathway?hsa04115+1647+4616+472+898+9134+8493+7161+900+6241+1643+1026+64393+9538+355+51512+581+8795+842+4193+1019+595+894+896+64065+51246+143686+83667+85417+891+9133+836+5366\n9                                                                                                                                                                                                                                                                                                                                                 http://www.genome.jp/dbget-bin/show_pathway?hsa05219+3265+4313+5228+3576+1956+999+1026+4609+1612+4193+1869+1870+2261+1019+595+9252+5594+369+3845+4893\n10                                                                                                                                                                                          http://www.genome.jp/dbget-bin/show_pathway?hsa04110+51343+4171+4172+4173+4176+4998+51434+996+6500+8454+5347+472+10971+7529+7531+7532+7534+1026+4193+1387+6502+9088+9700+8243+1647+4616+8317+991+994+990+993+85417+891+9133+890+1019+902+898+9134+595+894+896+9126+10274+1874+4609+7709+7027+1869+1870+3065\n11                                                                                                                                                                                                                                                                                                     http://www.genome.jp/dbget-bin/show_pathway?hsa05220+2122+598+5781+3065+1487+4609+7048+7046+6777+4193+572+1026+2885+25759+9846+1398+1869+1870+1019+595+207+208+5291+5293+5594+369+3265+3845+4893\n12                                                                                                                                                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa04710+79365+8553+1408+4862+9572+5187+8863+6500+8454+8945\n13 http://www.genome.jp/dbget-bin/show_pathway?hsa05166+6513+10725+4773+11261+5532+5534+3718+6777+3106+3107+3133+3134+4609+8295+10524+894+3265+3845+4893+6237+293+7416+7419+7514+5901+8498+107+113+5566+5567+467+7494+7046+7048+5425+5427+56655+1026+51434+996+991+9133+5902+55697+9020+115650+5602+3725+598+331+5156+5159+5154+5291+5293+207+208+11211+8322+1855+1857+1499+1739+1019+595+896+1869+1870+2002+2005+2353+1958+1959+8061+3111+3113+2648+1387+6929+581+4605+23373+64784+4488+7538+472+94241\n14                                                                                                                                                                                                                                                                                                              http://www.genome.jp/dbget-bin/show_pathway?hsa04512+284217+3908+3909+3911+3912+3915+1280+1288+1289+1292+1302+1605+7058+7059+3655+3676+3161+961+6382+6385+3693+22801+3678+3675+3672+960\n15                                                                                                                                                                                http://www.genome.jp/dbget-bin/show_pathway?hsa05034+5499+5566+10488+64764+90993+9586+814+3065+808+2771+2782+2786+2790+2792+2030+3265+3845+4893+369+5594+2354+3014+8329+8334+8336+92815+94239+9555+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370+126961+3020+8357+4915+25759+2885\n16                                                        http://www.genome.jp/dbget-bin/show_pathway?hsa04010+5923+11221+80824+5495+9448+5321+3925+9020+5594+8649+5578+5566+5567+9693+5922+3265+3845+4893+6237+10235+2768+2885+5156+5159+2261+2263+1956+4915+785+8912+8913+9254+5154+2247+2256+8074+994+9252+7867+4149+1649+2005+2002+5536+207+208+3315+1647+4616+1616+836+7046+7048+355+8550+998+23542+5602+1398+409+2122+3303+3304+3305+3306+3310+3312+3725+4773+11261+5532+5534+2318+2353+4609+8569\n17                                                                                                                                                                                                                                                http://www.genome.jp/dbget-bin/show_pathway?hsa04060+659+3588+8809+657+7046+7048+268+83729+3625+3624+60401+115650+3604+355+8744+970+53832+3815+1956+5159+5156+4254+1435+5154+7173+85480+3953+1271+9180+3589+1233+1235+6387+3576+27242+51330+8795+8793\n18                                                                                                                                                                                                                                                                                      http://www.genome.jp/dbget-bin/show_pathway?hsa05222+898+9134+595+3655+3675+9063+6257+5915+207+208+842+4149+4609+5291+5293+2272+1288+284217+3908+3909+3911+3912+3915+331+598+7187+7188+9618+1869+1870+1019+6502\n19                                                                                                                                   http://www.genome.jp/dbget-bin/show_pathway?hsa04810+7114+10092+10093+10552+5216+10163+55845+50649+10152+26999+10458+1072+3985+79837+8396+1729+81+88+4478+5962+5829+5499+10627+85366+6093+9459+998+387+9138+8826+5594+369+5291+5293+1398+22801+3655+3672+3675+3676+3678+3682+3693+3265+3845+4893+6237+2768+1956+2261+2263+5156+5159+2247+2256+5154+8074+2149+60+71\n20                                                                                                                                                                                                                                                                                                                                         http://www.genome.jp/dbget-bin/show_pathway?hsa05110+155066+23545+527+528+535+537+9114+9296+9550+5578+6558+5336+5566+5567+29927+55176+60+71+9601+10945+11014\n\n\nSPIA outputs a table showing significantly dysregulated pathways based on over-representation and signaling perturbations accumulation. The table shows the following information:\n\npSize: the number of genes on the pathway\nNDE: the number of DE genes per pathway\ntA: the observed total perturbation accumulation in the pathway\npNDE: the probability to observe at least NDE genes on the pathway using a hypergeometric model (similar to ORA)\npPERT: the probability to observe a total accumulation more extreme than tA only by chance\npG: the p-value obtained by combining pNDE and pPERT\npGFdr and pGFWER are the False Discovery Rate and Bonferroni adjusted global p-values, respectively\nStatus: gives the direction in which the pathway is perturbed (activated or inhibited)\nKEGGLINK gives a web link to the KEGG website that displays the pathway image with the differentially expressed genes highlighted in red\n\nWe can view the significantly dysregulated pathways by viewing the over-representation and perturbations for each pathway.\n\n# To avoid an error, remove any rows where `pPERT` is NA\nspia_result &lt;- spia_result %&gt;% filter(!is.na(pPERT))\n\n# Plot significant pathways\nplotP(spia_result, threshold=0.05)\n\n\n\n\n\n\n\n\nIn this plot, each pathway is a point and the coordinates are the log of pNDE (using a hypergeometric model) and the p-value from perturbations, pPERT. The oblique lines in the plot show the significance regions based on the combined evidence.\nIf we choose to explore the significant genes from our dataset occurring in these pathways, we can subset our SPIA results:\n\n# Look at pathway 05203 and view kegglink\nsubset(spia_result, ID == \"05203\")\n\n                  Name    ID pSize NDE         pNDE       tA pPERT           pG\n1 Viral carcinogenesis 05203   179  85 1.105913e-07 1.064764 0.106 2.257992e-07\n        pGFdr      pGFWER    Status\n1 3.09345e-05 3.09345e-05 Activated\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    KEGGLINK\n1 http://www.genome.jp/dbget-bin/show_pathway?hsa05203+1739+5829+578+3661+5700+1108+3725+836+581+572+5366+7187+7188+1642+5594+10488+64764+90993+9586+6777+5291+5293+5966+1959+1019+55697+5902+2648+6850+3718+595+894+896+890+4193+28973+898+9134+1233+7419+3265+3845+4893+10971+7529+7531+7532+7534+6502+2965+1387+9114+1026+5315+3065+5922+998+387+81+88+2957+991+3665+3106+3107+3133+3134+5566+5567+2885+128312+3017+440689+8341+8343+8347+8348+8349+85236+8970+554313+8360+8362+8367+8370\n\n\nThen, if we click on the KEGGLINK, we can view the genes within our dataset from these perturbed pathways:\n\n\n\nKEGG pathway with significant genes highlighted"
  },
  {
    "objectID": "lessons/10_wald_test_results.html",
    "href": "lessons/10_wald_test_results.html",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#learning-objectives",
    "href": "lessons/10_wald_test_results.html#learning-objectives",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDiscuss the steps required to generate a results table for pairwise comparisons (Wald test)\nSummarize the different levels of gene filtering\nExplain log fold change shrinkage",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#specifying-contrasts",
    "href": "lessons/10_wald_test_results.html#specifying-contrasts",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "Specifying contrasts",
    "text": "Specifying contrasts\nIn our dataset, we have a single variable in our design formula that has three sample classes (levels) so we can make three possible pairwise comparisons:\n\nControl vs. Mov10 overexpression\nControl vs. Mov10 knockdown\nMov10 knockdown vs. Mov10 overexpression\n\nWe are really only interested in #1 and #2 from above. When we initially created our dds object, we had provided ~ sampletype as our design formula, indicating that sampletype is our main factor of interest.\nTo indicate which two sample classes we are interested in comparing, we need to specify contrasts. The contrasts are used as input to the DESeq2 results() function to extract the desired results.\n\n\n\n\n\n\nNote\n\n\n\nIf we run the results() function without specifying contrast or name, it will return the comparison of the last level of the last variable in the design formula over the first level of this variable. If the order of levels are not specified, they are ordered alphabetically by DESeq2.\n\n\nContrasts can be specified in two different ways (with the first method more commonly used):\n\nContrasts can be supplied as a character vector with exactly three elements: the name of the factor (of interest) in the design formula and the name of the two factors levels to compare. The factor level given last is the base level for the comparison. The syntax is given below:\n\n\n## DO NOT RUN THIS CODE\n\n# Set up contrast\ncontrast &lt;- c(\"condition\", \"level_to_compare\", \"base_level\")\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\n\n\nContrasts can be given as a list of 2 character vectors: the names of the fold changes for the level of interest, and the names of the fold changes for the base level. These names should match identically to the elements of resultsNames(object). This method can be useful for combining interaction terms and main effects.\n\n\n## DO NOT RUN THIS CODE\n\n# See what names to use\nresultsNames(dds)\n\n# Set up contrast\ncontrast &lt;- list(resultsNames(dds)[1], resultsNames(dds)[2])\n\n# Pull out results for that contrast\nresults(dds, contrast = contrast)\n\nAlternatively, if you only had two factor levels, you could do nothing and not worry about specifying contrasts (i.e. results(dds)). In this case, DESeq2 will choose what your base factor level based on alphabetical order of the levels.\nTo start, we want to evaluate expression changes between the MOV10 overexpression samples and the control samples. As such we will use the first method for specifying contrasts and create a character vector:\n\n# Define contrasts for MOV10 overexpression\ncontrast_oe &lt;- c(\"sampletype\", \"MOV10_overexpression\", \"control\")\n\n\n\n\n\n\n\nDoes it matter what I choose to be my base level?\n\n\n\nYes, it does matter. Deciding what level is the base level will determine how to interpret the fold change that is reported. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in our factor level of interest relative to the base level. Thus, if leaving it up to DESeq2 to decide on the contrasts, be sure to check that the alphabetical order coincides with the fold change direction you are anticipating.",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#the-results-table",
    "href": "lessons/10_wald_test_results.html#the-results-table",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "The results table",
    "text": "The results table\nNow that we have our contrast created, we can use it as input to the results() function. Let’s take a quick look at the help manual for the function:\n\n?results\n\nYou will see we have the option to provide a wide array of arguments and tweak things from the defaults as needed. As we go through the lesson we will keep coming back to the help documentation to discuss some arguments that are good to know about.\n\n# Extract results for MOV10 overexpression vs control\nres_tableOE &lt;- results(dds, contrast=contrast_oe, alpha = 0.05)\n\n\n\n\n\n\n\nNote\n\n\n\nFor our analysis, in addition to the contrast argument we will also provide a value of 0.05 for the alpha argument. We will describe this in more detail when we talk about gene-level filtering.\n\n\nThe results table that is returned to us is a DESeqResults object, which is a simple subclass of DataFrame. In many ways it can be treated like a dataframe (i.e., when accessing/subsetting data); however, it is important to recognize that there are differences for downstream steps like visualization.\n\n# Check what type of object is returned\nclass(res_tableOE)\n\n[1] \"DESeqResults\"\nattr(,\"package\")\n[1] \"DESeq2\"\n\n\nNow let’s take a look at what information is stored in the results:\n\n# What is stored in results?\nres_tableOE %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                    baseMean log2FoldChange      lfcSE        stat       pvalue\nENSG00000000003 3525.8834779    -0.43824542 0.07746073 -5.65764661 1.534627e-08\nENSG00000000005   26.2489043     0.02920801 0.44112948  0.06621187 9.472091e-01\nENSG00000000419 1478.2512405     0.38363503 0.11376092  3.37229197 7.454538e-04\nENSG00000000457  518.4220238     0.22897058 0.10233134  2.23754120 2.525099e-02\nENSG00000000460 1159.7761365    -0.26913819 0.08149934 -3.30233587 9.588318e-04\nENSG00000000938    0.4021325    -1.79625184 4.02392684 -0.44639277 6.553136e-01\n                        padj\nENSG00000000003 4.250966e-07\nENSG00000000005 9.726866e-01\nENSG00000000419 4.673923e-03\nENSG00000000457 8.023483e-02\nENSG00000000460 5.760864e-03\nENSG00000000938           NA\n\n\nWe have six columns of information reported for each gene (row). We can use the mcols() function to extract information on what the values stored in each column represent:\n\n# Get information on each column in results\nmcols(res_tableOE, use.names=T)\n\n\nbaseMean: mean of normalized counts for all samples\nlog2FoldChange: log2 fold change\nlfcSE: standard error\nstat: Wald statistic\npvalue: Wald test p-value\npadj: BH adjusted p-values",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#p-values",
    "href": "lessons/10_wald_test_results.html#p-values",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "P-values",
    "text": "P-values\nThe p-value is a probability value used to determine whether there is evidence to reject the null hypothesis. A smaller p-value means that there is stronger evidence in favor of the alternative hypothesis. However, because we are performing a test for each individual gene we need to correct these p-values for multiple testing.\nThe padj column in the results table represents the p-value adjusted for multiple testing, and is the most important column of the results. Typically, a threshold such as padj &lt; 0.05 is a good starting point for identifying significant genes. The default method for multiple test correction in DESeq2 is an implementation of the Benjamini-Hochberg false discovery rate (FDR). There are other corrections methods available and can be changed by adding the pAdjustMethod argument to the results() function.\n\nGene-level filtering\nLet’s take a closer look at our results table. As we scroll through it, you will notice that for selected genes there are NA values in the pvalue and padj columns. What does this mean?\n\n\n\nThe missing values represent genes that have undergone filtering as part of the DESeq() function. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. DESeq2 does not physically remove any genes from the original counts matrix, and so all genes will be present in your results table. The genes omitted by DESeq2 meet one of the three filtering criteria outlined below:\n1. Genes with zero counts in all samples\nIf, within a row, all samples have zero counts, there is no expression information and therefore these genes are not tested.\n\n# Filter genes by zero expression\nres_tableOE[which(res_tableOE$baseMean == 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                baseMean log2FoldChange lfcSE stat pvalue padj\nENSG00000005381        0             NA    NA   NA     NA   NA\nENSG00000008196        0             NA    NA   NA     NA   NA\nENSG00000008197        0             NA    NA   NA     NA   NA\nENSG00000008438        0             NA    NA   NA     NA   NA\nENSG00000011083        0             NA    NA   NA     NA   NA\nENSG00000011600        0             NA    NA   NA     NA   NA\n\n\nThe baseMean column for these genes will be zero, and the log2 fold change estimates, p-value, and adjusted p-value will all be set to NA.\n2. Genes with an extreme count outlier\nThe DESeq() function calculates, for every gene and for every sample, a diagnostic test for outliers called Cook’s distance. Cook’s distance is a measure of how much a single sample is influencing the fitted coefficients for a gene, and a large value of Cook’s distance is intended to indicate an outlier count. Genes that contain a Cook’s distance above a threshold are flagged; however, at least 3 replicates are required for flagging, as it is difficult to judge which sample might be an outlier with only 2 replicates. We can turn off this filtering by using the cooksCutoff argument in the results() function.\n\n# Filter genes that have an extreme outlier\nres_tableOE[which(is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) &\n                    res_tableOE$baseMean &gt; 0), ] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                 baseMean log2FoldChange    lfcSE       stat pvalue padj\nENSG00000001626 123.83122     -0.3561765 3.438228 -0.1035930     NA   NA\nENSG00000008226  67.82651      5.8902223 1.973889  2.9840702     NA   NA\nENSG00000058866 116.38549      0.8519290 2.133619  0.3992882     NA   NA\nENSG00000060709 108.76629      4.5901999 1.716474  2.6742036     NA   NA\nENSG00000100346 121.65513      6.3764242 1.803765  3.5350630     NA   NA\nENSG00000100427  37.51051     -2.1283061 1.491536 -1.4269224     NA   NA\n\n\nIf a gene contains a sample with an extreme count outlier, then the p-value and adjusted p-value will be set to NA.\n3. Genes with a low mean normalized counts\nDESeq2 defines a low mean threshold, that is empirically determined from your data, in which the fraction of significant genes can be increased by reducing the number of genes that are considered for multiple testing. This is based on the notion that genes with very low counts are not likely to see significant differences typically due to high dispersion.\n\n\n\nImage courtesy of slideshare presentation from Joachim Jacob, 2014.\nAt a user-specified value (alpha = 0.05), DESeq2 evaluates the change in the number of significant genes as it filters out increasingly bigger portions of genes based on their mean counts, as shown in the figure above. The point at which the number of significant genes reaches a peak is the low mean threshold that is used to filter genes that undergo multiple testing. There is also an argument to turn off the filtering off by setting independentFiltering = F.\n\n# Filter genes below the low mean threshold\nres_tableOE[which(!is.na(res_tableOE$pvalue) & \n                    is.na(res_tableOE$padj) & \n                    res_tableOE$baseMean &gt; 0),] %&gt;% \n  data.frame() %&gt;% \n  head()\n\n                  baseMean log2FoldChange     lfcSE       stat     pvalue padj\nENSG00000000938  0.4021325     -1.7962518 4.0239268 -0.4463928 0.65531356   NA\nENSG00000000971 11.3963043     -0.6130577 0.7765898 -0.7894228 0.42986491   NA\nENSG00000002079  4.3709939     -0.4818745 1.5967741 -0.3017800 0.76281979   NA\nENSG00000002726  1.7387962     -0.3834632 1.9626071 -0.1953846 0.84509186   NA\nENSG00000002745  7.2065290      0.3893227 0.7689269  0.5063195 0.61263235   NA\nENSG00000002933 10.6169395     -1.4313952 0.6449326 -2.2194493 0.02645617   NA\n\n\nIf a gene is filtered by independent filtering, then only the adjusted p-value will be set to NA.\n\n\n\n\n\n\nImportant\n\n\n\nDESeq2 will perform the filtering outlined above by default; however, other DE tools such as EdgeR will not. Filtering is a necessary step, even if you are using limma-voom and/or edgeR’s quasi-likelihood methods. Be sure to follow pre-filtering steps when using other tools, as outlined in their user guides found on Bioconductor, as they generally perform much better.",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#fold-change",
    "href": "lessons/10_wald_test_results.html#fold-change",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "Fold change",
    "text": "Fold change\nAnother important column in the results table is the log2FoldChange. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also add a fold change threshold. Keep in mind when setting that value that we are working with log2 fold changes, so a cutoff of log2FoldChange &lt; 1 would translate to an actual fold change of 2.\n\n\n\n\n\n\nAn alternative approach to add the fold change threshold:\n\n\n\nThe results() function has an option to add a fold change threshold using the lfcThrehsold argument. This method is more statistically motivated, and is recommended when you want a more confident set of genes based on a certain fold-change. It actually performs a statistical test against the desired threshold, by performing a two-tailed test for log2 fold changes greater than the absolute value specified. The user can change the alternative hypothesis using altHypothesis and perform two one-tailed tests as well. This is a more conservative approach, so expect to retrieve a much smaller set of genes!\n\n\nThe fold changes reported in the results table are calculated by:\nlog2 (normalized_counts_group1 / normalized_counts_group2)\nThe problem is, these fold change estimates are not entirely accurate, as they do not account for the large dispersion we observe with low read counts. To address this, the log2 fold changes need to be adjusted.\n\nMore accurate LFC estimates\nTo generate more accurate log2 foldchange (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:\n\nLow counts\nHigh dispersion values\n\nLFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates.\n\n\n\nIllustration taken from the DESeq2 paper.\nIn the figure above, we have an example using two genes: green gene and purple gene. For each gene, the expression values are plotted for each sample in the two different mouse strains (C57BL/6J and DBA/2J). Both genes have the same mean values for the two sample groups, but the green gene has little variation within group while the purple gene has high levels of variation. For the green gene with low within group variation, the unshrunken LFC estimate (vertex of the green solid line) is very similar to the shrunken LFC estimate (vertex of the green dotted line). However, LFC estimates for the purple gene are quite different due to the high dispersion. So even though two genes can have similar normalized count values, they can have differing degrees of LFC shrinkage. Notice the LFC estimates are shrunken toward the prior (black solid line).\nShrinking the log2 fold changes will not change the total number of genes that are identified as significantly differentially expressed. The shrinkage of fold change is to help with downstream assessment of results. For example, if you wanted to subset your significant genes based on fold change for further evaluation, you may want to use shruken values. Additionally, for functional analysis tools such as GSEA that require fold change values as input, you would want to provide shrunken values.\nTo generate the shrunken log2 fold change estimates, you have to run an additional step on your results object (that we will create below) with the function lfcShrink().\n\n# Save the unshrunken results to compare\nres_tableOE_unshrunken &lt;- res_tableOE\n\n# Apply fold change shrinkage\nres_tableOE &lt;- lfcShrink(dds, coef=\"sampletype_MOV10_overexpression_vs_control\", type=\"apeglm\")\n\nDepending on the version of DESeq2 you are using, the default method for shrinkage estimation will differ. The defaults can be changed by adding the argument type in the lfcShrink() function as we have above. For most recent versions of DESeq2, type=\"normal\" is the default and was the only method in earlier versions. It has been shown that in most situations there are alternative methods that have less bias than the ’normal` method, and therefore we chose to use apeglm.\nNote that the stat column is no longer present in the results table. You can compare by inspecting the output of res_tableOE and res_tableOE_unshrunken in the R console. If you run type=\"apeglm\" or type=\"ashr\", you do not get a stat column because these don’t really make sense in the context of the posterior quantities that are returned.\n\n\n\n\n\n\nShrinkage\n\n\n\nFor more information on shrinkage, the DESeq2 vignette has an Extended section on shrinkage estimators that is quite useful.\n\n\n\n\n\n\n\n\ncontrast vs coef\n\n\n\nWhen using the alternative methods, rather than using the contrast argument, you will be required to specify coef. Using contrast forms an expanded model matrix, treating all factor levels equally, and averages over all distances between all pairs of factor levels to estimate the prior. Using coef means looking only at that column of the model matrix (so usually that would be one level against the reference level) and estimates the prior for that coefficient from the distribution of those MLE of coefficients. When using coef, the shrinkage depends on which level is chosen as reference.\n\n\n\n\n\n\n\n\nHow do I know what to value to provide to the coef argument?\n\n\n\nThe value you provide here needs to match identically to what is stored in the column header of the coefficients table. To see what values you have to work with you can use resultsNames(dds).",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/10_wald_test_results.html#ma-plot",
    "href": "lessons/10_wald_test_results.html#ma-plot",
    "title": "Exploring DESeq2 results from the Wald test",
    "section": "MA plot",
    "text": "MA plot\nA plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot.\nLet’s start with the unshrunken results:\n\n# MA plot using unshrunken fold changes\nplotMA(res_tableOE_unshrunken, ylim=c(-2,2))\n\n\n\n\n\n\n\n\nAnd now the shrunken results:\n\n# MA plot using shrunken fold changes\nplotMA(res_tableOE, ylim=c(-2,2))\n\n\n\n\n\n\n\n\nIn the first plot, you have the unshrunken fold change values, and you can see the abundance of scatter for the the lowly-expressed genes. That is, many of the low expressors exhibit very high fold changes. After shrinkage, we see the fold changes are much smaller estimates.\nIn addition to the comparison described above, this plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression. Generally, we would expect to see significant genes across the full range of expression levels.\n\n\n\n\n\n\nExcercise 1\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\nNow that we have results for the overexpression results, do the same for the Control vs. Knockdown samples.\n\nCreate a contrast vector called contrast_kd.\nUse contrast vector in the results() to extract a results table and store that to a variable called res_tableKD.\nShrink the LFC estimates using lfcShrink() and assign it back to res_tableKD.\n\n\n\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Exploring DESeq2 results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/07_design_formulas_Answers.html",
    "href": "lessons/07_design_formulas_Answers.html",
    "title": "Design formulas for differential expression analysis in DESeq2 - Answer key",
    "section": "",
    "text": "Exercise 1\nSuppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written?\ndesign = ~ sex + treatment + age\nBased on our Mov10 metadata dataframe, which factors could we include in our design formula?\ndesign = ~ sampletype\nWhat would you do if you wanted to include a factor in your design formula that is not in your metadata?\nAdd that factor into your metadata.\n\n\nExercise 2\nHow would the design formula be structured to perform the following analyses?\nTest for the effect of treatment.\ndesign = ~ treatment\nTest for the effect of genotype, while regressing out the variation due to treatment.\ndesign = ~ treatment + genotype\nTest for the effect of genotype on the treatment effects.\ndesign = ~ genotype + treatment + genotype:treatment"
  },
  {
    "objectID": "lessons/08_hypothesis_testing.html",
    "href": "lessons/08_hypothesis_testing.html",
    "title": "Hypothesis testing and multiple testing",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/08_hypothesis_testing.html#learning-objectives",
    "href": "lessons/08_hypothesis_testing.html#learning-objectives",
    "title": "Hypothesis testing and multiple testing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the process of model fitting\nCompare two methods for hypothesis testing (Wald test vs. LRT)\nRecognize the importance of multiple test correction\nIdentify different methods for multiple test correction",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/08_hypothesis_testing.html#generalized-linear-model",
    "href": "lessons/08_hypothesis_testing.html#generalized-linear-model",
    "title": "Hypothesis testing and multiple testing",
    "section": "Generalized Linear Model",
    "text": "Generalized Linear Model\nAs described earlier, the count data generated by RNA-seq exhibits overdispersion (variance &gt; mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a negative binomial distribution to model the RNA-seq counts using the equation below:\n\n\n\nThe two parameters required are the size factor and the dispersion estimate. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.\n\n\n\n\n\n\nNote\n\n\n\n“In statistics, the generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows for response variables that have error distribution models other than a normal distribution. The GLM generalizes linear regression by allowing the linear model to be related to the response variable via a link function and by allowing the magnitude of the variance of each measurement to be a function of its predicted value.” (Wikipedia).\n\n\nAfter the model is fit, coefficients are estimated for each sample group along with their standard error. The coefficents are the estimates for the log2 foldchanges, and will be used as input for hypothesis testing.",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/08_hypothesis_testing.html#hypothesis-testing",
    "href": "lessons/08_hypothesis_testing.html#hypothesis-testing",
    "title": "Hypothesis testing and multiple testing",
    "section": "Hypothesis testing",
    "text": "Hypothesis testing\nThe first step in hypothesis testing is to set up a null hypothesis for each gene. In our case, the null hypothesis is that there is no differential expression across the two sample groups (LFC == 0). Notice that we can do this without observing any data, because it is based on a thought experiment. Second, we use a statistical test to determine if, based on the observed data, the null hypothesis is true.\n\nWald test\nIn DESeq2, the Wald test is the default used for hypothesis testing when comparing two groups. The Wald test is a test usually performed on parameters that have been estimated by maximum likelihood. In our case we are testing each gene model coefficient (LFC), which was derived using parameters like dispersion that were estimated using maximum likelihood. If there are more than 2 sample classes within a variable (for example, if you had low, medium, and high treatment levels) then DESeq2 will generate two pairwise comparisons when low is set as the control (see here for more info): low vs. medium, and low vs. high.\nDESeq2 implements the Wald test by:\n\nTaking the LFC and dividing it by its standard error, resulting in a z-statistic\nThe z-statistic is compared to a standard normal distribution, and a p-value is computed reporting the probability that a z-statistic at least as extreme as the observed value would be selected at random\nIf the p-value is small, we reject the null hypothesis and state that there is evidence against the null (i.e., the gene is differentially expressed).\n\nThe model fit and Wald test were already run previously as part of the DESeq() function:\n\n## DO NOT RUN THIS CODE\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\n\n\nLikelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test (LRT) as an alternative hypothesis test for when we are comparing more than two sample classes. Rather than evaluating whether a gene’s expression is up- or down-regulated in one class compared to another, the LRT identifies genes that are changing in expression in any direction across the different sample classes.\nHow does this compare to the Wald test?\nThe Wald test (default) only estimates one model per gene and evaluates the null hypothesis that LFC == 0.\nFor the Likelihood Ratio Test is also performed on parameters that have been estimated by maximum likelihood. For this test two models are estimated per gene; the fit of one model is compared to the fit of the other model.\n\n\n\n\nm1 is the reduced model (i.e., the design formula with your main factor term removed)\nm2 is the full model (i.e., the full design formula you provided when creating your dds object)\n\n\n\n\n\n\n\nImportant\n\n\n\nThis type of test can be especially useful in analyzing time course experiments.\n\n\nHere, we are evaluating the null hypothesis that the full model fits just as well as the reduced model. If we reject the null hypothesis, this suggests that there is a significant amount of variation explained by the full model (and our main factor of interest), therefore the gene is differentially expressed across the different levels. DESeq2 implements the LRT by using an Analysis of Deviance (ANODEV) to compare the two model fits. It is shown that LR follows a chi-squared distribution, and this can be used to calculate and associated p-value.\nTo use the LRT, we use the DESeq() function but this time adding two arguments:\n\nspecifying that we want to use the LRT test\nthe ‘reduced’ model\n\n\n# The full model was specified previously with the `design = ~ sampletype`:\n# dds &lt;- DESeqDataSetFromTximport(txi, colData = meta, ~ sampletype)\n\n# Likelihood ratio test\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\n\nSince our ‘full’ model only has one factor (sampletype), the ‘reduced’ model (removing that factor) leaves us with nothing in our design formula. DESeq2 cannot fit a model with nothing in the design formula, and so in the scenario where you have no additional covariates the intercept is modeled using the syntax ~ 1.\n\n\n\n\n\n\nExercise 1\n\n\n\nYou are studying brain maturation and growth patterns in mouse cortex and have obtained RNA-seq data for a total of 24 mice. These samples were acquired at 2 developmental stages (3 dpf and 10 dpf) and with or without treatment using a growth inhibitor (Monoamine oxidase (MAO) inhibitors). For each developmental stage and treatment combination you have 6 replicates. You also have sex information for these mice (12 males and 12 females).\n\nWhat steps are necessary to take to decide what your model should be?\nWhat is an appropriate hypothesis test if you are testing for expression differences across the developmental stages?\nProvide the line of code used to create the dds object.\nProvide the line of code used to run DESeq2.\nWould you use a different hypothesis test if you had 3 developmental timepoints?",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/08_hypothesis_testing.html#multiple-test-correction",
    "href": "lessons/08_hypothesis_testing.html#multiple-test-correction",
    "title": "Hypothesis testing and multiple testing",
    "section": "Multiple test correction",
    "text": "Multiple test correction\nRegardless of whether we use the Wald test or the LRT, each gene that has been tested will be associated with a p-value. It is this result which we use to determine which genes are considered significantly differentially expressed. However, we cannot use the p-value directly.\n\nWhat does the p-value mean?\nA gene with a significance cut-off of p &lt; 0.05, means there is a 5% chance it is a false positive. For example, if we test 20,000 genes for differential expression, at p &lt; 0.05 we would expect to find 1,000 genes by chance. If we found 3,000 genes to be differentially expressed total, roughly one third of our genes are false positives! We would not want to sift through our “significant” genes to identify which ones are true positives.\nSince each p-value is the result of a single test (single gene), the more genes we test, the more we inflate the false positive rate. This is the multiple testing problem.\n\n\nCorrecting the p-value for multiple testing\nThere are a few common approaches for multiple test correction:\n\nBonferroni: The adjusted p-value is calculated by: p-value * m (m = total number of tests). This is a very conservative approach with a high probability of false negatives, so is generally not recommended.\nFDR/Benjamini-Hochberg: Benjamini and Hochberg (1995) defined the concept of False Discovery Rate (FDR) and created an algorithm to control the expected FDR below a specified level given a list of independent p-values. More info about BH.\nQ-value / Storey method: The minimum FDR that can be attained when calling that feature significant. For example, if gene X has a q-value of 0.013 it means that 1.3% of genes that show p-values at least as small as gene X are false positives.\n\nDESeq2 helps reduce the number of genes tested by removing those genes unlikely to be significantly DE prior to testing, such as those with low number of counts and outlier samples (gene-level QC). However, multiple test correction is also implemented to reduce the False Discovery Rate using an interpretation of the Benjamini-Hochberg procedure.\nSo what does FDR &lt; 0.05 mean?\nBy setting the FDR cutoff to &lt; 0.05, we’re saying that the proportion of false positives we expect amongst our differentially expressed genes is 5%. For example, if you call 500 genes as differentially expressed with an FDR cutoff of 0.05, you expect 25 of them to be false positives.\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2:",
      "Hypothesis testing and multiple testing"
    ]
  },
  {
    "objectID": "lessons/05_DGE_count_normalization.html",
    "href": "lessons/05_DGE_count_normalization.html",
    "title": "Count normalization with DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05_DGE_count_normalization.html#learning-objectives",
    "href": "lessons/05_DGE_count_normalization.html#learning-objectives",
    "title": "Count normalization with DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nList different “uninteresting factors” considered during normalization\nDescribe some common normalization methods and recommendations for its use\nCreate a DESeqDataSet object and discuss the structure of the object\nDemonstrate how to normalize counts using DESeq2",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05_DGE_count_normalization.html#normalization",
    "href": "lessons/05_DGE_count_normalization.html#normalization",
    "title": "Count normalization with DESeq2",
    "section": "Normalization",
    "text": "Normalization\nThe first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples.\n\nThe counts of mapped reads for each gene is the result of RNA expression (“interesting” part) in addition to many other factors (“uninteresting” part). Normalization is the process of adjusting raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples.\nThe main “uninteresting” factors often considered during normalization are:\n\nSequencing depth: Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have twice the expression in Sample A relative to Sample B. However, this is the consequence of Sample A having doubled sequencing depth.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the figure above, each pink and green rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron.\n\n\n\nGene length: Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example below, Gene X and Gene Y have similar levels of expression, but the number of reads mapped to Gene X would be many more than the number mapped to Gene Y because Gene X is longer.\n\nRNA composition: A few highly differentially expressed genes between samples, differences in the number of genes expressed between samples, or presence of contamination can skew some types of normalization methods. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses [1].\nIn the example below, imagine the sequencing depths are similar between Sample A and Sample B, and every gene except for gene DE presents similar expression level between samples. The counts in Sample B would be greatly skewed by the DE gene, which takes up most of the counts. Other genes for Sample B would therefore appear to be less expressed than those same genes in Sample A.\n\n\nWhile normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples.\n\nCommon normalization methods\nSeveral common normalization methods have been developed to account for these differences:\n\n\n\nNormalization method\nDescription\nAccounted factors\nRecommendations for use\n\n\n\n\nCPM (counts per million)\ncounts scaled by total number of reads\nsequencing depth\ngene count comparisons between replicates of the same sample group; NOT for within sample comparisons or DE analysis\n\n\nTPM (transcripts per kilobase million)\ncounts per length of transcript (kb) per million reads mapped\nsequencing depth and gene length\ngene count comparisons within a sample or between samples of the same sample group; NOT for DE analysis\n\n\nRPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped)\nsimilar to TPM\nsequencing depth and gene length\ngene count comparisons between genes within a sample; NOT for between sample comparisons or DE analysis\n\n\nDESeq2’s median of ratios [1]\ncounts divided by sample-specific size factors determined by median ratio of gene counts relative to geometric mean per gene\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\nEdgeR’s trimmed mean of M values (TMM) [2]\nuses a weighted trimmed mean of the log expression ratios between samples\nsequencing depth and RNA composition\ngene count comparisons between samples and for DE analysis; NOT for within sample comparisons\n\n\n\n\n\nRPKM/FPKM: not recommended for between sample comparisons\nWhile TPM and RPKM/FPKM normalization methods both account for sequencing depth and gene length, RPKM/FPKM are not recommended. The reason is that the normalized count values output by the RPKM/FPKM method are not comparable between samples.\nUsing RPKM/FPKM normalization, the total number of RPKM/FPKM normalized counts for each sample will be different. Therefore, you cannot compare the normalized counts for each gene equally between samples.\nRPKM-normalized counts table\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nXCR1\n5.5\n5.5\n\n\nWASHC1\n73.4\n21.8\n\n\n…\n…\n…\n\n\nTotal RPKM-normalized counts\n1,000,000\n1,500,000\n\n\n\nFor example, in the table above, sampleA has a greater proportion of counts associated with XCR1 (5.5/1,000,000) than sampleB (5.5/1,500,000), even though the RPKM count values are the same. Therefore, we cannot directly compare the counts for XCR1 (or any other gene) between sampleA and sampleB, because the total number of normalized counts are different between samples.\n\n\n\n\n\n\nNote\n\n\n\nThis video by StatQuest shows in more detail why TPM should be used in place of RPKM/FPKM if needing to normalize for sequencing depth and gene length.\n\n\n\n\nDESeq2-normalized counts: Median of ratios method\nSince tools for differential expression analysis are comparing the counts of the same gene between sample groups, gene length does not need to be accounted for by the tool. However, sequencing depth and RNA composition do need to be taken into account.\nTo normalize for sequencing depth and RNA composition, DESeq2 uses the median of ratios method. On the user-end there is only one step, but on the back-end there are multiple steps involved, as described below.\n\n\n\n\n\n\nNote\n\n\n\nThe steps below describe in detail some of the steps performed by DESeq2 when you run a single function to get DE genes. Basically, for a typical RNA-seq analysis, you would not run these steps individually.\n\n\nStep 1: creates a pseudo-reference sample (row-wise geometric mean)\nFor each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples.\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\n\n\n\n\nEF2A\n1489\n906\nsqrt(1489 * 906) = 1161.5\n\n\nABCD1\n22\n13\nsqrt(22 * 13) = 17.7\n\n\n…\n…\n…\n…\n\n\n\nStep 2: calculates ratio of each sample to the reference\nFor every gene in every sample, the ratios (sample/ref) are calculated (as shown below). Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample.\n\n\n\n\n\n\n\n\n\n\n\ngene\nsampleA\nsampleB\npseudo-reference sample\nratio of sampleA/ref\nratio of sampleB/ref\n\n\n\n\nEF2A\n1489\n906\n1161.5\n1489/1161.5 = 1.28\n906/1161.5 = 0.78\n\n\nABCD1\n22\n13\n16.9\n22/16.9 = 1.30\n13/16.9 = 0.77\n\n\nMEFV\n793\n410\n570.2\n793/570.2 = 1.39\n410/570.2 = 0.72\n\n\nBAG1\n76\n42\n56.5\n76/56.5 = 1.35\n42/56.5 = 0.74\n\n\nMOV10\n521\n1196\n883.7\n521/883.7 = 0.590\n1196/883.7 = 1.35\n\n\n…\n…\n…\n…\n\n\n\n\n\nStep 3: calculate the normalization factor for each sample (size factor)\nThe median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value:\nnormalization_factor_sampleA &lt;- median(c(1.28, 1.3, 1.39, 1.35, 0.59))\nnormalization_factor_sampleB &lt;- median(c(0.78, 0.77, 0.72, 0.74, 1.35))\nThe figure below illustrates the median value for the distribution of all gene ratios for a single sample (y-axis is the frequency).\n\nThe median of ratios method makes the assumption that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not affect the median ratio values). This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes.\n\n\n\n\n\n\nNote\n\n\n\nUsually these size factors are around 1. If you see large variations between samples, it is important to take note as it might indicate the presence of extreme outliers.\n\n\nStep 4: calculate the normalized count values using the normalization factor\nThis is performed by dividing each raw count value in a given sample by that sample’s normalization factor, generating normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for sampleA was 1.3 and the median ratio for sampleB was 0.77, you could calculate normalized counts as follows:\nRaw Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489\n906\n\n\nABCD1\n22\n13\n\n\n…\n…\n…\n\n\n\nNormalized Counts\n\n\n\ngene\nsampleA\nsampleB\n\n\n\n\nEF2A\n1489 / 1.3 = 1145.39\n906 / 0.77 = 1176.62\n\n\nABCD1\n22 / 1.3 = 16.92\n13 / 0.77 = 16.88\n\n\n…\n…\n…\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPlease note that normalized count values are not whole numbers.",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05_DGE_count_normalization.html#count-normalization-of-mov10-dataset-using-deseq2",
    "href": "lessons/05_DGE_count_normalization.html#count-normalization-of-mov10-dataset-using-deseq2",
    "title": "Count normalization with DESeq2",
    "section": "Count normalization of Mov10 dataset using DESeq2",
    "text": "Count normalization of Mov10 dataset using DESeq2\nNow that we know the theory of count normalization, we will normalize the counts for the Mov10 dataset using DESeq2. This requires a few steps:\n\nEnsure that the row names of the metadata dataframe are present and are in the same order as the column names of the counts dataframe.\nCreate a DESeqDataSet object\nGenerate the normalized counts\n\n\n1. Match the metadata and counts data\nWe should always make sure that we have sample names that match between the two files, and that the samples are in the same order. DESeq2 will output an error if this is not the case.\n\n# Check that sample names match in both files\nall(colnames(txi$counts) %in% rownames(meta))\n\n[1] TRUE\n\nall(colnames(txi$counts) == rownames(meta))\n\n[1] TRUE\n\n\nIf your data does not match, you could use the match() function to rearrange them.\n\n\n\n\n\n\nExercise 1\n\n\n\nSuppose we have sample names matching in the counts matrix and metadata file, but they are in different order. Write the line(s) of code to create a new matrix with columns re-ordered such that they are identical to the row names of the metadata.\n\n\n\n\n2. Create DESEq2 object\nBioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also results). These custom data structures are similar to lists in that they can contain multiple different data types/structures. But unlike lists, they have pre-specified data slots, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions.\nLet’s start by creating the DESeqDataSet object, and then we can talk a bit more about what is stored inside it. To create the object, we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have one column we are interested in, which is ~sampletype. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels.\nOur count matrix input is stored in the txi list object. So we need to specify that using the DESeqDataSetFromTximport() function, which will extract the counts component and round the values to the nearest whole number.\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\n\n\n\n\n\n\nNote\n\n\n\nSince we had created a data variable in the last lesson that contains the counts, we could have also used that as input. However, in that case we would want to use the DESeqDataSetFromMatrix() function.\n\n\n\n\n\nDESeq2 object structure\n\n\nYou can use DESeq-specific functions to access the different slots and retrieve information. For example, suppose we want to retrieve the original count matrix, we would use counts() function (Note: we nest it within the head() function so that we can see just the first few lines of the matrix. You could also use the View() function to view the result in the script editor rather than in the console):\n\nhead(counts(dds))\n\n                Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3\nENSG00000000003       4376       3645       2968       6178       3688\nENSG00000000005         27         29         23         37         13\nENSG00000000419       1478       1288        884       2369       1340\nENSG00000000457        508        405        357        934        571\nENSG00000000460       1394       1164        850       2172       1217\nENSG00000000938          1          1          0          2          0\n                Mov10_oe_1 Mov10_oe_2 Mov10_oe_3\nENSG00000000003       3343       3114       2079\nENSG00000000005         25         38         22\nENSG00000000419       1890       1766       1271\nENSG00000000457        646        591        354\nENSG00000000460       1183       1139        673\nENSG00000000938          0          0          0\n\n\nAs we go through the workflow, we will use relevant functions to check what information is stored inside our object.\n\n\n3. Generate the Mov10 normalized counts\nThe next step is to normalize the count data in order to make fair gene comparisons between samples.\n\nTo perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors. We will demonstrate this function in the example below, but in a typical RNA-seq analysis, this step is automatically performed by the DESeq() function, which we will discuss later.\n\n# Estimate size factors\ndds &lt;- estimateSizeFactors(dds)\n\nBy assigning the results back to the dds object, we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factors of each sample using:\n\n# Look at size factors\nsizeFactors(dds)\n\nIrrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 \n 1.1150371  0.9606366  0.7493552  1.5634128  0.9359082  1.2257749  1.1406863 \nMov10_oe_3 \n 0.6541689 \n\n\nNow, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE.\n\n# Get normalized counts matrix\nnormalized_counts &lt;- counts(dds, normalized=TRUE)\n\nWe can save this normalized data matrix to file for later use:\n\n# Save normalized counts matrix\nwrite.table(normalized_counts, file=\"./data/normalized_counts.txt\", sep=\"\\t\", quote=FALSE, col.names = NA)\n\n\n\n\n\n\n\nNote\n\n\n\nDESeq2 doesn’t actually use normalized counts; rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that perform differential expression analysis that use the negative binomial model.\n\n\n\nNext Lesson",
    "crumbs": [
      "Day 1 Self-learning:",
      "Count normalization with DESeq2"
    ]
  },
  {
    "objectID": "lessons/05_DGE_count_normalization_Answers.html",
    "href": "lessons/05_DGE_count_normalization_Answers.html",
    "title": "Count normalization with DESeq2 - Answer key",
    "section": "",
    "text": "Exercise 1\nSuppose we have sample names matching in the counts matrix and metadata file, but they are in different order. Write the line(s) of code to create a new matrix with columns re-ordered such that they are identical to the row names of the metadata.\nThere are multiple ways to do this. For example:\n\nidx &lt;- match(rownames(meta), colnames(data))\ndata_reordered &lt;- data[, idx]\n\nOR\n\ndata_reordered &lt;- data[, match(rownames(meta), colnames(data))]\n\nOR\n\ntxi$counts &lt;- txi$counts[, match(rownames(meta), colnames(txi$counts))]"
  },
  {
    "objectID": "lessons/03_DGE_setup_and_overview.html",
    "href": "lessons/03_DGE_setup_and_overview.html",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/03_DGE_setup_and_overview.html#learning-objectives",
    "href": "lessons/03_DGE_setup_and_overview.html#learning-objectives",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe the RNA-seq and differential gene expression analysis workflows\nExplain the experiment and its objectives\nCreate a project in R\nSet up for the analysis of RNA-seq data",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/03_DGE_setup_and_overview.html#review-of-the-dataset",
    "href": "lessons/03_DGE_setup_and_overview.html#review-of-the-dataset",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Review of the dataset",
    "text": "Review of the dataset\nFor this workshop, we will be using a publicly available RNA-seq dataset that is part of a larger study described in Kenny PJ et al., 2014.\nThe RNA-seq was performed on HEK293F cells that were transfected either with a MOV10 transgene, siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below.\nUsing these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition.\n\n\n\n\n\n\n\n\n\nWhat is the purpose of these datasets? What does Mov10 do?\n\n\n\nThe authors are investigating interactions between various genes involved in Fragile X syndrome, a disease in which there is aberrant production of the FMRP protein.\nFMRP, a protein that is “most commonly found in the brain, is essential for normal cognitive development and female reproductive function. Mutations of this gene can lead to fragile X syndrome, intellectual disability, premature ovarian failure, autism, Parkinson’s disease, developmental delays and other cognitive deficits.” - from Wikipedia\nMOV10 is a putative RNA helicase that is also associated with FMRP in the context of the microRNA pathway.\n\n\nThe hypothesis the paper is testing is that FMRP and MOV10 associate and regulate the translation of a subset of RNAs.\n\n\n\nOur questions:\n\nWhat patterns of expression can we identify with the loss or gain of MOV10?\nAre there any genes shared between the two conditions?",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/03_DGE_setup_and_overview.html#rna-seq-workflow",
    "href": "lessons/03_DGE_setup_and_overview.html#rna-seq-workflow",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "RNA-seq workflow",
    "text": "RNA-seq workflow\nFor this dataset, raw sequence reads were obtained from the Sequence Read Archive (SRA). These reads were then processed using the RNA-seq workflow as detailed in the pre-reading for this workshop. All steps were performed on the command line (Linux/Unix), including a thorough quality control assessment. If you are interested, we have the MultiQC html report for this dataset linked here for you to peruse.\nThe directories of output from the mapping/quantification step of the workflow (Salmon) is the data that we will be using. These transcript abundance estimates, often referred to as ‘pseudocounts’, will be the starting point for our differential gene expression analysis.",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/03_DGE_setup_and_overview.html#setting-up",
    "href": "lessons/03_DGE_setup_and_overview.html#setting-up",
    "title": "Set up and overview for gene-level differential expression analysis",
    "section": "Setting up",
    "text": "Setting up\nLet’s get started by opening up RStudio and setting up a new project for this analysis.\n\nGo to the File menu and select New Project.\nIn the New Project window, choose New Directory. Then, choose New Project. Name your new directory DEanalysis and then “Create the project as subdirectory of:” the Desktop (or location of your choice).\nThe new project should automatically open in RStudio.\n\n\n\n\nTo check whether or not you are in the correct working directory, use getwd(). The path Desktop/DEanalysis should be returned to you in the console. Within your working directory, use the New folder button in the bottom right panel to create two new directories: meta and results. Remember the key to a good analysis is keeping organized from the start! (NOTE: we will be downloading our data folder.)\nNow we need to grab the files that we will be working with for the analysis. There are two things we need to download.\n\nFirst we need the Salmon results for the full dataset. Right click on the links below, and choose the “Save link as …” option to download directly into your project directory:\n\n\nSalmon data for the Mov10 full dataset\n\nOnce you have the zip file downloaded you will want to decompress it. This will create a data directory with sub-directories that correspond to each of the samples in our dataset.\n\nNext, we need the annotation file that maps our transcript identifiers to gene identifiers. We have created this file for you using the R Bioconductor package AnnotationHub. For now, we will use it as is, but later in the workshop we will spend some time showing you how to create one for yourself. Right click on the links below, and choose the “Save link as …” option to download directly into the data folder in your project directory.\n\n\nAnnotation file\n\nFinally, go to the File menu and select New File, then select R Script. This should open up a script editor in the top left hand corner. This is where we will be typing and saving all commands required for this analysis. In the script editor, type in header lines:\n\n# HBC RNA-seq DGE workshop\n# Gene-level differential expression analysis using DESeq2\n\nNow save the file as de_script.R within your project directory. When finished, your project directory should now look similar to this:\n\n\nLoading libraries\nFor this analysis we will be using several R packages, some which have been installed from CRAN and others from Bioconductor. To use these packages (and the functions contained within them), we need to load the libraries. Add the following to your script and don’t forget to comment liberally!\n\n# Setup\n# Bioconductor and CRAN libraries used\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(DEGreport)\nlibrary(tximport)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n\n\nLoading data\nThe main output of Salmon is a quant.sf file, and we have one of these for each individual sample in our dataset. A screenshot of the file is displayed below:\n\nFor each transcript that was assayed in the reference, we have:\n\nThe transcript identifier\nThe transcript length (in bp)\nThe effective length (described in detail below)\nTPM (transcripts per million), which is computed using the effective length\nThe estimated read count (‘pseudocount’)\n\n\n\n\n\n\n\nWhat exactly is the effective length?\n\n\n\nThe effective length for a transcript is the essentially the number of possible start positions for a read or fragment within that transcript. The sequence composition of a transcript affects how many reads are sampled from it. While two transcripts might be of identical actual length, depending on the sequence composition we are more likely to generate fragments from one versus the other. The transcript that has a higher likelihood of being sampled will end up with the larger effective length. The effective length is transcript length that has been “corrected” to include factors due to sequence-specific and GC biases.\n\n\nWe will be using the R Bioconductor package tximport to prepare the quant.sf files for DESeq2. The first thing we need to do is create a variable that contains the paths to each of our quant.sf files. Then we will add names to our quant files, which will allow us to easily distinguish between samples in the final output matrix.\n\n# List all directories containing data  \nsamples &lt;- list.files(path = \"./data\", full.names = TRUE, pattern = \"salmon$\")\n\n# Obtain a vector of all filenames including the path\nfiles &lt;- file.path(samples, \"quant.sf\")\n\n# Since all quant files have the same name, it is useful to have names for each element\nnames(files) &lt;- str_replace(samples, \"./data/\", \"\") %&gt;% \n                str_replace(\".salmon\", \"\")\n\nOur Salmon index was generated with transcript sequences listed by Ensembl IDs, but tximport needs to know which genes these transcripts came from. We will use the annotation table that we downloaded to extract transcript to gene information.\n\n# Load the annotation table for GrCh38\ntx2gene &lt;- read.delim(\"./data/tx2gene_grch38_ens94.txt\")\n\n# Take a look at it \ntx2gene %&gt;% head()\n\n            tx_id         ensgene     symbol\n1 ENST00000387314 ENSG00000210049      MT-TF\n2 ENST00000389680 ENSG00000211459    MT-RNR1\n3 ENST00000387342 ENSG00000210077      MT-TV\n4 ENST00000387347 ENSG00000210082    MT-RNR2\n5 ENST00000612848 ENSG00000276345 AC004556.1\n6 ENST00000386347 ENSG00000209082     MT-TL1\n\n\ntx2gene is a three-column data frame linking transcript ID (column 1) to gene ID (column 2) to gene symbol (column 3). We will take the first two columns as input to tximport. The column names are not relevant, but the column order is (i.e., transcript ID must be first).\nNow we are ready to run tximport.\n\n?tximport # let's take a look at the arguments for the tximport function\n\nThe tximport() function imports transcript-level estimates from various external software (e.g., Salmon, Kallisto) and summarizes to the gene-level (default) or outputs transcript-level matrices. There are optional arguments to use the abundance estimates as they appear in the quant.sf files or to calculate alternative values.\nFor our analysis we need non-normalized or “raw” count estimates at the gene-level for performing DESeq2 analysis.\nSince the gene-level count matrix is a default (txOut=FALSE) there is only one additional argument for us to modify to specify how to obtain our “raw” count values. The options for countsFromAbundance are as follows:\n\nno (default): This will take the values in TPM (as our scaled values) and NumReads (as our “raw” counts) columns, and collapse it down to the gene-level.\nscaledTPM: This is taking the TPM scaled up to library size as our “raw” counts.\nlengthScaledTPM: This is used to generate the “raw” count table from the TPM (rather than summarizing the NumReads column). “Raw” count values are generated by using the TPM value x featureLength x library size. These represent quantities that are on the same scale as original counts, except no longer correlated with transcript length across samples.\n\n\n\n\n\n\n\nLet’s review how TPM values are calculated:\n\n\n\n\nDivide the read counts by the length of each gene in kilobases. This gives you reads per kilobase (RPK).\nCount up all the RPK values in a sample and divide this number by 1,000,000. This is your “per million” scaling factor.\nDivide the RPK values by the “per million” scaling factor. This gives you TPM.\n\n\n\n\n# Run tximport\ntxi &lt;- tximport(files, type = \"salmon\", tx2gene = tx2gene[,c(\"tx_id\", \"ensgene\")],\n                countsFromAbundance = \"lengthScaledTPM\")\n\n\n\n\n\n\n\nAn additional argument for tximport\n\n\n\nWhen performing your own analysis, you may find that the reference transcriptome file you obtain from Ensembl will have version numbers included on your identifiers (i.e., ENSG00000265439.2). This will cause a discrepancy with the tx2gene file, since the annotation databases don’t usually contain version numbers (i.e., ENSG00000265439). To get around this issue you can use the argument ignoreTxVersion = TRUE. The logical value indicates whether to split the tx id on the ‘.’ character to remove version information, for easier matching.\n\n\n\n\nViewing data\nThe txi object is a simple list containing matrices of the abundance, counts, and length. Another list element ‘countsFromAbundance’ carries through the character argument used in the tximport call. The length matrix contains the average transcript length for each gene, which can be used as an offset for gene-level analysis.\n\nattributes(txi)\n\n$names\n[1] \"abundance\"           \"counts\"              \"length\"             \n[4] \"countsFromAbundance\"\n\n\nWe will be using the txi object as is for input into DESeq2, but will save it until the next lesson. For now let’s take a look at the count matrix. You will notice that there are decimal values, so let’s round to the nearest whole number and convert it into a dataframe. We will save it to a variable called data that we can play with.\n\n# Look at the counts\ntxi$counts %&gt;% head()\n\n                 Irrel_kd_1  Irrel_kd_2 Irrel_kd_3  Mov10_kd_2 Mov10_kd_3\nENSG00000000003 4375.751722 3645.483112 2968.36018 6177.539799 3688.16902\nENSG00000000005   27.259410   29.304293   23.31638   36.534194   13.14787\nENSG00000000419 1478.158556 1287.569549  883.63968 2368.544452 1339.80470\nENSG00000000457  507.916351  404.538329  357.20364  934.274776  571.37608\nENSG00000000460 1393.739749 1164.378205  849.77430 2172.300020 1217.31401\nENSG00000000938    1.058214    1.054427    0.00000    1.780558    0.00000\n                Mov10_oe_1 Mov10_oe_2 Mov10_oe_3\nENSG00000000003 3343.09841 3114.21097 2079.30559\nENSG00000000005   25.25078   38.11501   22.47582\nENSG00000000419 1889.59603 1766.32555 1271.05675\nENSG00000000457  646.46620  591.44175  354.09067\nENSG00000000460 1183.43712 1138.51245  673.14907\nENSG00000000938    0.00000    0.00000    0.00000\n\n\n\n# Write the counts to an object\ndata &lt;- txi$counts %&gt;% \n  round() %&gt;% \n  data.frame()\n\n\n\n\n\n\n\nWhat if I don’t have Salmon pseudocounts as input?\n\n\n\nUntil recently, the standard approach for RNA-seq analysis had been to map our reads using a splice-aware aligner (e.g., STAR) and then use the resulting BAM files as input to counting tools like featureCounts and htseq-count to obtain our final expression matrix. The field has now moved towards using lightweight alignment tools like Salmon as standard practice. If you are still working with data generated using the older standard approach we have some materials linked here on using DESeq2 with a raw count matrix as your starting point.\n\n\n\n\nCreating metadata\nOf great importance is keeping track of the information about our data. At minimum, we need to at least have a file which maps our samples to the corresponding sample groups that we are investigating. We will use the column headers from the counts matrix as the row names of our metadata file and have a single column to identify each sample as “MOV10_overexpression”, “MOV10_knockdown”, or “control”.\n\n# Create a sample table / metadata\nsampletype &lt;- factor(c(rep(\"control\",              3),\n                       rep(\"MOV10_knockdown\",      2),\n                       rep(\"MOV10_overexpression\", 3)))\nmeta &lt;- data.frame(sampletype, row.names = colnames(txi$counts))\n\nNow we are all set to start our analysis!\n\nNext Lesson",
    "crumbs": [
      "Day 1:",
      "Set up and overview for gene-level differential expression analysis"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html",
    "href": "lessons/17_FA_functional_class_scoring.html",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "",
    "text": "Approximate time: 40 minutes\nLearning Objectives:",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html#functional-analysis-using-functional-class-scoring",
    "href": "lessons/17_FA_functional_class_scoring.html#functional-analysis-using-functional-class-scoring",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "Functional analysis using functional class scoring",
    "text": "Functional analysis using functional class scoring\nIn addition to over-representation analysis, there are other types of analyses that can be equally important or informative for obtaining some biological insight from your results. The hypothesis behind functional class scoring (FCS) methods is that although large changes in individual genes can have significant effects on pathways (and will be detected via ORA methods), weaker but coordinated changes in sets of functionally related genes (i.e., pathways) can also have significant effects. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. This type of analysis can be particularly helpful if the differential expression analysis only outputs a small list of significant DE genes.",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "href": "lessons/17_FA_functional_class_scoring.html#gene-set-enrichment-analysis-using-clusterprofiler-and-pathview",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "Gene set enrichment analysis using clusterProfiler and Pathview",
    "text": "Gene set enrichment analysis using clusterProfiler and Pathview\nOne commonly used tool that is classified under Functional class scoring (FCS) is Gene Set Enrichment Analysis (GSEA). Gene set enrichment analysis utilizes the gene-level statistics or log2 fold changes for all genes to look to see whether gene sets for particular biological pathways are enriched among the large positive or negative fold changes.\n\n\n\nGene sets are pre-defined groups of genes that are functionally related. Commonly used gene sets include those derived from KEGG pathways, Gene Ontology terms, MSigDB, Reactome, or gene groups that share some other functional annotations, etc. [1].\n\nPreparation for GSEA\nThe clusterProfiler package offers several functions to perform GSEA using different genes sets, including but not limited to GO, KEGG, and MSigDb. We will use the KEGG gene sets in our examples below. The KEGG gene sets are defined using the Entrez identifiers, thus to perform the analysis we will need to acquire the corresponding Entrez IDs for our genes. We will also need to remove any genes that do not have an Entrez ID (NA values) and any duplicates (due to gene ID conversion) that may exist:\n\n# Remove any NA values (reduces the data by quite a bit)\nres_entrez &lt;- dplyr::filter(res_ids, entrezid != \"NA\")\n\n# Remove any Entrez duplicates\nres_entrez &lt;- res_entrez[which(duplicated(res_entrez$entrezid) == F), ]\n\nGSEA will use the log2 fold changes obtained from the differential expression analysis for every gene to perform the analysis. We will obtain a vector of fold changes for input to clusterProfiler, in addition to the associated Entrez IDs:\n\n# Extract the foldchanges\nfoldchanges &lt;- res_entrez$log2FoldChange\n\n# Name each fold change with the corresponding Entrez ID\nnames(foldchanges) &lt;- res_entrez$entrezid\n\nNext we need to order the fold changes in decreasing order. To do this we’ll use the sort() function, which takes a vector as input. This is in contrast to Tidyverse’s arrange(), which requires a data frame.\n\n# Sort fold changes in decreasing order\nfoldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\n# Confirm that foldchanges is sorted correctly\nhead(foldchanges)\n\n    4343     3310     4046      429   254122    10083 \n6.987221 6.501850 6.006265 4.608039 3.639205 2.979537 \n\n\n\n\nTheory of GSEA\nNow we are ready to perform GSEA. The details regarding GSEA can be found in the PNAS paper by Subramanian et al. We will describe briefly the steps outlined in the paper below:\n\n\n\nImage credit: Subramanian et al. Proceedings of the National Academy of Sciences Oct 2005, 102 (43) 15545-15550; DOI: 10.1073/pnas.0506580102\nThis image describes the theory of GSEA, with the ‘gene set S’ showing the metric used (in our case, ranked log2 fold changes) to determine enrichment of genes in the gene set. The left-most image is representing this metric used for the GSEA analysis. The log2 fold changes for each gene in the ‘gene set S’ is shown as a line in the middle image. The large positive log2 fold changes are at the top of the gene set image, while the largest negative log2 fold changes are at the bottom of the gene set image. In the right-most image, the gene set is turned horizontally, underneath which is an image depicting the calculations involved in determining enrichment, as described below.\nStep 1: Calculation of enrichment score:\nAn enrichment score for a particular gene set is calculated by walking down the list of log2 fold changes and increasing the running-sum statistic every time a gene in the gene set is encountered and decreasing it when genes are not part of the gene set. The size of the increase/decrease is determined by magnitude of the log2 fold change. Larger (positive or negative) log2 fold changes will result in larger increases or decreases. The final enrichment score is where the running-sum statistic is the largest deviation from zero.\nStep 2: Estimation of significance:\nThe significance of the enrichment score is determined using permutation testing, which performs rearrangements of the data points to determine the likelihood of generating an enrichment score as large as the enrichment score calculated from the observed data. Essentially, for this step, the first permutation would reorder the log2 fold changes and randomly assign them to different genes, reorder the gene ranks based on these new log2 fold changes, and recalculate the enrichment score. The second permutation would reorder the log2 fold changes again and recalculate the enrichment score again, and this would continue for the total number of permutations run. Therefore, the number of permutations run will increase the confidence in the significance estimates.\nStep 3: Adjust for multiple test correction\nAfter all gene sets are tested, the enrichment scores are normalized for the size of the gene set, then the p-values are corrected for multiple testing.\nThe GSEA output will yield the core genes in the gene sets that most highly contribute to the enrichment score. The genes output are generally the genes at or before the running sum reaches its maximum value (i.e., the most influential genes driving the differences between conditions for that gene set).\n\n\nPerforming GSEA\nFirst, we will set the seed so that we all obtain the same result:\n\nset.seed(123456)\n\n\n\n\n\n\n\nNote\n\n\n\nThe permutations are performed using random reordering, so every time we run the function we will get slightly different results. If we would like to use the same permutations every time we run a function, then we use the set.seed(123456) function prior to running. The input to set.seed() can be any number, but if you would want the same results, then you would need to use the same number as the lesson.\n\n\nTo perform the GSEA using KEGG gene sets with clusterProfiler, we can use the gseKEGG() function. The organisms with available KEGG pathway information are listed here.\n\n# Run GSEA using gene sets from KEGG pathways\ngseaKEGG &lt;- gseKEGG(\n  geneList = foldchanges, # ordered named vector of fold changes (Entrez IDs are the associated names)\n  organism = \"hsa\", # supported organisms listed below\n  minGSSize = 20, # minimum gene set size (# genes in set) - change to test more sets or recover sets with fewer # genes\n  pvalueCutoff = 0.05, # padj cutoff value\n  verbose = FALSE)\n\n# Extract the GSEA results\ngseaKEGG_results &lt;- gseaKEGG@result\n\n\n# Write results to file\nwrite.csv(gseaKEGG_results, \"results/gseaOE_kegg.csv\", quote = FALSE)\n\nHow many pathways are enriched? NOTE: The results may look slightly different for you.\n\n# Look at GSEA results\nhead(gseaKEGG_results)\n\n               ID                                       Description setSize\nhsa00190 hsa00190                         Oxidative phosphorylation     124\nhsa05012 hsa05012                                 Parkinson disease     238\nhsa05014 hsa05014                     Amyotrophic lateral sclerosis     331\nhsa05016 hsa05016                                Huntington disease     276\nhsa04714 hsa04714                                     Thermogenesis     213\nhsa05208 hsa05208 Chemical carcinogenesis - reactive oxygen species     199\n         enrichmentScore       NES       pvalue     p.adjust       qvalue rank\nhsa00190      -0.5613308 -2.253628 7.184082e-09 7.399605e-07 6.049753e-07 4108\nhsa05012      -0.4697490 -2.057186 3.757128e-09 7.399605e-07 6.049753e-07 4020\nhsa05014      -0.4252949 -1.933580 6.041944e-09 7.399605e-07 6.049753e-07 3056\nhsa05016      -0.4258820 -1.895742 1.538568e-07 1.188544e-05 9.717271e-06 3590\nhsa04714      -0.4576529 -1.964456 2.141965e-07 1.323734e-05 1.082256e-05 3590\nhsa05208      -0.4570364 -1.942055 3.896519e-07 1.720035e-05 1.406262e-05 3827\n                           leading_edge\nhsa00190 tags=50%, list=27%, signal=37%\nhsa05012 tags=47%, list=27%, signal=35%\nhsa05014 tags=34%, list=20%, signal=28%\nhsa05016 tags=43%, list=24%, signal=34%\nhsa04714 tags=38%, list=24%, signal=29%\nhsa05208 tags=40%, list=25%, signal=30%\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               core_enrichment\nhsa00190                                                                                                                                                                                                                                                                                                             533/518/10312/126328/506/1349/10632/1329/90423/4716/513/4722/1352/1353/515/4723/27089/523/4715/514/9377/100532726/516/4713/9551/4706/4717/4696/54539/4718/4728/4725/4514/4726/537/4714/1340/4720/4702/9296/23545/6391/10063/4729/535/9550/4708/528/527/4538/4519/4539/9114/155066/4535/4540/4513/4541/4508/4509/4536/4537\nhsa05012                              5689/126328/25800/90550/805/51465/2770/506/5714/292/1349/118424/1329/4716/513/3800/4722/515/7327/4723/293/29985/27089/5687/10131/55334/4715/23516/3799/10376/27173/514/9377/100532726/5705/516/4713/836/6647/4706/7311/91252/4717/4696/5685/54539/4718/5704/5691/4728/10383/5692/5702/5694/4725/5693/7846/842/4514/11315/203068/7416/4726/5701/5715/4714/1340/5695/1616/4720/4702/7419/4128/64837/5708/84790/7326/5690/808/6391/3798/25828/10105/5700/5709/5707/120892/2771/5688/7345/4729/5717/7332/581/598/5566/11047/4708/9817/4538/4519/4539/5567/51807/4535/5602/4540/4513/4541/4508/4509/4536/4537\nhsa05014                    311/514/9377/11258/5603/9217/100532726/637/5705/516/4713/836/6647/4706/10121/1769/4717/2876/56893/10762/8480/23511/4696/5685/7186/54539/4928/79139/4718/55916/5704/5691/2521/81929/4728/9883/10383/5692/5702/9776/5694/4725/5693/10482/5534/7846/842/4514/203068/7416/71/5216/4726/5701/5608/5715/140775/4714/4218/1340/5695/4686/1616/79902/4720/4702/51164/56000/64837/7415/220988/2475/5708/84790/5690/55706/6391/3798/5700/9782/5709/5532/84516/22863/5707/116442/5688/572/4729/5717/581/598/4747/84134/10189/11047/4708/2733/2878/4538/60/10452/4519/4539/51807/4535/55567/4540/4513/4541/4508/4509/4536/4537\nhsa05016 506/5714/5431/292/1349/4899/1329/29982/5432/4716/513/3800/4722/25942/515/4723/293/27089/5687/1212/6507/26100/4715/3799/10376/514/9377/11258/163/100532726/5705/516/4713/836/6647/5609/4706/10121/1769/4717/2876/161/7019/4696/5685/1211/7186/54539/4718/5704/5691/4728/10383/5692/5702/9776/5694/4725/5693/7846/842/4514/203068/7416/4726/5701/5715/4714/1340/10488/5695/4720/4702/51164/7419/5436/64837/3065/2475/5708/84790/5690/1175/5438/5434/6391/3798/6874/10105/5700/5709/2776/84516/22863/5707/5688/4729/5439/5717/581/1387/5441/11047/4708/2878/5435/4538/4519/4539/51807/4535/5602/55567/4540/4513/4541/4508/4509/4536/4537\nhsa04714                                                                                                                                                                                                    4716/513/6604/4722/1352/1353/515/4723/7248/27089/4715/7249/514/9377/5603/100532726/516/4713/9551/4706/6605/137682/4717/8193/4696/51422/29078/54539/4718/84987/51287/10818/4728/3991/116228/4725/4514/6602/71/4726/51548/4714/1340/10488/5564/4720/4702/2475/4893/6599/64223/107/6391/10063/65260/6597/4729/284184/28958/5566/2885/4708/3265/57492/84335/6598/86/4538/60/113/4519/4539/5567/4535/4540/4513/4541/4508/4509/4536/4537\nhsa05208                                                                                                                                                                                                                               5605/292/1349/873/6416/1329/5595/3845/65010/5970/4716/513/4722/369/515/4723/293/119391/27089/4715/514/9377/5603/100532726/516/4713/1545/6647/5609/4706/4717/4696/1535/54539/4718/405/208/4728/52/4725/5291/4514/5770/7416/4726/4714/5170/1340/4720/4702/207/7419/5781/4893/6391/10105/572/4729/1728/5594/2885/4708/3265/1571/9817/9020/4538/4519/4539/2353/4535/5602/4540/4513/4541/4508/4509/4536/4537\n\n\n\nThe first few columns of the results table identify the pathway information\nThe following columns include the associated statistics\nThe last column will report which genes are part of the ‘core enrichment’. These are the genes associated with the pathway which contributed to the observed enrichment score (i.e., in the extremes of the ranking). The genes are listed by EntrezID.\n\n\n\n\n\n\n\nNote\n\n\n\nThe DOSE package has a handy function which allows us to easily convert the list of Entrez identifiers into gene symbols. This is possible if and only if there is an OrgDb available for your organism. The function takes the gseaKEGG object as input and returns the same object with the gene symbols in the ‘core enrichment’ column.\n\n# Example code\ngseaKEGG_geneSymbol &lt;- setReadable(gseaKEGG, OrgDb = org.Hs.eg.db, keyType = \"ENTREZID\")\n\n\n\nLet’s explore the GSEA plot of enrichment of one of the pathways in the ranked list:\n\n# Plot the GSEA plot for a single enriched pathway, `hsa03008`\ngseaplot(gseaKEGG, geneSetID = 'hsa03008')\n\n\n\n\n\n\n\n\nIn this plot, the lines in plot represent the genes in the gene set ‘hsa03008’, and where they occur among the log2 fold changes. The largest positive log2 fold changes are on the left-hand side of the plot, while the largest negative log2 fold changes are on the right. The top plot shows the magnitude of the log2 fold changes for each gene, while the bottom plot shows the running sum, with the enrichment score peaking at the red dotted line (which is among the negative log2 fold changes). This suggests the down-regulation of this pathway.\nUse the Pathview R package to integrate the KEGG pathway data from clusterProfiler into pathway images:\n\n# First unload dplyr to avoid conflicts\ndetach(\"package:dplyr\", unload=TRUE)\n\n# Output images for a single significant KEGG pathway\npathview(gene.data = foldchanges,\n         pathway.id = \"hsa03008\",\n         species = \"hsa\",\n         limit = list(gene = 2, # value gives the max/min limit for foldchanges\n                      cpd = 1))\n\n\n\n\n\n\n\nWarning\n\n\n\nIf the below error message occurs: Error in detach(\"package:dplyr\", unload = T) : invalid 'name' argument, that means the dplyr package is not currently loaded. Ignore the message and continue to run pathview command.\n\n\n\n\n\n\n\n\nNote\n\n\n\nPathview may not display in your R Plots window. Instead, you may see a message such as Info: Working in directory /Users/yourname/Desktop/DEanalysis and Info: Writing image file hsa03008.pathview.png. This indicates that the image has instead been saved to that directory. You can open the pathview file to view it.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nPrinting out Pathview images for all significant pathways can be easily performed as follows:\n\n# Output images for all significant KEGG pathways\n\n# Make a function to plot a single pathway\nget_kegg_plots &lt;- function(x) {\n  pathview(gene.data = foldchanges, \n           pathway.id = gseaKEGG_results$ID[x], \n           species = \"hsa\",\n           limit = list(gene = 2, cpd = 1))\n}\n\n# Run through that function for all pathways\npurrr::map(1:length(gseaKEGG_results$ID), \n           get_kegg_plots)\n\n\n\n\n\nIncorpororating other gene sets for GSEA\nThere are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, and use that as input.\nThe Molecular Signatures Database (also known as MSigDB) is a collection of annotated gene sets. It contains 8 major collections:\n\nH: hallmark gene sets\nC1: positional gene sets\nC2: curated gene sets\nC3: motif gene sets\nC4: computational gene sets\nC5: GO gene sets\nC6: oncogenic signatures\nC7: immunologic signatures\n\nUsers can download GMT files from Broad Institute and use the read.gmt() function to parse the files. Alternatively, there is an R package that already packed the MSigDB gene sets in tidy data format that can be used directly with clusterProfiler. The msigdbr package supports several species and some example code is provided below:\n\n# DO NOT RUN THIS CODE\n\n# Load library\nlibrary(msigdbr)\n\n# See what species are available\nmsigdbr_show_species()\n##  [1] \"Anolis carolinensis\"             \"Bos taurus\"                     \n##  [3] \"Caenorhabditis elegans\"          \"Canis lupus familiaris\"         \n##  [5] \"Danio rerio\"                     \"Drosophila melanogaster\"        \n##  [7] \"Equus caballus\"                  \"Felis catus\"                    \n##  [9] \"Gallus gallus\"                   \"Homo sapiens\"                   \n## [11] \"Macaca mulatta\"                  \"Monodelphis domestica\"          \n## [13] \"Mus musculus\"                    \"Ornithorhynchus anatinus\"       \n## [15] \"Pan troglodytes\"                 \"Rattus norvegicus\"              \n## [17] \"Saccharomyces cerevisiae\"        \"Schizosaccharomyces pombe 972h-\"\n## [19] \"Sus scrofa\"                      \"Xenopus tropicalis\"\n\n# Use a specific collection; example C6 oncogenic signatures\nm_t2g &lt;- msigdbr(species = \"Homo sapiens\", category = \"C6\") %&gt;% \n  dplyr::select(gs_name, entrez_gene)\n\n# Run GSEA\nmsig_GSEA &lt;- GSEA(foldchanges, TERM2GENE = m_t2g, verbose = FALSE)",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html#functional-analysis-pathway-topology-tools",
    "href": "lessons/17_FA_functional_class_scoring.html#functional-analysis-pathway-topology-tools",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "Functional analysis: Pathway topology tools",
    "text": "Functional analysis: Pathway topology tools\n\n\n\nThe last main type of functional analysis technique is pathway topology analysis. Pathway topology analysis often takes into account gene interaction information along with the fold changes and adjusted p-values from differential expression analysis to identify dysregulated pathways. Depending on the tool, pathway topology tools explore how genes interact with each other (e.g., activation, inhibition, phosphorylation, ubiquitination, etc.) to determine the pathway-level statistics. Pathway topology-based methods utilize the number and type of interactions between gene product (our DE genes) and other gene products to infer gene function or pathway association.\nFor instance, the SPIA (Signaling Pathway Impact Analysis) tool can be used to integrate the lists of differentially expressed genes, their fold changes, and pathway topology to identify affected pathways. We have step-by-step materials for using SPIA available.",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html#other-tools-for-functional-analysis",
    "href": "lessons/17_FA_functional_class_scoring.html#other-tools-for-functional-analysis",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "Other Tools for Functional Analysis",
    "text": "Other Tools for Functional Analysis\n\nCo-expression clustering\nCo-expression clustering is often used to identify genes of novel pathways or networks by grouping genes together based on similar trends in expression. These tools are useful in identifying genes in a pathway, when their participation in a pathway and/or the pathway itself is unknown. These tools cluster genes with similar expression patterns to create ‘modules’ of co-expressed genes that often reflect functionally similar groups of genes. These ‘modules’ can then be compared across conditions or in a time-course experiment to identify any biologically relevant pathway or network information.\nYou can visualize co-expression clustering using heatmaps, which should be viewed as suggestive only; serious classification of genes needs better methods.\nThe way the tools perform clustering is by taking the entire expression matrix and computing pair-wise co-expression values. A network is then generated from which we explore the topology to make inferences on gene co-regulation. The WGCNA package (in R) is one example of a more sophisticated method for co-expression clustering (please note however that it is no longer maintained).",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/17_FA_functional_class_scoring.html#resources-for-functional-analysis",
    "href": "lessons/17_FA_functional_class_scoring.html#resources-for-functional-analysis",
    "title": "Functional Analysis for RNA-seq: Functional class scoring",
    "section": "Resources for functional analysis",
    "text": "Resources for functional analysis\n\ng:Profiler - http://biit.cs.ut.ee/gprofiler/index.cgi\nDAVID - https://david.ncifcrf.gov\nclusterProfiler - http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html\nGeneMANIA - http://www.genemania.org/\nGenePattern - http://www.broadinstitute.org/cancer/software/genepattern/ (need to register)\nWebGestalt - http://www.webgestalt.org (need to register)\nAmiGO - http://amigo.geneontology.org/amigo\nReviGO (visualizing GO analysis, input is GO terms) - http://revigo.irb.hr/\nWGCNA - https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/ (no longer maintained)\nGSEA - http://software.broadinstitute.org/gsea/index.jsp\nSPIA - https://www.bioconductor.org/packages/release/bioc/html/SPIA.html\nGAGE/Pathview - http://www.bioconductor.org/packages/release/bioc/html/gage.html",
    "crumbs": [
      "Day 3 Self-learning",
      "Functional Analysis for RNA-seq: Functional class scoring"
    ]
  },
  {
    "objectID": "lessons/Aside_principal_component_analysis.html",
    "href": "lessons/Aside_principal_component_analysis.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nPrincipal Component Analysis (PCA)\nPrincipal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). Details regarding PCA are given below (based on materials from StatQuest, and if you would like a more thorough description, we encourage you to explore StatQuest’s video.\nIf you had two samples and wanted to plot the counts of one sample versus another, you could plot the counts of one sample on the x-axis and the other sample on the y-axis as shown below:\n\nYou could draw a line through the data in the direction representing the most variation, which is on the diagonal in this example. The maximum variation in the data is between the two endpoints of this line.\nWe also see the genes vary somewhat above and below the line. We could draw another line through the data representing the second most amount of variation in the data.\n\nThe genes near the ends of the line, which would include those genes with the highest variation between samples (high expression in one sample and low expression in the other), have the greatest influence on the direction of the line.\n\nFor example, a small change in the value of Gene C would greatly change the direction of the line, whereas a small change in Gene A or Gene D would have little affect.\n\nWe could just rotate the entire plot and view the lines representing the variation as left-to-right and up-and-down. We see most of the variation in the data is left-to-right; this is and the second most variation in the data is up-and-down. These axes that represent the variation are “Principal Components”, with PC1 representing the most variation in the data and PC2 representing the second most variation in the data.\nIf we had three samples, then we would have an extra direction in which we could have variation. Therefore, if we have N samples we would have N-directions of variation or principal components.\n\nWe could give quantitative scores to genes based on how much they influence PC1 and PC2. Genes with little influence would get scores near zero, while genes with more influence would receive larger scores. Genes on opposite ends of the lines have a large influence, so they would receive large scores, but with opposite signs.\n\nTo generate a score per sample, we combine the read counts for all genes. To calculate the scores, we do the following:\nSample1 PC1 score = (read count * influence) + ... for all genes\nUsing the counts in the table for each gene (assuming we had only 4 genes total) we could calculate PC1 and PC2 values for each sample as follows:\nSample1 PC1 score = (4 * -2) + (1 * -10) + (8 * 8) + (5 * 1) = 51\nSample1 PC2 score = (4 * 0.5) + (1 * 1) + (8 * -5) + (5 * 6) = -7\n\nSample2 PC1 score = (5 * -2) + (4 * -10) + (8 * 8) + (7 * 1) = 21\nSample2 PC2 score = (5 * 0.5) + (4 * 1) + (8 * -5) + (7 * 6) = 8.5\nThe scores would then be plotted to examine whether the samples exhibit similar variation across all genes:\n\nSince genes with the greatest variation between samples will have the greatest influence on the principal components, we hope our condition of interest explains this variation (e.g. high counts in one condition and low counts in the other). With PC1 representing the most variation in the data and PC2 representing the second most variation in the data, we can visualize how similar the variation of genes is between samples."
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html",
    "href": "lessons/13_DGE_LRT_results.html",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "",
    "text": "Approximate time: 60 minutes",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html#learning-objectives",
    "href": "lessons/13_DGE_LRT_results.html#learning-objectives",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nApply the Likelihood Ratio Test (LRT) for hypothesis testing\nCompare results generated from the LRT to results obtained using the Wald test\nIdentify shared expression profiles from the LRT significant gene list",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "href": "lessons/13_DGE_LRT_results.html#exploring-results-from-the-likelihood-ratio-test-lrt",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Exploring results from the Likelihood ratio test (LRT)",
    "text": "Exploring results from the Likelihood ratio test (LRT)\nDESeq2 also offers the Likelihood Ratio Test as an alternative when evaluating expression change across more than two levels. Genes that are identified as significant are those that are changing in expression in any direction across the different factor levels.\nGenerally, this test will result in a larger number of genes than the individual pairwise comparisons. While the LRT is a test of significance for differences of any level(s) of the factor, one should not expect it to be exactly equal to the union of sets of genes using Wald tests (although we do expect a high degree of overlap).",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html#the-results-table",
    "href": "lessons/13_DGE_LRT_results.html#the-results-table",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "The results() table",
    "text": "The results() table\nTo extract the results from our dds_lrt object we can use the same results() function we had used with the Wald test. There is no need for contrasts since we are not making a pairwise comparison.\n\n\n\n\n\n\nNote\n\n\n\nIn an earlier lesson on hypothesis testing, we had you create the object dds_lrt. If you are having trouble finding the object, please run the code:\n\ndds_lrt &lt;- DESeq(dds, test=\"LRT\", reduced = ~ 1)\n\n\n\n\n# Extract results for LRT\nres_LRT &lt;- results(dds_lrt)\n\nLet’s take a look at the results table:\n\n# View results for LRT\nres_LRT  \n\nlog2 fold change (MLE): sampletype MOV10 overexpression vs control \nLRT p-value: '~ sampletype' vs '~ 1' \nDataFrame with 57761 rows and 6 columns\n                  baseMean log2FoldChange     lfcSE      stat      pvalue\n                 &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;\nENSG00000000003  3525.8835      -0.438245 0.0774607  40.46117 1.63670e-09\nENSG00000000005    26.2489       0.029208 0.4411295   1.61898 4.45084e-01\nENSG00000000419  1478.2512       0.383635 0.1137609  11.34102 3.44611e-03\nENSG00000000457   518.4220       0.228971 0.1023313  14.63134 6.65035e-04\nENSG00000000460  1159.7761      -0.269138 0.0814993  25.03939 3.65398e-06\n...                    ...            ...       ...       ...         ...\nENSG00000285889    1.82171       -4.68144 3.9266061   2.35649 0.307818323\nENSG00000285950    7.58089       -1.01978 1.0715583   1.21446 0.544857226\nENSG00000285976 4676.24904        0.19364 0.0656673  14.87805 0.000587859\nENSG00000285978    2.25697        4.13612 2.0706212   4.68720 0.095981569\nENSG00000285980    0.00000             NA        NA        NA          NA\n                       padj\n                  &lt;numeric&gt;\nENSG00000000003 3.14071e-08\nENSG00000000005 5.88670e-01\nENSG00000000419 1.22924e-02\nENSG00000000457 3.04551e-03\nENSG00000000460 3.23425e-05\n...                     ...\nENSG00000285889          NA\nENSG00000285950          NA\nENSG00000285976  0.00273904\nENSG00000285978          NA\nENSG00000285980          NA\n\n\nThe results table output looks similar to the Wald test results, with identical columns to what we observed previously.\n\nWhy are fold changes reported for an LRT test?\nFor analyses using the likelihood ratio test, the p-values are determined solely by the difference in deviance between the full and reduced model formula. A single log2 fold change is printed in the results table for consistency with other results table outputs, but is not associated with the actual test.\nColumns relevant to the LRT test:\n\nbaseMean: mean of normalized counts for all samples\nstat: the difference in deviance between the reduced model and the full model\npvalue: the stat value is compared to a chi-squared distribution to generate a pvalue\npadj: BH adjusted p-values\n\nAdditional columns:\n\nlog2FoldChange: log2 fold change\nlfcSE: standard error\n\n\n\n\n\n\n\nNote\n\n\n\nPrinted at the top of the the results table are the two sample groups used to generate the log2 fold change values that we observe in the results table. This can be controlled using the name argument; the value provided to name must be an element of resultsNames(dds).",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html#identifying-significant-genes",
    "href": "lessons/13_DGE_LRT_results.html#identifying-significant-genes",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Identifying significant genes",
    "text": "Identifying significant genes\nWhen filtering significant genes from the LRT we threshold only the padj column. How many genes are significant at padj &lt; 0.05?\n\n# Create a tibble for LRT results\nres_LRT_tb &lt;- res_LRT %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\n# Subset to return genes with padj &lt; 0.05\nsigLRT_genes &lt;- res_LRT_tb %&gt;% \n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Get number of significant genes\nnrow(sigLRT_genes)\n\n[1] 7315\n\n# Compare to numbers we had from Wald test\nnrow(sigOE) # overexpression vs control\n\n[1] 4774\n\nnrow(sigKD) # knockdown vs control\n\n[1] 2827\n\n\nThe number of significant genes observed from the LRT is quite high. This list includes genes that can be changing in any direction across the three factor levels (control, KO, overexpression). To reduce the number of significant genes, we can increase the stringency of our FDR threshold (padj.cutoff).\n\n\n\n\n\n\nExercise 1\n\n\n\n\nCompare the resulting gene list from the LRT test to the gene lists from the Wald test comparisons.\n\nHow many of the sigLRT_genes overlap with the significant genes in sigOE?\nHow many of the sigLRT_genes overlap with the significant genes in sigKD?",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "href": "lessons/13_DGE_LRT_results.html#identifying-clusters-of-genes-with-shared-expression-profiles",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "Identifying clusters of genes with shared expression profiles",
    "text": "Identifying clusters of genes with shared expression profiles\nWe now have this list of ~7K significant genes that we know are changing in some way across the three different sample groups. What do we do next?\nA good next step is to identify groups of genes that share a pattern of expression change across the sample groups (levels). To do this we will be using a clustering tool called degPatterns from the ‘DEGreport’ package. The degPatterns tool uses a hierarchical clustering approach based on pair-wise correlations between genes, then cuts the hierarchical tree to generate groups of genes with similar expression profiles. The tool cuts the tree in a way to optimize the diversity of the clusters, such that the variability inter-cluster &gt; the variability intra-cluster.\nBefore we begin clustering, we will first subset our rlog transformed normalized counts to retain only the differentially expressed genes (padj &lt; 0.05). In our case, it may take some time to run the clustering on 7K genes, and so for class demonstration purposes we will subset to keep only the top 1000 genes sorted by p-adjusted value.\n\n\n\n\n\n\nWhere do I get rlog transformed counts?\n\n\n\nThis rlog transformation was applied in an earlier lesson when we performed QC analysis. If you do not see this in your environment, run the following code:\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind = TRUE)\nrld_mat &lt;- assay(rld)\n\n\n\n\n# Subset results for faster cluster finding (for classroom demo purposes)\nclustering_sig_genes &lt;- sigLRT_genes %&gt;%\n  arrange(padj) %&gt;%\n  head(n = 1000)\n\n# Obtain rlog values for those significant genes\ncluster_rlog &lt;- rld_mat[clustering_sig_genes$gene, ]\n\nThe rlog transformed counts for the significant genes are input to degPatterns along with a few additional arguments:\n\nmetadata: the metadata dataframe that corresponds to samples\ntime: character column name in metadata that will be used as variable that changes\ncol: character column name in metadata to separate samples\n\nOnce the clustering is finished running, you will get your command prompt back in the console and you should see a figure appear in your plot window. The genes have been clustered into four different groups. For each group of genes, we have a boxplot illustrating expression change across the different sample groups. A line graph is overlayed to illustrate the trend in expression change.\n\n# Use the `degPatterns` function from the 'DEGreport' package to show gene clusters across sample groups\nclusters &lt;- degPatterns(cluster_rlog, metadata = meta, time = \"sampletype\", col = NULL)\n\n\n\n\n\n\n\n\nSuppose we are interested in the genes which show a decreased expression in the knockdown samples and increase in the overexpression. According to the plot there are 275 genes that share this expression profile. To find out what these genes are, let’s explore the output. What type of data structure is the clusters output?\n\n# What type of data structure is the `clusters` output?\nclass(clusters)\n\n[1] \"list\"\n\n\nWe can see what objects are stored in the list by using names(clusters). There is a dataframe stored inside. This is the main result so let’s take a look at it. The first column contains the genes, and the second column contains the cluster number to which they belong.\n\n# Let's see what is stored in the `df` component\nhead(clusters$df)\n\n                          genes cluster\nENSG00000155363 ENSG00000155363       1\nENSG00000173110 ENSG00000173110       1\nENSG00000189060 ENSG00000189060       1\nENSG00000187621 ENSG00000187621       2\nENSG00000265972 ENSG00000265972       1\nENSG00000270882 ENSG00000270882       3\n\n\nSince we are interested in Group 1, we can filter the dataframe to keep only those genes:\n\n# Extract the Group 1 genes\ngroup1 &lt;- clusters$df %&gt;%\n  dplyr::filter(cluster == 1)\n\nAfter extracting a group of genes, we can use annotation packages to obtain additional information. We can also use these lists of genes as input to downstream functional analysis tools to obtain more biological insight and see whether the groups of genes share a specific function.\n\nMaterials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 3:",
      "DGE analysis using LRT in DESeq2"
    ]
  },
  {
    "objectID": "lessons/11_summarizing_results.html",
    "href": "lessons/11_summarizing_results.html",
    "title": "Summarizing results from the Wald test",
    "section": "",
    "text": "Approximate time: 20 minutes",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/11_summarizing_results.html#learning-objectives",
    "href": "lessons/11_summarizing_results.html#learning-objectives",
    "title": "Summarizing results from the Wald test",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nEvaluate the number of differentially expressed genes produced for each comparison\nConstruct R objects containing significant genes from each comparison",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/11_summarizing_results.html#summarizing-results",
    "href": "lessons/11_summarizing_results.html#summarizing-results",
    "title": "Summarizing results from the Wald test",
    "section": "Summarizing results",
    "text": "Summarizing results\nTo summarize the results table, a handy function in DESeq2 is summary(). Confusingly it has the same name as the function used to inspect data frames. This function, when called with a DESeq results table as input, will summarize the results using a default threshold of padj &lt; 0.1. However, since we had set the alpha argument to 0.05 when creating our results table, the summary() function should also use the threshold FDR &lt; 0.05. (Note that padj/FDR is used even though the output says p-value &lt; 0.05.) Let’s start with the OE vs control results:\n\n# Summarize results\nsummary(res_tableOE, alpha = 0.05)\n\n\nout of 38903 with nonzero total read count\nadjusted p-value &lt; 0.05\nLFC &gt; 0 (up)       : 2004, 5.2%\nLFC &lt; 0 (down)     : 2770, 7.1%\noutliers [1]       : 28, 0.072%\nlow counts [2]     : 20580, 53%\n(mean count &lt; 13)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n\nIn addition to the number of genes up- and down-regulated at the default threshold, the function also reports the number of genes that were tested (genes with non-zero total read count), and the number of genes not included in multiple test correction due to a low mean count.",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/11_summarizing_results.html#extracting-significant-differentially-expressed-genes",
    "href": "lessons/11_summarizing_results.html#extracting-significant-differentially-expressed-genes",
    "title": "Summarizing results from the Wald test",
    "section": "Extracting significant differentially expressed genes",
    "text": "Extracting significant differentially expressed genes\nLet’s first create variables that contain our threshold criteria. We will only be using the adjusted p-values in our criteria:\n\n# Set thresholds\npadj.cutoff &lt;- 0.05\n\nWe can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble:\n\n# Create a tibble of results\nres_tableOE_tb &lt;- res_tableOE %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\nNow we can subset that table to only keep the significant genes using our pre-defined thresholds:\n\n# Subset the tibble to keep only significant genes\nsigOE &lt;- res_tableOE_tb %&gt;%\n  dplyr::filter(padj &lt; padj.cutoff)\n\n# Take a quick look at this tibble\nsigOE\n\n# A tibble: 4,774 × 6\n   gene            baseMean log2FoldChange  lfcSE       pvalue        padj\n   &lt;chr&gt;              &lt;dbl&gt;          &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;\n 1 ENSG00000000003    3526.         -0.420 0.0781 0.0000000153 0.000000443\n 2 ENSG00000000419    1478.          0.341 0.115  0.000745     0.00487    \n 3 ENSG00000000460    1160.         -0.247 0.0808 0.000959     0.00599    \n 4 ENSG00000001084    2561.         -0.270 0.0936 0.00144      0.00842    \n 5 ENSG00000001167    2501.         -0.288 0.0650 0.00000330   0.0000496  \n 6 ENSG00000002016     921.         -0.273 0.116  0.00660      0.0291     \n 7 ENSG00000002330     715.         -0.403 0.132  0.000435     0.00309    \n 8 ENSG00000002549    1542.         -0.260 0.0876 0.00123      0.00736    \n 9 ENSG00000002834    2669.         -0.227 0.0538 0.0000125    0.000154   \n10 ENSG00000002919     886.         -0.389 0.0867 0.00000164   0.0000271  \n# ℹ 4,764 more rows\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nMOV10 Differential Expression Analysis: Control versus Knockdown\n\nUsing the same p-adjusted threshold as above (padj.cutoff &lt; 0.05), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.\nHow many genes are differentially expressed in the Knockdown compared to Control? How does this compare to the overexpression significant gene list (in terms of numbers)?\n\n\n\nNow that we have extracted the significant results, we are ready for visualization!\n\nSome materials and hands-on activities were adapted from RNA-seq workflow on the Bioconductor website",
    "crumbs": [
      "Day 2 Self-learning",
      "Summarizing results from the Wald test"
    ]
  },
  {
    "objectID": "lessons/Aside_AnnotationDbi_lesson.html",
    "href": "lessons/Aside_AnnotationDbi_lesson.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/Aside_AnnotationDbi_lesson.html#annotationdbi",
    "href": "lessons/Aside_AnnotationDbi_lesson.html#annotationdbi",
    "title": "",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\n\norg.Hs.eg.db\nThere are a plethora of organism-specific orgDb packages, such as org.Hs.eg.db for human and org.Mm.eg.db for mouse, and a list of organism databases can be found here. These databases are best for converting gene IDs or obtaining GO information for current genome builds, but not for older genome builds. These packages provide the current builds corresponding to the release date of the package, and update every 6 months. If a package is not available for your organism of interest, you can create your own using AnnotationHub.\n\n# Load libraries\nlibrary(org.Hs.eg.db)\nlibrary(AnnotationDbi)\n\n# Check object metadata\norg.Hs.eg.db\n\nOrgDb object:\n| DBSCHEMAVERSION: 2.1\n| Db type: OrgDb\n| Supporting package: AnnotationDbi\n| DBSCHEMA: HUMAN_DB\n| ORGANISM: Homo sapiens\n| SPECIES: Human\n| EGSOURCEDATE: 2024-Sep20\n| EGSOURCENAME: Entrez Gene\n| EGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA\n| CENTRALID: EG\n| TAXID: 9606\n| GOSOURCENAME: \n| GOSOURCEURL: \n| GOSOURCEDATE: \n| GOEGSOURCEDATE: 2024-Sep20\n| GOEGSOURCENAME: Entrez Gene\n| GOEGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA\n| KEGGSOURCENAME: KEGG GENOME\n| KEGGSOURCEURL: ftp://ftp.genome.jp/pub/kegg/genomes\n| KEGGSOURCEDATE: 2011-Mar15\n| GPSOURCENAME: UCSC Genome Bioinformatics (Homo sapiens)\n| GPSOURCEURL: ftp://hgdownload.cse.ucsc.edu/goldenPath/hg38/database\n| GPSOURCEDATE: 2024-Sep22\n| ENSOURCEDATE: 2024-May14\n| ENSOURCENAME: Ensembl\n| ENSOURCEURL: ftp://ftp.ensembl.org/pub/current_fasta\n| UPSOURCENAME: Uniprot\n| UPSOURCEURL: http://www.UniProt.org/\n| UPSOURCEDATE: Mon Sep 23 15:46:45 2024\n\n\nWe can see the metadata for the database by just typing the name of the database, including the species, last updates for the different source information, and the source urls. Note the KEGG data from this database was last updated in 2011, so may not be the best site for KEGG pathway information.\nWe can easily extract information from this database using AnnotationDbi with the methods: columns, keys, keytypes, and select. For example, we will use our org.Hs.eg.db database to acquire information, but know that the same methods work for the TxDb, Go.db, EnsDb, and BioMart annotations.\n\n# Return the Ensembl IDs for a set of genes\nannotations_orgDb &lt;- AnnotationDbi::select(\n  org.Hs.eg.db, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENENAME\"), # information to retrieve for given data\n  keytype = \"ENSEMBL\") # type of data given in 'keys' argument\n\nWe started from at about 57K genes in our results table, and the dimensions of our resulting annotation data frame also look quite similar. Let’s take a peek to see if we actually returned annotations for each individual Ensembl gene ID that went in to the query:\n\n# How many Ensembl IDs have NOT been linked to gene names (symbols)?\nlength(which(is.na(annotations_orgDb$SYMBOL)))\n\n[1] 22125\n\n\nLooks like about half of the input genes did not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The difference is due to the fact that each database implements different computational approaches for generating the gene builds. Let’s get rid of those NA entries:\n\n# Determine the indices for the non-NA genes\nnon_na_idx &lt;- which(is.na(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the genes with annotations using indices\nannotations_orgDb &lt;- annotations_orgDb[non_na_idx, ]\n\nYou may have also noted the warning returned: ‘select()’ returned 1:many mapping between keys and columns. This is always going to happen with converting between different gene IDs (i.e., one geneID can map to more than one identifier in another databse) . Unless we would like to keep multiple mappings for a single gene, then we probably want to de-duplicate our data before using it.\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_orgDb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_orgDb &lt;- annotations_orgDb[non_duplicates_idx, ]\n\n\n\nEnsDb.Hsapiens.v86\nTo generate the Ensembl annotations, the EnsDb database can also be easily queried using AnnotationDbi. You will need to decide the release of Ensembl you would like to query. We know that our data is for GRCh38, and the most current EnsDb release for GRCh38 in Bioconductor is release 86, so we can install this database. All Ensembl releases are listed here. NOTE: this is not the most current release of GRCh38 in the Ensembl database, but it’s as current as we can obtain through AnnotationDbi.\nSince we are using AnnotationDbi to query the database, we can use the same functions that we used previously:\n\n# Install the library\n# BiocManager::install(\"EnsDb.Hsapiens.v86\")\n\n# Load the library\nlibrary(EnsDb.Hsapiens.v86)\n\n# Check object metadata\nEnsDb.Hsapiens.v86\n\nEnsDb for Ensembl:\n|Backend: SQLite\n|Db type: EnsDb\n|Type of Gene ID: Ensembl Gene ID\n|Supporting package: ensembldb\n|Db created by: ensembldb package from Bioconductor\n|script_version: 0.3.0\n|Creation time: Thu May 18 16:32:27 2017\n|ensembl_version: 86\n|ensembl_host: localhost\n|Organism: homo_sapiens\n|taxonomy_id: 9606\n|genome_build: GRCh38\n|DBSCHEMAVERSION: 2.0\n| No. of genes: 63970.\n| No. of transcripts: 216741.\n|Protein data available.\n\n# Explore the fields that can be used as keys\nkeytypes(EnsDb.Hsapiens.v86)\n\n [1] \"ENTREZID\"            \"EXONID\"              \"GENEBIOTYPE\"        \n [4] \"GENEID\"              \"GENENAME\"            \"PROTDOMID\"          \n [7] \"PROTEINDOMAINID\"     \"PROTEINDOMAINSOURCE\" \"PROTEINID\"          \n[10] \"SEQNAME\"             \"SEQSTRAND\"           \"SYMBOL\"             \n[13] \"TXBIOTYPE\"           \"TXID\"                \"TXNAME\"             \n[16] \"UNIPROTID\"          \n\n\nNow we can return all gene IDs for our gene list:\n\n# Return the Ensembl IDs for a set of genes\nannotations_edb &lt;- AnnotationDbi::select(\n  EnsDb.Hsapiens.v86, # database\n  keys = res_tableOE_tb$gene, # data to use for retrieval\n  columns = c(\"SYMBOL\", \"ENTREZID\",\"GENEBIOTYPE\"), # information to retrieve for given data\n  keytype = \"GENEID\") # type of data given in 'keys' argument\n\nWe can check for NA entries, and find that there are none:\n\nlength(which(is.na(annotations_edb$SYMBOL)))\n\n[1] 0\n\n\nThen we can again deduplicate, to remove the gene symbols which appear more than once:\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_edb$SYMBOL) == FALSE)\n\n# Return only the non-duplicated genes using indices\nannotations_edb &lt;- annotations_edb[non_duplicates_idx, ]\n\n\n\n\n\n\n\nNote\n\n\n\nIn this case we used the same build but a slightly older release, and we found little discrepancy. If your analysis was conducted using an older genome build (e.g., hg19), but used a newer build for annotation, some genes may be found to be not annotated (NA). Some of the genes have changed names in between versions (due to updates and patches), so may not be present in the newer version of the database."
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html",
    "href": "lessons/01_RNAseq_processing_workflow.html",
    "title": "From raw sequence reads to count matrix",
    "section": "",
    "text": "Approximate time: 40 minutes",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#learning-objectives",
    "href": "lessons/01_RNAseq_processing_workflow.html#learning-objectives",
    "title": "From raw sequence reads to count matrix",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand the different steps of the RNA-seq workflow, from RNA extraction to assessing the expression levels of genes.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#rna-extraction-and-library-preparation",
    "href": "lessons/01_RNAseq_processing_workflow.html#rna-extraction-and-library-preparation",
    "title": "From raw sequence reads to count matrix",
    "section": "1. RNA extraction and library preparation",
    "text": "1. RNA extraction and library preparation\nBefore RNA can be sequenced, it must first be extracted and separated from its cellular environment and prepared into a cDNA library. There are a number of steps involved which are outlined in the figure below, and in parallel there are various quality checks implemented to make sure we have good quality RNA to move forward with. We briefly describe some of these steps below.\na. Enriching for RNA. Once the sample has been treated with DNAse to remove any contaminating DNA sequence, the sample undergoes either selection of the mRNA (polyA selection) or depletion of the rRNA.\nGenerally, ribosomal RNA represents the majority of the RNAs present in a cell, while messenger RNAs represent a small percentage of total RNA (~2% in humans). Therefore, if we want to study the protein-coding genes, we need to enrich for mRNA or deplete the rRNA. For differential gene expression analysis, it is best to enrich for Poly(A)+, unless you are aiming to obtain information about long non-coding RNAs, in which case ribosomal RNA depletion is recommended.\n\n\n\n\n\n\nRNA Quality check\n\n\n\nIt is essential to check for the integrity of the extracted RNA prior to starting the cDNA library prepation. Traditionally, RNA integrity was assessed via gel electrophoresis by visual inspection of the ribosomal RNA bands, but that method is time-consuming and imprecise. The Bioanalyzer system from Agilent will rapidly assess RNA integrity and calculate an RNA Integrity Number (RIN), which facilitates the interpretation and reproducibility of RNA quality. RIN, essentially, provides a means by which RNA quality from different samples can be compared to each other in a standardized manner.\n\n\nb. Fragmentation and size selection. The remaining RNA molecules are then fragmented. This is done either via chemical, enzymatic (e.g., RNAses), or physical processes (e.g., chemical/mechanical shearing). These fragments then undergo size selection to retain only those fragments within a size range that Illumina sequencing machines can handle best, i.e., between 150 to 300 bp.\n\n\n\n\n\n\nFragment size quality check\n\n\n\nAfter size selection/exclusion, the fragment size distribution should be assesed to ensure that it is unimodal and well-defined.\n\n\nc. Reverse transcribe RNA into double-stranded cDNA. Information about which strand a fragment originated from can be preserved by creating stranded libraries. The most commonly used method incorporates deoxy-UTP during the synthesis of the second cDNA strand (Levin JZ et al., 2010). Once double-stranded cDNA fragments are generated, sequence adapters are ligated to the ends. (Size selection can be performed here instead of at the RNA level.)\nd. PCR amplification. If the amount of starting material is low and/or to increase the number of cDNA molecules to an amount sufficient for sequencing, libraries are usually PCR amplified. Run as few amplification cycles as possible to avoid PCR artefacts.\n\n\n\nImage source: Zeng W and Mortazavi A, 2012",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#sequencing-illumina",
    "href": "lessons/01_RNAseq_processing_workflow.html#sequencing-illumina",
    "title": "From raw sequence reads to count matrix",
    "section": "2. Sequencing (Illumina)",
    "text": "2. Sequencing (Illumina)\nSequencing of the cDNA libraries will generate reads. Reads correspond to the nucleotide sequences of the ends of each of the cDNA fragements in the library. You will have the choice of sequencing either a single end of the cDNA fragments (single-end reads) or both ends of the fragments (paired-end reads).\n\n\n\n\nSE - Single end dataset =&gt; Only Read1\nPE - Paired-end dataset =&gt; Read1 + Read2\n\ncan be 2 separate FastQ files or just one with interleaved pairs\n\n\nGenerally single-end sequencing is sufficient unless it is expected that the reads will match multiple locations on the genome (e.g. organisms with many paralogous genes), assemblies are being performed, or for splice isoform differentiation. Be aware that paired-end reads are generally 2x more expensive.\n\nSequencing-by-synthesis\nIllumina sequencing technology uses a sequencing-by-synthesis approach. To explore sequencing by synthesis in more depth, please watch this linked video on Illumina’s YouTube channel.\nWe have privided a brief explanation of the steps below:\nCluster growth: The DNA fragments in the cDNA library are denatured and hybridized to the glass flowcell (adapter complementarity). Each fragment is then clonally amplified, forming a cluster of double-stranded DNA. This step is necessary to ensure that the sequencing signal will be strong enough to be detected/captured unambiguously for each base of each fragment.\n\nNumber of clusters ~= Number of reads\n\nSequencing: The sequencing of the fragment ends is based on fluorophore-labelled dNTPs with reversible terminator elements. In each sequencing cycle, a base is incorporated into every cluster and excited by a laser.\nImage acquisition: Each dNTP has a distinct excitatory signal emission that is captured by cameras.\nBase calling: The Base calling program will then generate the sequence of bases, i.e. reads, for each fragement/cluster by assessing the images captured during the many sequencing cycles. In addition to calling the base in every position, the base caller will also report the certainty with which it was able to make the call (quality information).\n\nNumber of sequencing cycles = Length of reads",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#quality-control-of-raw-sequencing-data-fastqc",
    "href": "lessons/01_RNAseq_processing_workflow.html#quality-control-of-raw-sequencing-data-fastqc",
    "title": "From raw sequence reads to count matrix",
    "section": "3. Quality control of raw sequencing data (FastQC)",
    "text": "3. Quality control of raw sequencing data (FastQC)\nThe raw reads obtained from the sequencer are stored as FASTQ files. The FASTQ file format is the de facto file format for sequence reads generated from next-generation sequencing technologies.\nEach FASTQ file is a text file that represents sequence readouts for a sample. Each read is represented by 4 lines as shown below:\n@HWI-ST330:304:H045HADXX:1:1101:1111:61397\nCACTTGTAAGGGCAGGCCCCCTTCACCCTCCCGCTCCTGGGGGANNNNNNNNNNANNNCGAGGCCCTGGGGTAGAGGGNNNNNNNNNNNNNNGATCTTGG\n+\n@?@DDDDDDHHH?GH:?FCBGGB@C?DBEGIIIIAEF;FCGGI#########################################################\n\n\n\n\n\n\n\nLine\nDescription\n\n\n\n\n1\nAlways begins with ‘@’ and then information about the read\n\n\n2\nThe actual DNA sequence\n\n\n3\nAlways begins with a ‘+’ and sometimes the same info as in line 1\n\n\n4\nHas a string of characters which represent the quality scores; must have same number of characters as line 2\n\n\n\nFastQC is a commonly used software that provides a simple way to do some quality control checks on raw sequence data.\nThe main functions include:\n\nProviding a quick overview to tell you in which areas there may be problems\nSummary graphs and tables to quickly assess your data\nExport of results to an HTML-based permanent report",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#quantify-expression",
    "href": "lessons/01_RNAseq_processing_workflow.html#quantify-expression",
    "title": "From raw sequence reads to count matrix",
    "section": "4. Quantify expression",
    "text": "4. Quantify expression\nOnce we have explored the quality of our raw reads, we can move on to quantifying expression at the transcript level. The goal of this step is to identify from which transcript each of the reads originated from and the total number of reads associated with each transcript.\nTools that have been found to be most accurate for this step in the analysis are referred to as lightweight alignment tools, which include:\n\nKallisto,\nSailfish and\nSalmon\n\nEach of the tools in the list above work slightly differently from one another. However, common to all of them is that they avoid base-to-base genomic alignment of the reads. Genomic alignment is a step performed by older splice-aware alignment tools such as STAR and HISAT2. In comparison to these tools, the lightweight alignment tools not only provide quantification estimates faster (typically more than 20 times faster), but also prove improvements in accuracy (Robert C and Watson M, 2015).\nWe will use the expression estimates, often referred to as ‘pseudocounts’, obtained from Salmon as the starting point for the differential gene expression analysis.",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#quality-control-of-aligned-sequence-reads-starqualimap",
    "href": "lessons/01_RNAseq_processing_workflow.html#quality-control-of-aligned-sequence-reads-starqualimap",
    "title": "From raw sequence reads to count matrix",
    "section": "5. Quality control of aligned sequence reads (STAR/Qualimap)",
    "text": "5. Quality control of aligned sequence reads (STAR/Qualimap)\nAs mentioned above, the differential gene expression analysis will use transcript/gene pseudocounts generated by Salmon. However, to perform some basic quality checks on the sequencing data, it is important to align the reads to the whole genome. Either STAR or HiSAT2 are able to perform this step and generate a BAM file that can be used for QC.\nA tool called Qualimap explores the features of aligned reads in the context of the genomic region they map to, hence providing an overall view of the data quality (as an HTML file). Various quality metrics assessed by Qualimap include:\n\nDNA or rRNA contamination\n5’-3’ biases\nCoverage biases",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/01_RNAseq_processing_workflow.html#quality-control-aggregating-results-with-multiqc",
    "href": "lessons/01_RNAseq_processing_workflow.html#quality-control-aggregating-results-with-multiqc",
    "title": "From raw sequence reads to count matrix",
    "section": "6. Quality control: aggregating results with MultiQC",
    "text": "6. Quality control: aggregating results with MultiQC\nThroughout the workflow we have performed various steps of quality checks on our data. You will need to do this for every sample in your dataset, making sure these metrics are consistent across the samples for a given experiment. Outlier samples should be flagged for further investigation and potential removal.\nManually tracking these metrics and browsing through multiple HTML reports (FastQC, Qualimap) and log files (Salmon, STAR) for each samples is tedious and prone to errors. MultiQC is a tool that aggregates results from several tools and generates a single HTML report with plots to visualize and compare various QC metrics between the samples. Assessment of the QC metrics may result in the removal of samples before proceeding to the next step, if necessary.\n\nOnce the QC has been performed on all the samples, we are ready to get started with Differential Gene Expression analysis with DESeq2!",
    "crumbs": [
      "Pre-reading:",
      "From raw sequence reads to count matrix"
    ]
  },
  {
    "objectID": "lessons/13_DGE_LRT_results_Answers.html",
    "href": "lessons/13_DGE_LRT_results_Answers.html",
    "title": "DGE analysis using LRT in DESeq2",
    "section": "",
    "text": "Exercise 1\nCompare the resulting gene list from the LRT test to the gene lists from the Wald test comparisons.\nHow many of the sigLRT_genes overlap with the significant genes in sigOE?\n\n# find overlaps between sigLRT_genes and sigOE\noverlap_LRT_OE &lt;- sigLRT_genes %&gt;% subset(gene %in% sigOE$gene)\nnrow(overlap_LRT_OE)\n\n[1] 4510\n\n\nHow many of the sigLRT_genes overlap with the significant genes in sigKD?\n\n# find overlaps between sigLRT_genes and sigKD\noverlap_LRT_KD &lt;- sigLRT_genes %&gt;% subset(gene %in% sigKD$gene)\nnrow(overlap_LRT_KD)\n\n[1] 2741"
  },
  {
    "objectID": "lessons/15_genomic_annotation.html",
    "href": "lessons/15_genomic_annotation.html",
    "title": "Genomic annotations",
    "section": "",
    "text": "Approximate time: 30 minutes",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#learning-objectives",
    "href": "lessons/15_genomic_annotation.html#learning-objectives",
    "title": "Genomic annotations",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDiscuss the available genomic annotation databases and the different types if information stored\nCompare and contrast the tools available for accessing genomic annotation databases\nApply various R packages for retrieval of genomic annotations",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#databases",
    "href": "lessons/15_genomic_annotation.html#databases",
    "title": "Genomic annotations",
    "section": "Databases",
    "text": "Databases\nWe retrieve information on the processes, pathways, etc. (for which a gene is involved in) from the necessary database where the information is stored. The database you choose will be dependent on what type of information you are trying to obtain. Examples of databases that are often queried include:\nGeneral databases\nOffer comprehensive information on genome features, feature coordinates, homology, variant information, phenotypes, protein domain/family information, associated biological processes/pathways, associated microRNAs, etc.:\n\nEnsembl (use Ensembl gene IDs)\nNCBI (use Entrez gene IDs)\nUCSC\nEMBL-EBI\n\nAnnotation-specific databases\nProvide annotations related to a specific topic:\n\nGene Ontology (GO): database of gene ontology biological processes, cellular components and molecular functions - based on Ensembl or Entrez gene IDs or official gene symbols\nKEGG: database of biological pathways - based on Entrez gene IDs\nMSigDB: database of gene sets\nReactome: database of biological pathways\nHuman Phenotype Ontology: database of genes associated with human disease\nCORUM: database of protein complexes for human, mouse, rat\n…\n\nThis is by no means an exhaustive list, there are many other databases available that are not listed here.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#genome-builds",
    "href": "lessons/15_genomic_annotation.html#genome-builds",
    "title": "Genomic annotations",
    "section": "Genome builds",
    "text": "Genome builds\nBefore you begin your search through any of these databases, you should know which build of the genome was used to generate your gene list and make sure you use the same build for the annotations during functional analysis. When a new genome build is acquired, the names and/or coordinate location of genomic features (gene, transcript, exon, etc.) may change. Therefore, the annotations regarding genome features (gene, transcript, exon, etc.) is genome build-specific and we need to make sure that our annotations are obtained from the appropriate resource.\nFor example, if we used the GRCh38 build of the human genome to quantify gene expression used for differential expression analysis, then we should use the same GRCh38 build of the genome to convert between gene IDs and to identify annotations for each of the genes.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#tools-for-accessing-databases",
    "href": "lessons/15_genomic_annotation.html#tools-for-accessing-databases",
    "title": "Genomic annotations",
    "section": "Tools for accessing databases",
    "text": "Tools for accessing databases\nWithin R, there are many popular packages used for gene/transcript-level annotation. These packages provide tools that take the list of genes you provide and retrieve information for each gene using one or more of the databases listed above.\n\nAnnotation tools: for accessing/querying annotations from a specific databases\n\n\n\nTool\nDescription\nPros\nCons\n\n\n\n\norg.Xx.eg.db\nQuery gene feature information for the organism of interest\ngene ID conversion, biotype and coordinate information\nonly latest genome build available\n\n\nEnsDb.Xx.vxx\nTranscript and gene-level information directly fetched from Ensembl API (similar to TxDb, but with filtering ability and versioned by Ensembl release)\neasy functions to extract features, direct filtering\nNot the most up-to-date annotations, more difficult to use than some packages\n\n\nTxDb.Xx.UCSC.hgxx.knownGene\nUCSC database for transcript and gene-level information or can create own TxDb from an SQLite database file using the GenomicFeatures package\nfeature information, easy functions to extract features\nonly available current and recent genome builds - can create your own, less up-to-date with annotations than Ensembl\n\n\nannotables\nGene-level feature information immediately available for the human and model organisms\nsuper quick and easy gene ID conversion, biotype and coordinate information\nstatic resource, not updated regularly\n\n\nbiomaRt\nAn R package version of the Ensembl BioMart online tool\nall Ensembl database information available, all organisms on Ensembl, wealth of information\n\n\n\n\n\n\nInterface tools: for accessing/querying annotations from multiple different annotation sources\n\nAnnotationDbi: queries the OrgDb, TxDb, Go.db, EnsDb, and BioMart annotations.\n\nAnnotationHub: queries large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc.\n\n\n\n\n\n\n\nNote\n\n\n\nThese are both packages that can be used to create the tx2gene files we had you download at the beginning of this workshop.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#annotationdbi",
    "href": "lessons/15_genomic_annotation.html#annotationdbi",
    "title": "Genomic annotations",
    "section": "AnnotationDbi",
    "text": "AnnotationDbi\nAnnotationDbi is an R package that provides an interface for connecting and querying various annotation databases using SQLite data storage. The AnnotationDbi packages can query the OrgDb, TxDb, EnsDb, Go.db, and BioMart annotations. There is helpful documentation available to reference when extracting data from any of these databases.\nWhile AnnotationDbi is a popular tool, we will not be walking through code to use this package. However, if you are interested in more detail, we have materials linked here with examples using our current dataset.",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/15_genomic_annotation.html#annotationhub",
    "href": "lessons/15_genomic_annotation.html#annotationhub",
    "title": "Genomic annotations",
    "section": "AnnotationHub",
    "text": "AnnotationHub\nAnnotationHub is a wonderful resource for accessing genomic data or querying large collection of whole genome resources, including ENSEMBL, UCSC, ENCODE, Broad Institute, KEGG, NIH Pathway Interaction Database, etc. All of this information is stored and easily accessible by directly connecting to the database.\nTo get started with AnnotationHub, we first load the library and connect to the database:\n\n# Load libraries\nlibrary(AnnotationHub)\nlibrary(ensembldb)\n\n# Connect to AnnotationHub\nah &lt;- AnnotationHub()\n\n\n\n\n\n\n\nWhat is a cache?\n\n\n\nA cache is used in R to store data or a copy of the data so that future requests can be served faster without having to re-run a lengthy computation.\nThe AnnotationHub() command creates a client that manages a local cache of the database, helping with quick and reproducible access. When encountering question AnnotationHub does not exist, create directory?, you can answer either yes (create a permanent location to store cache) or no (create a temporary location to store cache). hubCache(ah) gets the file system location of the local AnnotationHub cache. hubUrl(ah) gets the URL for the online hub.\n\n\nTo see the types of information stored inside our database, we can just type the name of the object. Using the output, you can get an idea of the information that you can query within the AnnotationHub object:\n\n# Explore the AnnotationHub object\nah\n\nAnnotationHub with 72100 records\n# snapshotDate(): 2024-10-28\n# $dataprovider: Ensembl, BroadInstitute, UCSC, ftp://ftp.ncbi.nlm.nih.gov/g...\n# $species: Homo sapiens, Mus musculus, Drosophila melanogaster, Rattus norv...\n# $rdataclass: GRanges, TwoBitFile, BigWigFile, EnsDb, Rle, OrgDb, SQLiteFil...\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH5012\"]]' \n\n             title                                             \n  AH5012   | Chromosome Band                                   \n  AH5013   | STS Markers                                       \n  AH5014   | FISH Clones                                       \n  AH5015   | Recomb Rate                                       \n  AH5016   | ENCODE Pilot                                      \n  ...        ...                                               \n  AH119506 | Ensembl 113 EnsDb for Zonotrichia albicollis      \n  AH119507 | Ensembl 113 EnsDb for Zalophus californianus      \n  AH119508 | Ensembl 113 EnsDb for Zosterops lateralis melanops\n  AH119518 | MassBank CompDb for release 2024.06               \n  AH119519 | MassBank CompDb for release 2024.11               \n\n\nNotice the note on retrieving records with object[[ID]] - this will be how we can extract a single record from the AnnotationHub object.\nIf you would like to see more information about any of the classes of data, you can extract that information as well. For example, if you wanted to determine all species information available, you could explore that within the AnnotationHub object:\n\n# Explore all species information available\nunique(ah$species) %&gt;% head()\n\n[1] \"Homo sapiens\"         \"Vicugna pacos\"        \"Dasypus novemcinctus\"\n[4] \"Otolemur garnettii\"   \"Papio hamadryas\"      \"Papio anubis\"        \n\n\nIn addition to species information, there is also additional information about the type of Data Objects and the Data Providers:\n\n# Explore the types of Data Objects available\nunique(ah$rdataclass) %&gt;% head()\n\n[1] \"GRanges\"          \"data.frame\"       \"Inparanoid8Db\"    \"TwoBitFile\"      \n[5] \"ChainFile\"        \"SQLiteConnection\"\n\n# Explore the Data Providers\nunique(ah$dataprovider) %&gt;% head()\n\n[1] \"UCSC\"        \"Ensembl\"     \"RefNet\"      \"Inparanoid8\" \"NHLBI\"      \n[6] \"ChEA\"       \n\n\nNow that we know the types of information available from AnnotationHub, we can query it for the information we want using the query() function. Let’s say we would like to return the Ensembl EnsDb information for Human. To return the records available, we need to use the terms as they are output from the ah object to extract the desired data.\n\n# Query AnnotationHub for Human references\nhuman_ens &lt;- query(ah, c(\"Homo sapiens\", \"EnsDb\"))\n\n# See what annotations are available\nhuman_ens\n\nAnnotationHub with 28 records\n# snapshotDate(): 2024-10-28\n# $dataprovider: Ensembl\n# $species: Homo sapiens\n# $rdataclass: EnsDb\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH53211\"]]' \n\n             title                             \n  AH53211  | Ensembl 87 EnsDb for Homo Sapiens \n  AH53715  | Ensembl 88 EnsDb for Homo Sapiens \n  AH56681  | Ensembl 89 EnsDb for Homo Sapiens \n  AH57757  | Ensembl 90 EnsDb for Homo Sapiens \n  AH60773  | Ensembl 91 EnsDb for Homo Sapiens \n  ...        ...                               \n  AH109606 | Ensembl 109 EnsDb for Homo sapiens\n  AH113665 | Ensembl 110 EnsDb for Homo sapiens\n  AH116291 | Ensembl 111 EnsDb for Homo sapiens\n  AH116860 | Ensembl 112 EnsDb for Homo sapiens\n  AH119325 | Ensembl 113 EnsDb for Homo sapiens\n\n\nThe query retrieves all hits for the EnsDb objects, and you will see that they are listed by the release number. The most current release for GRCh38 is Ensembl 113 and AnnotationHub offers that as an option to use. However, if you look at options for older releases, for Homo sapiens it only go back as far as Ensembl 87. This is fine if you are using GRCh38; however, if you were using an older genome build like hg19/GRCh37, you would need to load the EnsDb package if available for that release or you might need to build your own with ensembldb.\nIn our case, we are looking for the latest Ensembl release so that the annotations are the most up-to-date. To extract this information from AnnotationHub, we can use the AnnotationHub ID to subset the object:\n\n# Extract annotations of interest\nhuman_ens &lt;- human_ens[[\"AH119325\"]]\n\nNow we can use ensembldb functions to extract the information at the gene, transcript, or exon levels. We are interested in the gene-level annotations, so we can extract that information as follows:\n\n# Extract gene-level information\ngenes(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n          gene_id   gene_name                       gene_biotype gene_seq_start\n1 ENSG00000290825    DDX11L16                             lncRNA          11121\n3 ENSG00000223972     DDX11L1 transcribed_unprocessed_pseudogene          12010\n4 ENSG00000310526      WASH7P                             lncRNA          14356\n5 ENSG00000227232      WASH7P transcribed_unprocessed_pseudogene          14696\n6 ENSG00000278267   MIR6859-1                              miRNA          17369\n7 ENSG00000243485 MIR1302-2HG                             lncRNA          28589\n  gene_seq_end seq_name seq_strand seq_coord_system\n1        24894        1          1       chromosome\n3        13670        1          1       chromosome\n4        30744        1         -1       chromosome\n5        24886        1         -1       chromosome\n6        17436        1         -1       chromosome\n7        31109        1          1       chromosome\n                                                                                      description\n1 DEAD/H-box helicase 11 like 16 (pseudogene) [Source:NCBI gene (formerly Entrezgene);Acc:727856]\n3                  DEAD/H-box helicase 11 like 1 (pseudogene) [Source:HGNC Symbol;Acc:HGNC:37102]\n4                           WASP family homolog 7, pseudogene [Source:HGNC Symbol;Acc:HGNC:38034]\n5                           WASP family homolog 7, pseudogene [Source:HGNC Symbol;Acc:HGNC:38034]\n6                                             microRNA 6859-1 [Source:HGNC Symbol;Acc:HGNC:50039]\n7                                         MIR1302-2 host gene [Source:HGNC Symbol;Acc:HGNC:52482]\n    gene_id_version canonical_transcript      symbol     entrezid\n1 ENSG00000290825.2      ENST00000832823    DDX11L16 727856, ....\n3 ENSG00000223972.6      ENST00000450305     DDX11L1           NA\n4 ENSG00000310526.1      ENST00000831140      WASH7P       653635\n5 ENSG00000227232.6      ENST00000488147      WASH7P           NA\n6 ENSG00000278267.1      ENST00000619216   MIR6859-1    102466751\n7 ENSG00000243485.6      ENST00000834618 MIR1302-2HG           NA\n\n\nBut note that it is just as easy to get the transcript- or exon-level information:\n\n# Extract transcript-level information\ntranscripts(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n            tx_id     tx_biotype tx_seq_start tx_seq_end tx_cds_seq_start\n1 ENST00000620701          snRNA            1        107               NA\n2 ENST00000634102 protein_coding            1      58864             5632\n3 ENST00000630811         lncRNA            1       7125               NA\n4 ENST00000622103          snRNA           12        118               NA\n5 ENST00000612589          snRNA           12        118               NA\n6 ENST00000610987          snRNA           12        118               NA\n  tx_cds_seq_end         gene_id tx_support_level     tx_id_version gc_content\n1             NA ENSG00000275782               NA ENST00000620701.1   42.99065\n2          57902 ENSG00000278550                1 ENST00000634102.1   59.15209\n3             NA ENSG00000280592                2 ENST00000630811.1   55.94758\n4             NA ENSG00000275021               NA ENST00000622103.1   42.99065\n5             NA ENSG00000275168               NA ENST00000612589.1   42.99065\n6             NA ENSG00000276552               NA ENST00000610987.1   42.99065\n  tx_external_name tx_is_canonical         tx_name\n1        U6.55-201               1 ENST00000620701\n2      SLC43A2-224               0 ENST00000634102\n3    LINC01624-216               1 ENST00000630811\n4        U6.47-201               1 ENST00000622103\n5        U6.49-201               1 ENST00000612589\n6        U6.61-201               1 ENST00000610987\n\n# Extract exon-level information\nexons(human_ens, return.type = \"data.frame\") %&gt;% head()\n\n          exon_id exon_seq_start exon_seq_end\n1 ENSE00003754250              1          107\n2 ENSE00003766135              1         2668\n3 ENSE00003783572              1         5793\n4 ENSE00003716605             12          118\n5 ENSE00003723881             12          118\n6 ENSE00003725167             12          118\n\n\nTo obtain an annotation data frame using AnnotationHub, we’ll use the genes() function, but only keep selected columns and filter out rows to keep those corresponding to our gene identifiers in our results file:\n\n# Create a gene-level dataframe \nannotations_ahb &lt;- genes(human_ens, return.type = \"data.frame\") %&gt;%\n  # Choose which columns to keep\n  dplyr::select(gene_id, gene_name, entrezid, gene_biotype) %&gt;%\n  # Choose which rows to keep (only genes that are in our overexpression results)\n  dplyr::filter(gene_id %in% res_tableOE_tb$gene)\n\nThis dataframe looks like it should be fine as it is, but we look a little closer we will notice that the column containing Entrez identifiers is a list, and in fact there are many Ensembl identifiers that map to more than one Entrez identifier!\n\n# Wait a second, we don't have one-to-one mappings!\nclass(annotations_ahb$entrezid)\n\n[1] \"list\"\n\nwhich(map(annotations_ahb$entrezid, length) &gt; 1) %&gt;% head()\n\nENSG00000186092 ENSG00000239149 ENSG00000229571 ENSG00000206652 ENSG00000158747 \n              9             407             432             529             604 \nENSG00000235200 \n           1835 \n\n\nSo what do we do here? And why do we have this problem? An answer from the Ensembl Help Desk is that this occurs when we cannot choose a perfect match; i.e., when we have two good matches, but one does not appear to match with a better percentage than the other. In that case, we assign both matches. What we will do is choose to keep the first identifier for these multiple mapping cases.\n\n# Only keep the first identifier in each list\nannotations_ahb$entrezid &lt;- map(annotations_ahb$entrezid, 1) %&gt;% unlist()\n\n\n\n\n\n\n\nNote\n\n\n\nNot all databases handle multiple mappings in the same way. For example, if we used the OrgDb instead of the EnsDb:\n\n# Pull annotations from OrgDb\nhuman_orgdb &lt;- query(ah, c(\"org.Hs.eg.db.sqlite\"))\nhuman_orgdb &lt;- human_orgdb[[\"AH116710\"]]\nannotations_orgdb &lt;- AnnotationDbi::select(human_orgdb, res_tableOE_tb$gene, c(\"SYMBOL\", \"GENENAME\", \"ENTREZID\"), \"ENSEMBL\")\n\nWe would find that multiple mapping entries would be automatically reduced to one-to-one. We would also find that more than half of the input genes do not return any annotations. This is because the OrgDb family of database are primarily based on mapping using Entrez Gene identifiers. Since our data is based on Ensembl mappings, using the OrgDb would result in a loss of information.\n\n\nLet’s take a look and see how many of our Ensembl identifiers have an associated gene symbol, and how many of them are unique:\n\n# Total Ensembl IDs with associated gene symbols\nwhich(!is.na(annotations_ahb$gene_name)) %&gt;% length()\n\n[1] 56427\n\n# Duplicated gene symbols\nwhich(duplicated(annotations_ahb$gene_name)) %&gt;% length()\n\n[1] 15814\n\n\nLet’s identify the non-duplicated genes and only keep the ones that are not duplicated:\n\n# Determine the indices for the non-duplicated genes\nnon_duplicates_idx &lt;- which(duplicated(annotations_ahb$gene_name) == FALSE)\n\n# How many rows does annotations_ahb have?\nannotations_ahb %&gt;% nrow()\n\n[1] 56427\n\n# Return only the non-duplicated genes using indices\nannotations_ahb &lt;- annotations_ahb[non_duplicates_idx, ]\n\n# How many rows are we left with after removing?\nannotations_ahb %&gt;% nrow()\n\n[1] 40613\n\n\nFinally, it would be good to know what proportion of the Ensembl identifiers map to an Entrez identifier:\n\n# Determine how many of the Entrez column entries are NA\nwhich(is.na(annotations_ahb$entrezid)) %&gt;% length()\n\n[1] 15969\n\n\nThat’s almost half of our genes! If we plan on using Entrez ID results for downstream analysis, we should definitely keep this in mind. If you look at some of the Ensembl IDs from our query that returned NA, these map to pseudogenes (e.g., ENSG00000265439) or non-coding RNAs (e.g., ENSG00000265425). The discrepancy (which we can expect to observe) between databases is due to the fact that each implements its own different computational approaches for generating the gene builds.\n\nUsing AnnotationHub to create our tx2gene file\nTo create our tx2gene file, we would need to use a combination of the methods above and merge two dataframes together. For example:\n\n## DO NOT RUN THIS CODE\n\n# Create a transcript dataframe\ntxdb &lt;- transcripts(human_ens, return.type = \"data.frame\") %&gt;%\n  dplyr::select(tx_id, gene_id)\ntxdb &lt;- txdb[grep(\"ENST\", txdb$tx_id),]\n\n# Create a gene-level dataframe\ngenedb &lt;- genes(human_ens, return.type = \"data.frame\")  %&gt;%\n  dplyr::select(gene_id, gene_name)\n\n# Merge the two dataframes together\nannotations &lt;- inner_join(txdb, genedb)\n\nIn this lesson our focus has been using annotation packages to extract information mainly just for gene ID conversion for the different tools that we use downstream. Many of the annotation packages we have presented have much more information than what we need for functional analysis, and we have only just scratched the surface here. It’s good to know the capabilities of the tools we use, so we encourage you to spend some time exploring these packages to become more familiar with them.\n\n\n\n\n\n\nNote\n\n\n\nThe annotables package is a super easy annotation package to use. It is not updated frequently, so it’s not great for getting the most up-to-date information for the current builds and does not have information for other organisms than human and mouse, but is a quick way to get annotation information.\n\n# Install package\nBiocManager::install(\"annotables\")\n\n# Load library\nlibrary(annotables)\n\n# Access previous build of annotations\ngrch38",
    "crumbs": [
      "Day 3 Self-learning",
      "Genomic annotations"
    ]
  },
  {
    "objectID": "lessons/Aside_top20_genes-expression_plotting.html",
    "href": "lessons/Aside_top20_genes-expression_plotting.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nUsing ggplot2 to plot multiple genes (e.g. top 20)\nOften it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling.\nWe are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values):\n\n# Order results by padj values\ntop20_sigOE_genes &lt;- res_tableOE_tb %&gt;% \n  arrange(padj) %&gt;% # Arrange rows by padj values\n  pull(gene) %&gt;%        # Extract character vector of ordered genes\n  head(n=20)            # Extract the first 20 genes\n\nThen, we can extract the normalized count values for these top 20 genes:\n\n# Get normalized counts for top 20 significant genes\ntop20_sigOE_norm &lt;- normalized_counts %&gt;%\n  filter(gene %in% top20_sigOE_genes)\n\nNow that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.\nThe gather() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth.\n\n\n# Gathering the columns to have normalized counts to a single column\ngathered_top20_sigOE &lt;- top20_sigOE_norm %&gt;%\n  gather(colnames(top20_sigOE_norm)[2:9], key = \"samplename\", value = \"normalized_counts\")\n\n# Check the column header in the \"gathered\" data frame\nhead(gathered_top20_sigOE)\n\n# A tibble: 6 × 4\n  gene            symbol samplename normalized_counts\n  &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;                  &lt;dbl&gt;\n1 ENSG00000089220 PEBP1  Irrel_kd_1             7289.\n2 ENSG00000096654 ZNF184 Irrel_kd_1              502.\n3 ENSG00000102317 RBM3   Irrel_kd_1             8550.\n4 ENSG00000104885 DOT1L  Irrel_kd_1             3680.\n5 ENSG00000112972 HMGCS1 Irrel_kd_1             9310.\n6 ENSG00000124762 CDKN1A Irrel_kd_1             1639.\n\n\nNow, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot():\n\n# Add metadata\ngathered_top20_sigOE &lt;- inner_join(mov10_meta, gathered_top20_sigOE)\n\nThe inner_join() will merge 2 data frames with respect to any column with the same column name in both data frames: in this case, the “samplename” column.\nNow that we have a data frame in a format that can be utilized by ggplot easily, let’s plot!\n\n# Plot using ggplot2\nggplot(gathered_top20_sigOE) +\n  geom_point(aes(x = symbol, y = normalized_counts, color = sampletype)) +\n  scale_y_log10() +\n  # Add title and plot tweaks\n  xlab(\"Genes\") +\n  ylab(\"log10 Normalized Counts\") +\n  ggtitle(\"Top 20 Significant DE Genes\") +\n  theme_bw() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  theme(plot.title = element_text(hjust = 0.5))"
  },
  {
    "objectID": "lessons/11_summarizing_results_Answers.html",
    "href": "lessons/11_summarizing_results_Answers.html",
    "title": "Summarizing results from the Wald test - Answer key",
    "section": "",
    "text": "Exercise 1\nMOV10 Differential Expression Analysis: Control versus Knockdown\nUsing the same p-adjusted threshold as above (padj.cutoff &lt; 0.05), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.\n\n# Create a tibble of results\nres_tableKD_tb &lt;- res_tableKD %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;% \n  as_tibble()\n\nHow many genes are differentially expressed in the Knockdown compared to Control? How does this compare to the overexpression significant gene list (in terms of numbers)?\n\n# Subset the tibble to keep only significant genes\nsigKD &lt;- res_tableKD_tb %&gt;%\n  dplyr::filter(padj &lt; padj.cutoff)\n\nThere are rnrow(sigKD) genes differentially expressed in the Knockdown compared to Control, and 4774 genes differentially expressed in the Overexpression compared to Control. Therefore, fewer genes are present in the Knockdown significant gene list."
  },
  {
    "objectID": "lessons/07_design_formulas.html",
    "href": "lessons/07_design_formulas.html",
    "title": "Design formulas for differential expression analysis in DESeq2",
    "section": "",
    "text": "Approximate time: 30 minutes",
    "crumbs": [
      "Day 2:",
      "Design formulas for differential expression analysis in DESeq2"
    ]
  },
  {
    "objectID": "lessons/07_design_formulas.html#learning-objectives",
    "href": "lessons/07_design_formulas.html#learning-objectives",
    "title": "Design formulas for differential expression analysis in DESeq2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDemonstrate the use of the design formula with simple and complex designs\nConstruct R code to execute the differential expression analysis workflow with DESeq2",
    "crumbs": [
      "Day 2:",
      "Design formulas for differential expression analysis in DESeq2"
    ]
  },
  {
    "objectID": "lessons/07_design_formulas.html#running-deseq2",
    "href": "lessons/07_design_formulas.html#running-deseq2",
    "title": "Design formulas for differential expression analysis in DESeq2",
    "section": "Running DESeq2",
    "text": "Running DESeq2\nPrior to performing the differential expression analysis, it is a good idea to know what sources of variation are present in your data, either by exploration during the QC and/or prior knowledge. Once you know the major sources of variation, you can remove them prior to analysis or control for them in the statistical model by including them in your design formula.\nThis step is critical as each additional factor in your design formula reduces your power. HOWEVER, failing to include important sources of variation can give you inaccurate results.\n\nDesign formula\nA design formula tells the statistical software which sources of variation to test for. This includes both your factor of interest as well as any additional covariates that are sources of variation. For example, if you know that sex is a significant source of variation in your data, then sex should be included in your model. The design formula should have all of the factors in your metadata that account for major sources of variation in your data.\nFor example, suppose you have the following metadata:\n\n\n\nIf you want to examine the expression differences between treatments, and you know that major sources of variation include sex and age, then your design formula would be:\ndesign = ~ sex + age + treatment\nThe tilde (~) should always precede your factors and tells DESeq2 to model the counts using the following formula. Note the factors included in the design formula need to match the column names in the metadata.\n\n\n\n\n\n\nDoes the order of variables matter?\n\n\n\nIn short, the order of variables in your design formula will not change the final results (i.e., the coefficients returned are the always the same). Typically, it has been best practice to list the variable that is your main effect in the last position of your design formula. In this way, the default result that is returned to you when using the results() function will be for your main effect.\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\n\nSuppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written?\nBased on our Mov10 metadata dataframe, which factors could we include in our design formula?\nWhat would you do if you wanted to include a factor in your design formula that is not in your metadata?\n\n\n\n\nComplex designs\nDESeq2 also allows for the analysis of complex designs. You can explore interactions or ‘the difference of differences’ by specifying for it in the design formula. For example, if you wanted to explore the effect of sex on the treatment effect, you could specify for it in the design formula as follows:\ndesign = ~ sex + age + treatment + sex:treatment\nThere are additional recommendations for complex designs in the DESeq2 vignette. In addition, Limma documentation offers additional insight into creating more complex design formulas.\n\n\n\n\n\n\nNote\n\n\n\nNeed help figuring out what information should be present in your metadata? We have additional materials highlighting bulk RNA-seq planning considerations. Please take a look at these materials before starting an experiment to help with proper experimental design.\n\n\n\n\n\nMOV10 DE analysis\nNow that we know how to specify the model to DESeq2, we can run the differential expression pipeline on the raw counts.\nTo get our differential expression results from our raw count data, we only need to run 2 lines of code!\nFirst we create a DESeqDataSet as we did in the ‘Count normalization’ lesson and specify the txi object that contains our raw counts, the metadata variable, and provide our design formula:\n\n# Create DESeq2Dataset object\ndds &lt;- DESeqDataSetFromTximport(txi, colData = meta, design = ~ sampletype)\n\nThen, to run the actual differential expression analysis, we use a single call to the function DESeq().\n\n# Run analysis\ndds &lt;- DESeq(dds)\n\nBy re-assigning the results of the function back to the same variable name (dds), we can fill in the slots of our DESeqDataSet object.\n\n\n\nEverything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs:\n\n\nestimating size factors\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\n\nWe will discuss what is occurring in each of these steps in the next few lessons, but the code to execute these steps is encompassed in the two lines above.\n\n\n\n\n\n\nNote\n\n\n\nThere are individual functions available in DESeq2 that would allow us to carry out each step in the workflow in a step-wise manner, rather than a single call. We demonstrated one example when generating size factors to create a normalized matrix. By calling DESeq(), the individual functions for each step are run for you.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nLet’s suppose our experiment has the following metadata:\n\n\n\n\ngenotype\ntreatment\n\n\n\n\nsample1\nWT\nev\n\n\nsample2\nWT\nev\n\n\nsample3\nWT\nev\n\n\nsample4\nWT\nev\n\n\nsample5\nKO_geneA\nev\n\n\nsample6\nKO_geneA\nev\n\n\nsample7\nKO_geneA\nev\n\n\nsample8\nKO_geneA\nev\n\n\nsample9\nWT\ntreated\n\n\nsample10\nWT\ntreated\n\n\nsample11\nWT\ntreated\n\n\nsample12\nWT\ntreated\n\n\nsample13\nKO_geneA\ntreated\n\n\nsample14\nKO_geneA\ntreated\n\n\nsample15\nKO_geneA\ntreated\n\n\nsample16\nKO_geneA\ntreated\n\n\n\nHow would the design formula be structured to perform the following analyses?\n\nTest for the effect of treatment.\nTest for the effect of genotype, while regressing out the variation due to treatment.\nTest for the effect of genotype on the treatment effects.",
    "crumbs": [
      "Day 2:",
      "Design formulas for differential expression analysis in DESeq2"
    ]
  }
]